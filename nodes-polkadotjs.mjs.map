{"version":3,"sources":["_init.js","NodeToast.js","Connection/Extension.js","SubstrateNodes.js","generator.js","Connection/HTTP.js","Connection/WebSocket.js","Constant/generator.js","Convert/Mnemonic.js","Data/Sign.js","Data/Verify.js","Events/Blocks.js","Extrinsics/generator.js","Keyring/RandomSeed.js","Storage/generator.js","Transaction/Batch.js","Transaction/PaymentInfo.js","Transaction/Send.js","Account/Transfer/Balance.js","Convert/Address To/Address.js","Convert/Address To/Uint8Array.js","Convert/String To/Uint8Array.js","Convert/Uint8Array To/Hex.js","Convert/Uint8Array To/String.js","Events/Account/Balance.js","Extension/Get/Signer.js","Keyring/Create/Keypair.js","Keyring/Create/Keyring.js","Keyring/Create/Mnemonic.js","Keyring/Create/Seed.js"],"names":["_class","_class2","_class3","_class4","_class5","_class6","_class7","_class8","_class9","_class10","_class11","_class12","_class13","_class14","_class15","_class16","_class17","_class18","_class19","_class20","_class21","_class22","_class23","window","globalThis","async","imports","urls","sf","loader","mjs","Promise","all","map","v","import","task","polkadotApi","polkadotKeyring","polkadotTypes","polkadotUtilCrypto","polkadotUtil","polkadotExtensionDapp","Blackprint","loadScope","url","hasInterface","hasDocs","crypto","Environment","loadFromURL","isNode","webcrypto","addEventListener","e","console","log","setTimeout","process","exit","path","cwd","isBrowser","_remoteModule","push","js","ordered","i","length","Context","createContext","EventSlot","slot","_internalKeyring","Keyring","type","ss58Format","Transaction","constructor","txn","api","isBatch","this","Signer","isPair","address","signer","utils","renameTypeName","ApiPromise","WsProvider","HttpProvider","_extensionEnabled","NodeToast","iface","clear","haveInfo","destroy","haveWarn","haveError","_reduceText","text","replace","full","slice","info","$decoration","temp","_raw","warn","error","success","SubstrateMetadata","SubstrateSubscriber","SubmitAndWatchExtrinsic","Subscribe","SubscribeAllHeads","SubscribeFinalizedHeads","SubscribeJustifications","SubscribeNewHeads","SubscribeRuntimeVersion","SubscribeStorage","TypeAny","Types","Any","SubstrateTypeData","AccountId","String","ApplyExtrinsicResult","BeefySignedCommitment","BlockHash","BlockNumber","Number","Bytes","ChainProperties","ChainType","ContractCallRequest","ContractExecResult","ContractInstantiateResult","CreatedBlock","EthAccount","EthCallRequest","EthFilter","EthFilterChanges","EthLog","EthReceipt","EthRichBlock","EthSubKind","EthSubParams","EthSyncStatus","EthTransaction","EthTransactionRequest","EthWork","Extrinsic","ExtrinsicOrHash","ExtrinsicStatus","FeeDetails","H64","H160","H256","Hash","Header","EncodedFinalityProofs","Health","Index","InstantiateRequest","Json","Justification","JustificationNotification","KeyValue","Object","Metadata","MmrLeafProof","NetworkState","NodeRole","Null","PeerInfo","PrefixedStorageKey","ReadProof","ReportedRoundStates","RpcMethods","RuntimeDispatchInfo","RuntimeVersion","SignedBlock","StorageChangeSet","StorageData","StorageKey","StorageKind","SyncState","Text","TraceBlockResponse","U64","U256","bool","Boolean","u32","u64","functionParser","str","options","list","trim","split","funcName","args","returnType","isExtrinsics","isConst","argsName","typeAsName","join","name","argsObj","a","toUpperCase","optionalReturn","fillLooseType","key","wrapper","Substrate_BlackprintNodeGenerator","namespace","description","apiPath","funcs","that","func","test","loose","returnToField","preprocessType","portName","Finished","Trigger","RPCParams","keys","typeData","category","apiName","toLowerCase","defaultInput","API","Port","node","trigger","GeneratedNode","Node","instance","super","setInterface","title","_toast","update","Input","Output","ref","rpc_path","toast","obj","response","apply","message","OnFinish","undefined","value","skipSuggestTypeAny","isGenerated","output","input","assign","registerNode","resolve","ConnectionExtensionData","_dAppName","_iface","dAppName","val","syncOut","setEnumerablePrototype","imported","data","syncIn","ExtensionId","Default","Connect","connectExtension","Accounts","Array","IsAllowed","registerInterface","IFace","ConnectionExtension","Interface","wallet","injectedWeb3","_unsubscribe","_polkadot","web3Enable","web3AccountsSubscribe","accounts","web3Accounts","ConnectionHTTPData","_rpcURL","rpcURL","changeRPC","http","Provider","disconnect","Disconnected","Reconnect","Connected","ConnectionHTTP","provider","create","throwOnConnect","isConnected","ConnectionWebSocketData","ws","connect","Disconnect","ConnectionWebSocket","clearTimeout","_prepareAPIWait","initialized","on","init","Seed","mnemonicToMiniSecret","mnemonicValidate","Uint8Array","port","source","_fail","msg","Data","stringToU8a","sign","u8aToHex","stringToHex","signRaw","signing","hexToU8a","signature","Union","IsValid","Address","Signature","signatureVerify","isValid","IInput","unsubscribe","hasSubscriptions","rpc","chain","subscribeNewHeads","header","number","toNumber","EventsBlocks","randomAsU8a","keyring","KeyType","pair","Pair","addFromSeed","Txn","tx","utility","batchAll","ArrayOf","Sender","payment","queryInfo","paymentInfo","includes","Info","StructOf","Fee","handle","partialFee","Weight","weight","_onStatus","ev","status","dispatchError","n","events","BatchInterrupted","is","event","isModule","decoded","registry","findMetaError","asModule","docs","method","section","toString","Failed","Success","TxHash","txHash","Status","Nonce","nonce","signAndSend","Submit","submit","Value","isInteger","MAX_SAFE_INTEGER","balances","transfer","encodeAddress","ChainId","decodeAddress","In","Out","u8aToString","query","system","account","Free","free","Reserved","reserved","MiscFrozen","miscFrozen","FeeFrozen","feeFrozen","web3FromAddress","oldKeyring","_keyring","Keypair","removePair","Mnemonic","_mnemonic","cables","disconnectAll","addFromMnemonic","byteLength","currentKeyType","keyType","mnemonicGenerate"],"mappings":"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","file":"nodes-polkadotjs.mjs","sourcesContent":["// Let the Blackprint Editor know the source URL where\n// the registerNode and registerInterface belongs to\nvar Blackprint = window.Blackprint.loadScope({\n\t// You can find the URL on Blackprint menu -> Modules\n\t// This will also be exported to JSON if this module's nodes is being used\n\turl: import.meta.url,\n\n\t// This will autoload (*.sf.mjs) and (*.sf.css) file for Browser\n\thasInterface: true,\n\n\t// This will autoload (*.docs.json) for Browser\n\thasDocs: true,\n});\n\n// Prepare variable\nvar polkadotApi, polkadotKeyring, polkadotTypes, polkadotUtilCrypto, polkadotUtil, polkadotExtensionDapp;\n\n// Import for different environment\nlet crypto = window.crypto;\n\nif(Blackprint.Environment.loadFromURL === false) {\n\tif(Blackprint.Environment.isNode){\n\t\tcrypto = (await import('node:crypto')).webcrypto; // eslint-disable-line\n\n\t\t// Bugfix for polkadot.js's dependency library\n\t\twindow.addEventListener ??= ()=>{};\n\n\t\t// We can't use the bundled version because it's currently not for Node.js\n\t\ttry{\n\t\t\tpolkadotUtil = await import('@polkadot/util');\n\t\t\tpolkadotUtilCrypto = await import('@polkadot/util-crypto');\n\t\t\tpolkadotKeyring = await import('@polkadot/keyring');\n\t\t\tpolkadotTypes = await import('@polkadot/types');\n\t\t\tpolkadotApi = await import('@polkadot/api');\n\t\t} catch(e) {\n\t\t\tconsole.log(e);\n\t\t\tsetTimeout(() => process.exit(), 500);\n\t\t}\n\t}\n\telse{\n\t\t// Use the bundled version for Browser and Deno\n\t\tlet path = 'file:///'+process.cwd();\n\n\t\tawait import(path+'/node_modules/@polkadot/util/bundle-polkadot-util.js');\n\t\tawait import(path+'/node_modules/@polkadot/util-crypto/bundle-polkadot-util-crypto.js');\n\t\tawait import(path+'/node_modules/@polkadot/keyring/bundle-polkadot-keyring.js');\n\t\tawait import(path+'/node_modules/@polkadot/types/bundle-polkadot-types.js');\n\t\tawait import(path+'/node_modules/@polkadot/api/bundle-polkadot-api.js');\n\n\t\tif(Blackprint.Environment.isBrowser)\n\t\t\tawait import(path+'/node_modules/@polkadot/extension-dapp/bundle-polkadot-extension-dapp.js');\n\n\t\t({ polkadotApi, polkadotKeyring, polkadotTypes, polkadotUtilCrypto, polkadotUtil, polkadotExtensionDapp } = window);\n\t}\n}\n// Skip from coverage report as this only for Deno or Browser that load module from URL\n/* c8 ignore start */\nelse {\n\n\t/* Parallely load dependencies from CDN */\n\t// Use bundled file\n\t// This will be registered on global (window)\n\tlet _remoteModule = [\n\t\t\"https://cdn.jsdelivr.net/npm/@polkadot/util@^12/bundle-polkadot-util.min.js\",\n\t\t\"https://cdn.jsdelivr.net/npm/@polkadot/util-crypto@^12/bundle-polkadot-util-crypto.min.js\",\n\t\t\"https://cdn.jsdelivr.net/npm/@polkadot/keyring@^12/bundle-polkadot-keyring.min.js\",\n\t\t\"https://cdn.jsdelivr.net/npm/@polkadot/types@^10/bundle-polkadot-types.min.js\",\n\t\t\"https://cdn.jsdelivr.net/npm/@polkadot/api@^10/bundle-polkadot-api.min.js\",\n\t];\n\n\tif(window.Blackprint.Environment.isBrowser){\n\t\t_remoteModule.push(\"https://cdn.jsdelivr.net/npm/@polkadot/extension-dapp@^0.46/bundle-polkadot-extension-dapp.min.js\");\n\t}\n\n\tif(window.sf?.loader != null)\n\t\tawait sf.loader.js(_remoteModule, {ordered: true});\n\telse {\n\t\tfor (var i = 0; i < _remoteModule.length; i++)\n\t\t\tawait import(_remoteModule[i]);\n\t}\n\n\t({ polkadotApi, polkadotKeyring, polkadotTypes, polkadotUtilCrypto, polkadotUtil, polkadotExtensionDapp } = window); // eslint-disable-line\n}\n/* c8 ignore stop */\n\n// Global shared context\nvar Context = Blackprint.createContext('Polkadot.js');\n\n// This is needed to avoid duplicated event listener when using hot reload\n// Event listener that registered with same slot will be replaced\nContext.EventSlot = {slot: 'my-private-event-slot'};\n\n// internal Keyring that will be used by some node if not connected to any keyring\nContext._internalKeyring = new polkadotApi.Keyring({\n\ttype: 'ed25519',\n\tss58Format: 0,\n});\n\n// Custom class: for Port's type check\nclass Transaction {\n\tconstructor(txn, api, isBatch){\n\t\tthis.txn = txn;\n\t\tthis.api = api;\n\t\tthis.isBatch = isBatch;\n\t}\n}\n\nclass Signer {\n\tconstructor(isPair, address, signer){\n\t\tthis.isPair = isPair;\n\t\tthis.address = address;\n\t\tthis.signer = signer;\n\t}\n}\n\n\n// Fix minified class name\nBlackprint.utils.renameTypeName({\n\t'Transaction': Transaction,\n\t'Signer': Signer,\n\t'ApiPromise': polkadotApi.ApiPromise,\n\t'Keyring': polkadotApi.Keyring,\n\t'WsProvider': polkadotApi.WsProvider,\n\t'HttpProvider': polkadotApi.HttpProvider,\n});","/**\n * import { Context } from \"./_init.js\";\n */\n\n// Bootstrap for add toast on node decoration\nlet NodeToast = Context.NodeToast = class NodeToast { // eslint-disable-line\n\tconstructor(iface){\n\t\tthis.iface = iface;\n\t}\n\n\tclear(){\n\t\tif(this.haveInfo)\n\t\t\tthis.haveInfo.destroy();\n\t\tif(this.haveWarn)\n\t\t\tthis.haveWarn.destroy();\n\t\tif(this.haveError)\n\t\t\tthis.haveError.destroy();\n\n\t\tthis.haveInfo = false;\n\t\tthis.haveWarn = false;\n\t\tthis.haveError = false;\n\t}\n\n\t_reduceText(text){\n\t\treturn text.replace(/\\w{15,}/g, full => full.slice(0, 5)+'...');\n\t}\n\n\tinfo(text){\n\t\tif(!this.iface.$decoration) return;\n\t\tlet temp = text;\n\t\ttext = this._reduceText(text);\n\n\t\tif(this.haveInfo)\n\t\t\tthis.haveInfo.text = text;\n\t\telse\n\t\t\tthis.haveInfo = this.iface.$decoration.info(text);\n\n\t\tthis.haveInfo._raw = temp;\n\t}\n\n\twarn(text){\n\t\tif(!this.iface.$decoration) return;\n\t\tlet temp = text;\n\t\ttext = this._reduceText(text);\n\n\t\tif(this.haveWarn)\n\t\t\tthis.haveWarn.text = text;\n\t\telse\n\t\t\tthis.haveWarn = this.iface.$decoration.warn(text);\n\n\t\tthis.haveWarn._raw = temp;\n\t}\n\n\terror(text){\n\t\tif(!this.iface.$decoration) return;\n\t\tlet temp = text;\n\t\ttext = this._reduceText(text);\n\n\t\tif(this.haveError)\n\t\t\tthis.haveError.text = text;\n\t\telse\n\t\t\tthis.haveError = this.iface.$decoration.error(text);\n\n\t\tthis.haveError._raw = temp;\n\t}\n\n\tsuccess(text){\n\t\tif(!this.iface.$decoration) return;\n\t\tlet ref = this.iface.$decoration.success(this._reduceText(text));\n\t\tref._raw = text;\n\t}\n}","/**\n * import { Context } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotExtensionDapp, polkadotApi } = window\n */\n\nlet _extensionEnabled;\nContext._extensionEnabled = new Promise(resolve=> _extensionEnabled = resolve);\n\n\n// For storing node data\nclass ConnectionExtensionData {\n\tconstructor(iface){this._iface = iface}\n\n\t_dAppName = 'BP-Polkadot.js';\n\tget dAppName(){return this._dAppName}\n\tset dAppName(val){\n\t\tthis._dAppName = val;\n\n\t\t// Already throttled before being synced to remote\n\t\tthis._iface.node.syncOut('dAppName', val);\n\t}\n}\n\n// Make sure the property that can be exported to JSON is visible/enumerable\nBlackprint.utils.setEnumerablePrototype(ConnectionExtensionData, {\n\tdAppName: true,\n});\n\n/**\n * Connect a wallet from browser extension\n * @blackprint node\n * @summary Connect wallet from browser\n */\nBlackprint.registerNode(\"Polkadot.js/Connection/Extension\",\nclass ExtensionNode extends Blackprint.Node {\n\t// Input port\n\tstatic input = {\n\t\t/**\n\t\t * Extension's id\n\t\t * \n\t\t * If you're using Polkadot{.js} browser extension\n\t\t * The id is `polkadot-js`\n\t\t */\n\t\tExtensionId: Blackprint.Port.Default(String, 'polkadot-js'),\n\t\t/** Request the connection */\n\t\tConnect: Blackprint.Port.Trigger(function({ iface }){\n\t\t\tiface.connectExtension();\n\t\t}),\n\t};\n\n\t// Output port\n\tstatic output = {\n\t\t/** Wallet accounts from browser extension */\n\t\tAccounts: Array,\n\t\t/** Return true if user was allowed access to browser extension */\n\t\tIsAllowed: Boolean,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\t// Use custom interface\n\t\t// Engine: scroll down this file to \"Blackprint.registerInterface\"\n\t\t// Browser: ./Extension.sf\n\t\tlet iface = this.setInterface('BPIC/Polkadot.js/Connection/Extension');\n\t\tiface.title = \"Browser Wallet\";\n\t}\n\n\t// This will be called by the engine once the node has been loaded, but no cable connected\n\timported(data){\n\t\tif(!data) return;\n\t\tObject.assign(this.iface.data, data);\n\t}\n\n\t// Add support for remote control/collaborative editor mode\n\tsyncIn(type, data){\n\t\tif(type === 'dAppName')\n\t\t\tthis.iface.data.dAppName = data;\n\t}\n});\n\n\n// Register Blackprint Interface (like an API for developer, or UI for sketch editor)\nBlackprint.registerInterface('BPIC/Polkadot.js/Connection/Extension',\nContext.IFace.ConnectionExtension = class ExtensionIFace extends Blackprint.Interface {\n\tconstructor(node){\n\t\tsuper(node);\n\t\tthis.data = new ConnectionExtensionData(this);\n\n\t\tthis._toast = new NodeToast(this);\n\t\tthis._toast.warn(\"Disconnected\");\n\t}\n\n\t// This will be called if `Connect` port has been triggered\n\tasync connectExtension(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet toast = this._toast;\n\n\t\tif(!Input.ExtensionId){\n\t\t\tconsole.error(\"ExtensionId is required\");\n\t\t\treturn toast.error(\"ExtensionId is required\");\n\t\t}\n\n\t\tlet wallet = window.injectedWeb3?.[Input.ExtensionId];\n\t\tif(wallet === void 0){\n\t\t\tconsole.error(\"Extension (with id: \"+ Input.ExtensionId +\") was not found\");\n\t\t\treturn toast.error(\"Extension (with id: \"+ Input.ExtensionId +\") was not found\");\n\t\t}\n\n\t\ttoast.clear();\n\t\ttoast.warn(\"Asking for Permission\");\n\n\t\t// Unsubscribe from the last extension if the connection was exist\n\t\tthis._unsubscribe?.();\n\n\t\ttry{\n\t\t\tthis._polkadot = await polkadotExtensionDapp.web3Enable(this.data.dAppName);\n\t\t} catch(e) {\n\t\t\tconsole.error(e.message);\n\t\t\ttoast.error(e.message);\n\t\t\tOutput.IsAllowed = false;\n\t\t\treturn;\n\t\t}\n\n\t\tif(this._polkadot.length === 0){\n\t\t\tOutput.IsAllowed = false;\n\t\t\ttoast.clear();\n\t\t\ttoast.warn(\"Access Rejected\");\n\t\t\treturn;\n\t\t}\n\n\t\ttoast.clear();\n\t\ttoast.success(\"Access Granted\");\n\n\t\t_extensionEnabled();\n\t\tContext._extensionEnabled = true;\n\n\t\tthis._unsubscribe = await polkadotExtensionDapp.web3AccountsSubscribe(accounts => {\n\t\t\tOutput.Accounts = accounts;\n\t\t});\n\n\t\tOutput.Accounts = await polkadotExtensionDapp.web3Accounts();\n\t\tOutput.IsAllowed = true;\n\t}\n\n\t// This will be called by the engine when this node is deleted\n\tdestroy(){\n\t\t// Unsubscribe to event listener if exist\n\t\ttry{\n\t\t\tthis._unsubscribe?.();\n\t\t} catch(e) {\n\t\t\tconsole.error(e);\n\t\t}\n\t}\n});","// Work in progress\n// Set this to true to enable this generator\nlet SubstrateMetadata = true;\n\n// Watch/Subscribe will be an event\nlet SubstrateSubscriber = {\n\tSubmitAndWatchExtrinsic: \"author\",\n\tSubscribe: \"eth\",\n\tSubscribeAllHeads: \"chain\",\n\tSubscribeFinalizedHeads: \"chain\",\n\tSubscribeJustifications: \"grandpa\",\n\tSubscribeNewHeads: \"chain\",\n\tSubscribeRuntimeVersion: \"state\",\n\tSubscribeStorage: \"state\",\n};\n\nlet TypeAny = Blackprint.Types.Any;\n\n// ToDo: Type mapping (Rust Types => JavaScript Types)\n// Vec => Array\n// HashMap => Map\n// Option => can be null or have a value (optional)\nlet SubstrateTypeData = {\n\t'AccountId': String,\n\t'ApplyExtrinsicResult': TypeAny,\n\t'BeefySignedCommitment': TypeAny,\n\t'BlockHash': TypeAny,\n\t'BlockNumber': Number,\n\t'Bytes': String,\n\t'ChainProperties': TypeAny,\n\t'ChainType': TypeAny,\n\t'ContractCallRequest': TypeAny,\n\t'ContractExecResult': TypeAny,\n\t'ContractInstantiateResult': TypeAny,\n\t'CreatedBlock': TypeAny,\n\t'EthAccount': TypeAny,\n\t'EthCallRequest': TypeAny,\n\t'EthFilter': TypeAny,\n\t'EthFilterChanges': TypeAny,\n\t'EthLog': TypeAny,\n\t'EthReceipt': TypeAny,\n\t'EthRichBlock': TypeAny,\n\t'EthSubKind': TypeAny,\n\t'EthSubParams': TypeAny,\n\t'EthSyncStatus': TypeAny,\n\t'EthTransaction': TypeAny,\n\t'EthTransactionRequest': TypeAny,\n\t'EthWork': TypeAny,\n\t'Extrinsic': TypeAny,\n\t'ExtrinsicOrHash': TypeAny,\n\t'ExtrinsicStatus': TypeAny,\n\t'FeeDetails': TypeAny,\n\t'H64': String,\n\t'H160': String,\n\t'H256': String,\n\t'Hash': String,\n\t'HashMap<AuthorityId,EpochAuthorship>': TypeAny, // ToDo: HashMap<A, B> => (Map[A] = B)\n\t'Header': TypeAny,\n\t'EncodedFinalityProofs': TypeAny,\n\t'Health': TypeAny,\n\t'Index': TypeAny,\n\t'InstantiateRequest': TypeAny,\n\t'Json': TypeAny,\n\t'Justification': TypeAny,\n\t'JustificationNotification': TypeAny,\n\t'KeyValue': Object,\n\t'Metadata': TypeAny,\n\t'MmrLeafProof': TypeAny,\n\t'NetworkState': TypeAny,\n\t'NodeRole': TypeAny,\n\t'Null': TypeAny,\n\t'PeerInfo': TypeAny,\n\t'PrefixedStorageKey': TypeAny,\n\t'ReadProof': TypeAny,\n\t'ReportedRoundStates': TypeAny,\n\t'RpcMethods': TypeAny,\n\t'RuntimeDispatchInfo': TypeAny,\n\t'RuntimeVersion': TypeAny,\n\t'SignedBlock': TypeAny,\n\t'StorageChangeSet': TypeAny,\n\t'StorageData': TypeAny,\n\t'StorageKey': TypeAny,\n\t'StorageKind': TypeAny,\n\t'String': String,\n\t'SyncState': TypeAny,\n\t'Text': String,\n\t'TraceBlockResponse': TypeAny,\n\t'U64': Number,\n\t'U256': Number,\n\t'bool': Boolean,\n\t'u32': Number,\n\t'u64': Number,\n};\n\n/**\n * For extracting function name, parameter, and return types\n * @param  String str function list to be extracted\n * @return Array\n */\nfunction functionParser(str, options){\n\t// Clean the spaces and split the new line\n\tlet list = str.trim().replace(/\\t+| /g, '').split('\\n');\n\n\t// For each lines\n\tfor (var i = 0; i < list.length; i++) {\n\t\tlet temp = list[i];\n\t\tlet funcName, args, returnType;\n\n\t\t// Implementation below can be replaced with RegExp, but more complicated I think\n\n\t\t// For Substrate Extrinsics that doesn't return value\n\t\tif(options.isExtrinsics)\n\t\t\ttemp += ':Null';\n\n\t\t// For Substrate Constants\n\t\tif(options.isConst)\n\t\t\ttemp = temp.replace(':', '():');\n\n\t\t// Separate name, parameter, and types\n\t\t// ex: hasSessionKeys(sessionKeys:Bytes):bool\n\t\t([temp, returnType] = temp.split('):'));\n\t\t([funcName, args] = temp.split('('));\n\n\t\tif(args === void 0) console.error(`Incorrect format \"${temp}\", `);\n\n\t\tlet argsName = [];\n\t\tif(!options.typeAsName){\n\t\t\t// Get the parameters/arguments name\n\t\t\targs = args.replace(/,?([a-zA-Z0-9_?]+):/g, function(full, name){\n\t\t\t\targsName.push(name);\n\t\t\t\treturn ';;'; // Remove the parameter name from the text\n\t\t\t})\n\t\t\t.replace(/^;;/m, ''); // Remove the first ';;'\n\t\t}\n\t\telse{\n\t\t\ttry {\n\t\t\t\targsName = args.split(',');\n\t\t\t\targs = argsName.join(';;');\n\t\t\t} catch(e) {\n\t\t\t\tconsole.error(`Incorrect format \"${temp}\", `, e);\n\t\t\t}\n\t\t}\n\n\t\t// Let's obtain the function parameter's type data\n\t\tlet argsObj = {};\n\t\tif(args !== ''){\n\t\t\targs = args.split(';;');\n\n\t\t\t// For each type data on the parameters\n\t\t\tfor (var a = 0; a < args.length; a++) {\n\t\t\t\tlet name = argsName[a];\n\n\t\t\t\t// Capitalize first word and assign it to argsObj\n\t\t\t\t// SessionKeys => Bytes\n\t\t\t\tname = name.slice(0, 1).toUpperCase() + name.slice(1);\n\t\t\t\targs[a] = args[a].replace(/^Option<(.*?)>$/m, (full, type) => {\n\t\t\t\t\tname += '?';\n\t\t\t\t\treturn type;\n\t\t\t\t});\n\n\t\t\t\targsObj[name] = args[a];\n\t\t\t}\n\t\t}\n\n\t\tlet optionalReturn = false;\n\t\treturnType = returnType.replace(/Option<(.*?)>$/m, (full, type) => {\n\t\t\toptionalReturn = true;\n\t\t\treturn type;\n\t\t});\n\n\t\t// ToDo: reconsider\n\t\treturnType = returnType.replace(/(Vec|HashMap)<(.*?)>$/m, fillLooseType);\n\t\tfor(let key in argsObj)\n\t\t\targsObj[key] = argsObj[key].replace(/(Vec|HashMap)<(.*?)>$/m, fillLooseType);\n\n\t\t// Put the extraction in the 'list'\n\t\tlist[i] = {\n\t\t\tname: funcName.slice(0, 1).toUpperCase() + funcName.slice(1),\n\t\t\targs: argsObj,\n\t\t\treturnType,\n\t\t\toptionalReturn,\n\t\t};\n\t}\n\n\treturn list;\n}\n\t\t\nfunction fillLooseType(full, wrapper, type){\n\tif(SubstrateTypeData[type] != null) return type;\n\n\tif(wrapper === 'HashMap')\n\t\tSubstrateTypeData[type] = Object;\n\t// else if(wrapper === 'Vec')\n\t// \tSubstrateTypeData[type] = Array;\n\n\treturn type;\n}\n\n/**\n * Generate Blackprint nodes for Substrate RPC\n * @param Array list [description]\n */\nfunction Substrate_BlackprintNodeGenerator(options, list){ // eslint-disable-line\n\tif(SubstrateMetadata === false) return;\n\n\tlet { namespace, description, apiPath, isConst, isExtrinsics } = options;\n\n\t// For each array items\n\tfor (var i = 0; i < list.length; i++) {\n\t\tlet temp = list[i];\n\t\tlet funcs = functionParser(temp.funcs, options);\n\n\t\t// For each extracted function from the string\n\t\tthat: for (var a = 0; a < funcs.length; a++) {\n\t\t\tlet func = funcs[a];\n\n\t\t\t// Skip subscribe or watch because it was an event\n\t\t\t// We will create separate nodes to handle subscribe/unsubscribe\n\t\t\tif(/subscribe|watch/i.test(func.name) && !options.loose){\n\t\t\t\tif(SubstrateSubscriber[func.name] === void 0)\n\t\t\t\t\tconsole.error(`Substrate subscriber for \"${func.name}\" was not found`);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If you found error from this line, then the SubstrateTypeData need to be updated\n\t\t\tif(SubstrateTypeData[func.returnType] === void 0 && !options.loose){\n\t\t\t\tconsole.error(`Substrate type data for \"${func.returnType}\" was not found`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\n\t\t\t// Type mapping (Rust Types => JavaScript Types)\n\t\t\tlet returnToField = func.returnType;\n\t\t\tlet preprocessType = TypeAny;\n\t\t\tif(func.returnType !== 'Null'){\n\t\t\t\t// Simplify port name\n\t\t\t\tlet portName = func.returnType\n\t\t\t\t\t.replace(/(Vec|HashMap)<(.*?)>$/m, function(full, wrapper, type){\n\t\t\t\t\t\tif(wrapper === 'Vec') return type;\n\n\t\t\t\t\t\t// ToDO: HashMap\n\t\t\t\t\t\treturn type;\n\t\t\t\t\t});\n\n\t\t\t\tif(options.loose && SubstrateTypeData[func.returnType] === void 0)\n\t\t\t\t\tSubstrateTypeData[func.returnType] = TypeAny;\n\n\t\t\t\tpreprocessType = SubstrateTypeData[func.returnType];\n\n\t\t\t\tif(preprocessType !== Number && preprocessType !== String && preprocessType !== Boolean)\n\t\t\t\t\tpreprocessType = TypeAny;\n\n\t\t\t\tif(preprocessType == null)\n\t\t\t\t\tpreprocessType = TypeAny;\n\n\t\t\t\tif(func.optionalReturn)\n\t\t\t\t\tportName += '?';\n\n\t\t\t\t// This will be used as output port\n\t\t\t\t// port name => type\n\t\t\t\tfunc.returnType = {\n\t\t\t\t\t[portName]: SubstrateTypeData[func.returnType]\n\t\t\t\t};\n\n\t\t\t\treturnToField = portName;\n\t\t\t}\n\t\t\telse func.returnType = void 0; // Didn't return data\n\n\t\t\tif(isExtrinsics)\n\t\t\t\tfunc.returnType = {Finished: Blackprint.Types.Trigger};\n\n\t\t\t// Type mapping (Rust Types => JavaScript Types)\n\t\t\tlet args = func.args;\n\t\t\tlet RPCParams = Object.keys(args);\n\t\t\tfor(let portName in args){\n\t\t\t\tlet typeData = args[portName];\n\n\t\t\t\tif(options.loose && SubstrateTypeData[typeData] === void 0)\n\t\t\t\t\tSubstrateTypeData[typeData] = TypeAny;\n\n\t\t\t\t// If you found error from this line, then the SubstrateTypeData need to be updated\n\t\t\t\tif(SubstrateTypeData[typeData] === void 0){\n\t\t\t\t\tconsole.error(`Substrate type data for \"${typeData}\" was not found`);\n\t\t\t\t\tcontinue that;\n\t\t\t\t}\n\n\t\t\t\t// This will be used as input port\n\t\t\t\t// port name => type\n\t\t\t\targs[portName] = SubstrateTypeData[typeData];\n\t\t\t}\n\n\t\t\t// Categorizing Blackprint Node's path by function name\n\t\t\tlet funcName = func.name\n\t\t\t.replace(/By([A-Z].*)/, function(full, name){\n\t\t\t\treturn 'By/'+name;\n\t\t\t})\n\t\t\t.replace(/^(Get|Set|Has|New)([A-Z].*)/, function(full, category, name){\n\t\t\t\treturn category + '/' +name;\n\t\t\t});\n\n\t\t\t// Capitalize the first character\n\t\t\tlet apiName = func.name.slice(0, 1).toLowerCase() + func.name.slice(1);\n\n\t\t\tlet defaultInput = {\n\t\t\t\tAPI: polkadotApi.ApiPromise,\n\t\t\t\tTrigger: Blackprint.Port.Trigger(function({ iface }){\n\t\t\t\t\tiface.node.trigger(); // => async trigger()\n\t\t\t\t})\n\t\t\t};\n\n\t\t\t// For Substrate Constants\n\t\t\tif(isConst) delete defaultInput.Trigger;\n\n\t\t\tif(func.optionalReturn){\n\t\t\t\tlet temp = {};\n\t\t\t\tfor (let key in func.returnType)\n\t\t\t\t\ttemp[key.replace('?', '')] = func.returnType[key];\n\n\t\t\t\tfunc.returnType = temp;\n\t\t\t}\n\n\t\t\t// Custom Node class\n\t\t\tclass GeneratedNode extends Blackprint.Node {\n\t\t\t\tstatic skipSuggestTypeAny = true; // Because some of type still using many Type.Any, let's skip the suggestion\n\t\t\t\tstatic isGenerated = true;\n\n\t\t\t\t// Output port, this can be undefined if return nothing (no output port)\n\t\t\t\tstatic output = func.returnType;\n\n\t\t\t\t// Input port for each nodes\n\t\t\t\tstatic input = Object.assign(defaultInput, args);\n\n\t\t\t\tconstructor(instance){\n\t\t\t\t\tsuper(instance);\n\n\t\t\t\t\t// Use default interface\n\t\t\t\t\tlet iface = this.setInterface();\n\t\t\t\t\tiface.title = `${temp.name} ${func.name}`; // ex: Author HasKey\n\t\t\t\t\tiface.description = description;\n\n\t\t\t\t\t// For showing toast above the node\n\t\t\t\t\tthis._toast = new NodeToast(iface);\n\t\t\t\t}\n\n\t\t\t\t// This will be called by the engine if the input port have a new value\n\t\t\t\tupdate(){\n\t\t\t\t\tlet {Input, Output} = this.ref; // Shortcut\n\t\t\t\t\tthis._toast.clear();\n\n\t\t\t\t\tif(Input.API != null){\n\t\t\t\t\t\tif(Input.API[apiPath][temp.rpc_path]?.[apiName] == null){\n\t\t\t\t\t\t\tthis._toast.error(\"This network doesn't support this feature\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(!isExtrinsics){\n\t\t\t\t\t\tOutput[returnToField] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// For Substrate Constants\n\t\t\t\t\tif(isConst) this.trigger();\n\t\t\t\t}\n\n\t\t\t\t// This will be triggered from input port (input.Trigger)\n\t\t\t\tasync trigger(){\n\t\t\t\t\tlet {Input, Output} = this.ref; // Shortcut\n\t\t\t\t\tlet toast = this._toast;\n\n\t\t\t\t\tif(Input.API === null)\n\t\t\t\t\t\treturn toast.warn(\"API is required\");\n\n\t\t\t\t\t// Get reference, ex: rpc_path = author\n\t\t\t\t\tlet obj = Input.API[apiPath][temp.rpc_path];\n\n\t\t\t\t\tif(obj == null) return toast.error(\"This network doesn't support this feature\");\n\n\t\t\t\t\t// Prepare arguments before calling the Polkadot.js's RPC function\n\t\t\t\t\tlet args = [];\n\t\t\t\t\tfor (var i = 0; i < RPCParams.length; i++) {\n\t\t\t\t\t\targs.push(Input[RPCParams[i]]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Call the RPC function and put the result to the output port\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar response = isConst ? obj[apiName] : await obj[apiName].apply(obj, args);\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\tOutput[returnToField] = null;\n\t\t\t\t\t\ttoast.error(e.message);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(isExtrinsics){\n\t\t\t\t\t\tOutput.OnFinish();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(preprocessType !== TypeAny)\n\t\t\t\t\t\tresponse = preprocessType(response);\n\t\t\t\t\t\n\t\t\t\t\tif(response.value !== undefined)\n\t\t\t\t\t\tresponse = response.value;\n\n\t\t\t\t\t// ToDo: should we use type data's name as the port name?\n\t\t\t\t\tOutput[returnToField] = response;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Register it as Blackprint Node\n\t\t\tBlackprint.registerNode(`Polkadot.js/${namespace}/${temp.name}/${funcName}`, GeneratedNode);\n\t\t}\n\t}\n}","/**\n * import { Substrate_BlackprintNodeGenerator } from \"../utils/SubstrateNodes.js\";\n */\n\n// Work in progress and untested nodes\n// Please expect changes on the port's name and type data on the future\n\n// https://polkadot.js.org/docs/substrate/rpc\n// The parameters will be input port, and the returned data will be the output port\n// The function name will be the node's name (ex: Author HasKey)\nSubstrate_BlackprintNodeGenerator({\n\tnamespace: 'RPC',\n\tdescription: '[Experimental] Substrate JSON-RPC',\n\tapiPath: 'rpc'\n}, [\n\t{\n\t\tname: \"Author\", rpc_path: \"author\",\n\t\tfuncs: `\n\t\t\thasKey(publicKey: Bytes, keyType: Text): bool\n\t\t\thasSessionKeys(sessionKeys: Bytes): bool\n\t\t\tinsertKey(keyType: Text, suri: Text, publicKey: Bytes): Bytes\n\t\t\tpendingExtrinsics(): Vec<Extrinsic>\n\t\t\tremoveExtrinsic(bytesOrHash: Vec<ExtrinsicOrHash>): Vec<Hash>\n\t\t\trotateKeys(): Bytes\n\t\t\tsubmitAndWatchExtrinsic(extrinsic: Extrinsic): ExtrinsicStatus\n\t\t\tsubmitExtrinsic(extrinsic: Extrinsic): Hash\n\t\t`\n\t}, {\n\t\tname: \"Babe\", rpc_path: \"babe\",\n\t\tfuncs: `\n\t\t\tepochAuthorship(): HashMap<AuthorityId, EpochAuthorship>\n\t\t`\n\t}, {\n\t\tname: \"Beefy\", rpc_path: \"beefy\",\n\t\tfuncs: `\n\t\t\tsubscribeJustifications(): BeefySignedCommitment\n\t\t`\n\t}, {\n\t\tname: \"Chain\", rpc_path: \"chain\",\n\t\tfuncs: `\n\t\t\tgetBlock(hash?: BlockHash): SignedBlock\n\t\t\tgetBlockHash(blockNumber?: BlockNumber): BlockHash\n\t\t\tgetFinalizedHead(): BlockHash\n\t\t\tgetHeader(hash?: BlockHash): Header\n\t\t\tsubscribeAllHeads(): Header\n\t\t\tsubscribeFinalizedHeads(): Header\n\t\t\tsubscribeNewHeads(): Header\n\t\t`\n\t}, {\n\t\tname: \"ChildState\", rpc_path: \"childstate\",\n\t\tfuncs: `\n\t\t\tgetKeys(childKey: PrefixedStorageKey, prefix: StorageKey, at?: Hash): Vec<StorageKey>\n\t\t\tgetKeysPaged(childKey: PrefixedStorageKey, prefix: StorageKey, count: u32, startKey?: StorageKey, at?: Hash): Vec<StorageKey>\n\t\t\tgetStorage(childKey: PrefixedStorageKey, key: StorageKey, at?: Hash): Option<StorageData>\n\t\t\tgetStorageEntries(childKey: PrefixedStorageKey, keys: Vec<StorageKey>, at?: Hash): Vec<Option<StorageData>>\n\t\t\tgetStorageHash(childKey: PrefixedStorageKey, key: StorageKey, at?: Hash): Option<Hash>\n\t\t\tgetStorageSize(childKey: PrefixedStorageKey, key: StorageKey, at?: Hash): Option<u64>\n\t\t`\n\t}, {\n\t\tname: \"Contracts\", rpc_path: \"contracts\",\n\t\tfuncs: `\n\t\t\tcall(callRequest: ContractCallRequest, at?: BlockHash): ContractExecResult\n\t\t\tgetStorage(address: AccountId, key: H256, at?: BlockHash): Option<Bytes>\n\t\t\tinstantiate(request: InstantiateRequest, at?: BlockHash): ContractInstantiateResult\n\t\t\trentProjection(address: AccountId, at?: BlockHash): Option<BlockNumber>\n\t\t`\n\t}, {\n\t\tname: \"Engine\", rpc_path: \"engine\",\n\t\tfuncs: `\n\t\t\tcreateBlock(createEmpty: bool, finalize: bool, parentHash?: BlockHash): CreatedBlock\n\t\t\tfinalizeBlock(hash: BlockHash, justification?: Justification): bool\n\t\t`\n\t}, {\n\t\tname: \"Eth\", rpc_path: \"eth\",\n\t\tfuncs: `\n\t\t\taccounts(): Vec<H160>\n\t\t\tblockNumber(): U256\n\t\t\tcall(request: EthCallRequest, number?: BlockNumber): Bytes\n\t\t\tchainId(): U64\n\t\t\tcoinbase(): H160\n\t\t\testimateGas(request: EthCallRequest, number?: BlockNumber): U256\n\t\t\tgasPrice(): U256\n\t\t\tgetBalance(address: H160, number?: BlockNumber): U256\n\t\t\tgetBlockByHash(hash: H256, full: bool): Option<EthRichBlock>\n\t\t\tgetBlockByNumber(block: BlockNumber, full: bool): Option<EthRichBlock>\n\t\t\tgetBlockTransactionCountByHash(hash: H256): U256\n\t\t\tgetBlockTransactionCountByNumber(block: BlockNumber): U256\n\t\t\tgetCode(address: H160, number?: BlockNumber): Bytes\n\t\t\tgetFilterChanges(index: U256): EthFilterChanges\n\t\t\tgetFilterLogs(index: U256): Vec<EthLog>\n\t\t\tgetLogs(filter: EthFilter): Vec<EthLog>\n\t\t\tgetProof(address: H160, storageKeys: Vec<H256>, number: BlockNumber): EthAccount\n\t\t\tgetStorageAt(address: H160, index: U256, number?: BlockNumber): H256\n\t\t\tgetTransactionByBlockHashAndIndex(hash: H256, index: U256): EthTransaction\n\t\t\tgetTransactionByBlockNumberAndIndex(number: BlockNumber, index: U256): EthTransaction\n\t\t\tgetTransactionByHash(hash: H256): EthTransaction\n\t\t\tgetTransactionCount(hash: H256, number?: BlockNumber): U256\n\t\t\tgetTransactionReceipt(hash: H256): EthReceipt\n\t\t\tgetUncleByBlockHashAndIndex(hash: H256, index: U256): EthRichBlock\n\t\t\tgetUncleByBlockNumberAndIndex(number: BlockNumber, index: U256): EthRichBlock\n\t\t\tgetUncleCountByBlockHash(hash: H256): U256\n\t\t\tgetUncleCountByBlockNumber(number: BlockNumber): U256\n\t\t\tgetWork(): EthWork\n\t\t\thashrate(): U256\n\t\t\tmining(): bool\n\t\t\tnewBlockFilter(): U256\n\t\t\tnewFilter(filter: EthFilter): U256\n\t\t\tnewPendingTransactionFilter(): U256\n\t\t\tprotocolVersion(): u64\n\t\t\tsendRawTransaction(bytes: Bytes): H256\n\t\t\tsendTransaction(tx: EthTransactionRequest): H256\n\t\t\tsubmitHashrate(index: U256, hash: H256): bool\n\t\t\tsubmitWork(nonce: H64, headerHash: H256, mixDigest: H256): bool\n\t\t\tsubscribe(kind: EthSubKind, params?: EthSubParams): Null\n\t\t\tsyncing(): EthSyncStatus\n\t\t\tuninstallFilter(index: U256): bool\n\t\t`\n\t}, {\n\t\tname: \"Net\", rpc_path: \"net\",\n\t\tfuncs: `\n\t\t\tlistening(): bool\n\t\t\tpeerCount(): String\n\t\t\tversion(): String\n\t\t`\n\t}, {\n\t\tname: \"Web3\", rpc_path: \"web3\",\n\t\tfuncs: `\n\t\t\tclientVersion(): String\n\t\t\tsha3(data: Bytes): H256\n\t\t`\n\t}, {\n\t\tname: \"Grandpa\", rpc_path: \"grandpa\",\n\t\tfuncs: `\n\t\t\tproveFinality(begin: BlockHash, end: BlockHash, authoritiesSetId?: u64): Option<EncodedFinalityProofs>\n\t\t\troundState(): ReportedRoundStates\n\t\t\tsubscribeJustifications(): JustificationNotification\n\t\t`\n\t}, {\n\t\tname: \"Mmr\", rpc_path: \"mmr\",\n\t\tfuncs: `\n\t\t\tgenerateProof(leafIndex: u64, at?: BlockHash): MmrLeafProof\n\t\t`\n\t}, {\n\t\tname: \"OffChain\", rpc_path: \"offchain\",\n\t\tfuncs: `\n\t\t\tlocalStorageGet(kind: StorageKind, key: Bytes): Option<Bytes>\n\t\t\tlocalStorageSet(kind: StorageKind, key: Bytes, value: Bytes): Null\n\t\t`\n\t}, {\n\t\tname: \"Payment\", rpc_path: \"payment\",\n\t\tfuncs: `\n\t\t\tqueryFeeDetails(extrinsic: Bytes, at?: BlockHash): FeeDetails\n\t\t\tqueryInfo(extrinsic: Bytes, at?: BlockHash): RuntimeDispatchInfo\n\t\t`\n\t}, {\n\t\tname: \"RPC\", rpc_path: \"rpc\",\n\t\tfuncs: `\n\t\t\tmethods(): RpcMethods\n\t\t`\n\t}, {\n\t\tname: \"State\", rpc_path: \"state\",\n\t\tfuncs: `\n\t\t\tcall(method: Text, data: Bytes, at?: BlockHash): Bytes\n\t\t\tgetChildKeys(childStorageKey: StorageKey, childDefinition: StorageKey, childType: u32, key: StorageKey, at?: BlockHash): Vec<StorageKey>\n\t\t\tgetChildReadProof(childStorageKey: PrefixedStorageKey, keys: Vec<StorageKey>, at?: BlockHash): ReadProof\n\t\t\tgetChildStorage(childStorageKey: StorageKey, childDefinition: StorageKey, childType: u32, key: StorageKey, at?: BlockHash): StorageData\n\t\t\tgetChildStorageHash(childStorageKey: StorageKey, childDefinition: StorageKey, childType: u32, key: StorageKey, at?: BlockHash): Hash\n\t\t\tgetChildStorageSize(childStorageKey: StorageKey, childDefinition: StorageKey, childType: u32, key: StorageKey, at?: BlockHash): u64\n\t\t\tgetKeys(key: StorageKey, at?: BlockHash): Vec<StorageKey>\n\t\t\tgetKeysPaged(key: StorageKey, count: u32, startKey?: StorageKey, at?: BlockHash): Vec<StorageKey>\n\t\t\tgetMetadata(at?: BlockHash): Metadata\n\t\t\tgetPairs(prefix: StorageKey, at?: BlockHash): Vec<KeyValue>\n\t\t\tgetReadProof(keys: Vec<StorageKey>, at?: BlockHash): ReadProof\n\t\t\tgetRuntimeVersion(at?: BlockHash): RuntimeVersion\n\t\t\tgetStorage(key: StorageKey, at?: BlockHash): StorageData\n\t\t\tgetStorageHash(key: StorageKey, at?: BlockHash): Hash\n\t\t\tgetStorageSize(key: StorageKey, at?: BlockHash): u64\n\t\t\tqueryStorage(keys: Vec<StorageKey>, fromBlock: Hash, toBlock?: BlockHash): Vec<StorageChangeSet>\n\t\t\tqueryStorageAt(keys: Vec<StorageKey>, at?: BlockHash): Vec<StorageChangeSet>\n\t\t\tsubscribeRuntimeVersion(): RuntimeVersion\n\t\t\tsubscribeStorage(keys?: Vec<StorageKey>): StorageChangeSet\n\t\t\ttraceBlock(block: Hash, targets: Option<Text>, storageKeys: Option<Text>, methods: Option<Text>): TraceBlockResponse\n\t\t`\n\t}, {\n\t\tname: \"SyncState\", rpc_path: \"syncstate\",\n\t\tfuncs: `\n\t\t\tgenSyncSpec(raw: bool): Json\n\t\t`\n\t}, {\n\t\tname: \"System\", rpc_path: \"system\",\n\t\tfuncs: `\n\t\t\taccountNextIndex(accountId: AccountId): Index\n\t\t\taddLogFilter(directives: Text): Null\n\t\t\taddReservedPeer(peer: Text): Text\n\t\t\tchain(): Text\n\t\t\tchainType(): ChainType\n\t\t\tdryRun(extrinsic: Bytes, at?: BlockHash): ApplyExtrinsicResult\n\t\t\thealth(): Health\n\t\t\tlocalListenAddresses(): Vec<Text>\n\t\t\tlocalPeerId(): Text\n\t\t\tname(): Text\n\t\t\tnetworkState(): NetworkState\n\t\t\tnodeRoles(): Vec<NodeRole>\n\t\t\tpeers(): Vec<PeerInfo>\n\t\t\tproperties(): ChainProperties\n\t\t\tremoveReservedPeer(peerId: Text): Text\n\t\t\treservedPeers(): Vec<Text>\n\t\t\tresetLogFilter(): Null\n\t\t\tsyncState(): SyncState\n\t\t\tversion(): Text\n\t\t`\n\t}\n]);","/**\n * import { Context } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotApi } = window;\n */\n\n// For storing node data\nclass ConnectionHTTPData {\n\tconstructor(iface){this._iface = iface}\n\n\t// example:  https://rpc.polkadot.io\n\t_rpcURL = '';\n\tget rpcURL(){return this._rpcURL}\n\tset rpcURL(val){\n\t\tthis._rpcURL = val;\n\t\tthis._iface.changeRPC();\n\n\t\t// Already throttled before being synced to remote\n\t\tthis._iface.node.syncOut('rpcURL', val);\n\t}\n}\n\n// Make sure the property that can be exported to JSON is visible/enumerable\nBlackprint.utils.setEnumerablePrototype(ConnectionHTTPData, {\n\trpcURL: true,\n});\n\n/**\n * Connect to parachain's RPC through HTTP URL\n * @blackprint node\n * @summary Web3 RPC Connection\n */\nBlackprint.registerNode(\"Polkadot.js/Connection/HTTP\",\nclass HTTPNode extends Blackprint.Node {\n\t// Input port\n\tstatic input = {\n\t\t/** Initiate reconnection with the RPC */\n\t\tReconnect: Blackprint.Port.Trigger(function({ iface }){\n\t\t\tiface.changeRPC();\n\t\t}),\n\t};\n\n\t// Output port\n\tstatic output = {\n\t\t/** RPC Provider object from Polkadot.js's */\n\t\tProvider: polkadotApi.HttpProvider,\n\t\t/** API object from Polkadot.js's */\n\t\tAPI: polkadotApi.ApiPromise,\n\t\t/** This will be called when we successfully connected to the RPC*/\n\t\tConnected: Blackprint.Types.Trigger,\n\t\t/** This will be called when we disconnected with the RPC*/\n\t\tDisconnected: Blackprint.Types.Trigger,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\t// Use custom interface\n\t\t// Engine: scroll down this file to \"Blackprint.registerInterface\"\n\t\t// Browser: ./HTTP.sf\n\t\tlet iface = this.setInterface('BPIC/Polkadot.js/Connection/HTTP');\n\t\tiface.title = \"HTTP\";\n\n\t\t// Create new object for storing data\n\t\tiface.data = new ConnectionHTTPData(iface);\n\t}\n\n\t// This will be called by the engine once the node has been loaded\n\timported(data){\n\t\tif(!data) return;\n\n\t\t// This will also trigger \"iface.changeRPC\"\n\t\t// due to getter/setter on \"ConnectionHTTPData\"\n\t\tObject.assign(this.iface.data, data);\n\t}\n\n\t// Add support for remote control/collaborative editor mode\n\tsyncIn(type, data){\n\t\tif(type === 'rpcURL')\n\t\t\tthis.iface.data.rpcURL = data;\n\t}\n\n\t// This will be called by the engine when this node is deleted\n\tdestroy(){\n\t\tlet http = this.ref.Output.Provider;\n\t\tif(http === void 0) return;\n\n\t\t// Disconnect from the network\n\t\thttp.disconnect();\n\t\tthis.ref.Output.Disconnected();\n\t}\n});\n\n\n// Register Blackprint Interface (like an API for developer, or UI for sketch editor)\nBlackprint.registerInterface('BPIC/Polkadot.js/Connection/HTTP',\nContext.IFace.ConnectionHTTP = class HTTPIFace extends Blackprint.Interface {\n\tconstructor(node){\n\t\tsuper(node);\n\n\t\tthis._toast = new NodeToast(this);\n\t\tthis._toast.warn(\"Disconnected\");\n\t}\n\n\tasync changeRPC(){\n\t\tlet { Output } = this.ref; // Shortcut\n\t\tthis._toast.clear();\n\n\t\t// This can be filled from sketch's UI, or with code by accessing the IFace\n\t\tlet rpcURL = this.data.rpcURL;\n\t\tif(!rpcURL)\n\t\t\treturn this._toast.error(\"RPC URL was empty\");\n\n\t\tif(!/^(https|http):\\/\\//.test(rpcURL))\n\t\t\treturn this._toast.error(\"The endpoint should start with http:// or https://\");\n\n\t\t// If already connected to other network, let's disconnect it first\n\t\tif(Output.Provider != null){\n\t\t\tOutput.Provider.disconnect();\n\t\t\tOutput.Disconnected();\n\t\t}\n\n\t\t// Connect to the new RPC URL\n\t\tlet provider = Output.Provider = new polkadotApi.HttpProvider(rpcURL);\n\n\t\tthis._toast.warn(\"Connecting...\");\n\n\t\t// Wait until connected, or show warning when failed\n\t\ttry {\n\t\t\tvar api = await polkadotApi.ApiPromise.create({ provider, throwOnConnect: true });\n\t\t} catch(e) {\n\t\t\tthis._toast.warn(\"Connection failed\");\n\t\t\tOutput.API = null;\n\t\t\tOutput.Disconnected();\n\t\t\treturn;\n\t\t}\n\n\t\t// Put the API object into the output port\n\t\tOutput.API = api;\n\n\t\t// Check connection status\n\t\tif(provider.isConnected){\n\t\t\tthis._toast.clear();\n\t\t\tthis._toast.success(\"Connected\");\n\n\t\t\tOutput.Connected();\n\t\t}\n\t\telse{\n\t\t\tthis._toast.error(\"Failed to connect\");\n\t\t\tOutput.Disconnected();\n\t\t}\n\t}\n});","/**\n * import { Context } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotApi } = window;\n */\n\n// For storing node data\nclass ConnectionWebSocketData {\n\tconstructor(iface){this._iface = iface}\n\n\t// example:  wss://rpc.polkadot.io\n\t_rpcURL = '';\n\tget rpcURL(){return this._rpcURL}\n\tset rpcURL(val){\n\t\tthis._rpcURL = val;\n\t\tthis._iface.changeRPC();\n\n\t\t// Already throttled before being synced to remote\n\t\tthis._iface.node.syncOut('rpcURL', val);\n\t}\n}\n\n// Make sure the property that can be exported to JSON is visible/enumerable\nBlackprint.utils.setEnumerablePrototype(ConnectionWebSocketData, {\n\trpcURL: true,\n});\n\n/**\n * Connect to parachain's RPC through WebSocket\n * @blackprint node\n * @summary Web3 RPC Connection\n */\nBlackprint.registerNode(\"Polkadot.js/Connection/WebSocket\",\nclass WebSocketNode extends Blackprint.Node {\n\t// Input port\n\tstatic input = {\n\t\t/** Initiate connection with the RPC */\n\t\tConnect: Blackprint.Port.Trigger(function({ iface }){\n\t\t\tiface.node.output.Provider?.connect();\n\t\t}),\n\t\t/** Disconnect the RPC */\n\t\tDisconnect: Blackprint.Port.Trigger(function({ iface }){\n\t\t\tiface.node.output.Provider?.disconnect();\n\t\t}),\n\t};\n\n\t// Output port\n\tstatic output = {\n\t\t/** RPC Provider object from Polkadot.js's */\n\t\tProvider: polkadotApi.WsProvider,\n\t\t/** API object from Polkadot.js's */\n\t\tAPI: polkadotApi.ApiPromise,\n\t\t/** This will be called when we successfully connected to the RPC*/\n\t\tConnected: Blackprint.Types.Trigger,\n\t\t/** This will be called when we disconnected with the RPC*/\n\t\tDisconnected: Blackprint.Types.Trigger,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\t// Use custom interface\n\t\t// Engine: scroll down this file to \"Blackprint.registerInterface\"\n\t\t// Browser: ./WebSocket.sf\n\t\tlet iface = this.setInterface('BPIC/Polkadot.js/Connection/WebSocket');\n\t\tiface.title = \"WebSocket\";\n\n\t\tiface.data = new ConnectionWebSocketData(iface);\n\t}\n\n\t// This will be called by the engine once the node has been loaded\n\timported(data){\n\t\tif(!data) return;\n\t\tObject.assign(this.iface.data, data);\n\t}\n\n\t// Add support for remote control/collaborative editor mode\n\tsyncIn(type, data){\n\t\tif(type === 'rpcURL')\n\t\t\tthis.iface.data.rpcURL = data;\n\t}\n\n\t// This will be called by the engine when this node is deleted\n\tdestroy(){\n\t\tlet ws = this.ref.Output.Provider;\n\t\tif(ws === void 0) return;\n\n\t\t// Disconnect from the network\n\t\tws.disconnect();\n\t}\n});\n\n\n// Register Blackprint Interface (like an API for developer, or UI for sketch editor)\nBlackprint.registerInterface('BPIC/Polkadot.js/Connection/WebSocket',\nContext.IFace.ConnectionWebSocket = class WebSocketIFace extends Blackprint.Interface {\n\tconstructor(node){\n\t\tsuper(node);\n\n\t\tthis._toast = new NodeToast(this);\n\t\tthis._toast.warn(\"Disconnected\");\n\t}\n\n\tasync changeRPC(){\n\t\tlet { Output } = this.ref; // Shortcut\n\t\tthis._toast.clear();\n\n\t\t// If already connected to other network, let's disconnect it first\n\t\tOutput.Provider?.disconnect();\n\n\t\t// This can be filled from sketch's UI, or with code by accessing the IFace\n\t\tlet rpcURL = this.data.rpcURL;\n\t\tif(!rpcURL)\n\t\t\treturn this._toast.error(\"RPC URL was empty\");\n\n\t\tif(!/^(wss|ws):\\/\\//.test(rpcURL))\n\t\t\treturn this._toast.error(\"The endpoint should start with ws:// or wss://\");\n\n\t\t// Connect to the new RPC URL and put the Provider object to the output port\n\t\tlet provider = Output.Provider = new polkadotApi.WsProvider(rpcURL);\n\n\t\tclearTimeout(this._prepareAPIWait);\n\n\t\t// Add event listener before connecting to the network\n\t\tlet initialized = false;\n\t\tprovider.on('connected', ()=> {\n\t\t\tthis._toast.clear();\n\t\t\tthis._toast.success(\"Connected\");\n\n\t\t\tif(!initialized){\n\t\t\t\tthis._toast.warn(\"Preparing API...\");\n\n\t\t\t\t// Show error if no response from RPC\n\t\t\t\tthis._prepareAPIWait = setTimeout(() => {\n\t\t\t\t\tif(initialized) return;\n\n\t\t\t\t\tthis._toast.clear();\n\t\t\t\t\tthis._toast.error(\"No response from RPC\");\n\t\t\t\t}, 60e3);\n\t\t\t}\n\n\t\t\tOutput.Connected();\n\t\t});\n\n\t\tprovider.on('disconnected', ()=> {\n\t\t\tthis._toast.warn(\"Disconnected\");\n\t\t\tOutput.Disconnected();\n\t\t});\n\n\t\t// Wait until connected and put the API object into the output port\n\t\tthis._toast.warn(\"Connecting...\");\n\t\tOutput.API = await polkadotApi.ApiPromise.create({ provider });\n\n\t\tinitialized = true;\n\t\tclearTimeout(this._prepareAPIWait);\n\n\t\tif(this._toast.haveWarn.text === \"Preparing API...\")\n\t\t\tthis._toast.clear();\n\t}\n});","/**\n * import { Substrate_BlackprintNodeGenerator } from \"../utils/SubstrateNodes.js\";\n */\n\n// This file may get changed on the future\n\n// https://polkadot.js.org/docs/substrate/constants\n// The parameters will be input port, and the returned data will be the output port\n// The function name will be the node's name (ex: Author HasKey)\n\nSubstrate_BlackprintNodeGenerator({\n\tnamespace: 'Constants',\n\tdescription: '[Experimental] Substrate Constants',\n\tapiPath: 'consts',\n\tloose: true,\n\tisConst: true,\n}, [\n\t{\n\t\tname: \"Assets\", rpc_path: \"assets\",\n\t\tfuncs: `\n\t\t\tapprovalDeposit: u128\n\t\t\tassetAccountDeposit: u128\n\t\t\tassetDeposit: u128\n\t\t\tmetadataDepositBase: u128\n\t\t\tmetadataDepositPerByte: u128\n\t\t\tstringLimit: u32\n\t\t`\n\t}, {\n\t\tname: \"Authorship\", rpc_path: \"authorship\",\n\t\tfuncs: `\n\t\t\tuncleGenerations: u32\n\t\t`\n\t}, {\n\t\tname: \"Babe\", rpc_path: \"babe\",\n\t\tfuncs: `\n\t\t\tepochDuration: u64\n\t\t\texpectedBlockTime: u64\n\t\t\tmaxAuthorities: u32\n\t\t`\n\t}, {\n\t\tname: \"BagsList\", rpc_path: \"bagsList\",\n\t\tfuncs: `\n\t\t\tbagThresholds: Vec<u64>\n\t\t`\n\t}, {\n\t\tname: \"Balances\", rpc_path: \"balances\",\n\t\tfuncs: `\n\t\t\texistentialDeposit: u128\n\t\t\tmaxLocks: u32\n\t\t\tmaxReserves: u32\n\t\t`\n\t}, {\n\t\tname: \"Bounties\", rpc_path: \"bounties\",\n\t\tfuncs: `\n\t\t\tbountyCuratorDeposit: Permill\n\t\t\tbountyDepositBase: u128\n\t\t\tbountyDepositPayoutDelay: u32\n\t\t\tbountyUpdatePeriod: u32\n\t\t\tbountyValueMinimum: u128\n\t\t\tdataDepositPerByte: u128\n\t\t\tmaximumReasonLength: u32\n\t\t`\n\t}, {\n\t\tname: \"ChildBounties\", rpc_path: \"childBounties\",\n\t\tfuncs: `\n\t\t\tchildBountyCuratorDepositBase: Permill\n\t\t\tchildBountyValueMinimum: u128\n\t\t\tmaxActiveChildBountyCount: u32\n\t\t`\n\t}, {\n\t\tname: \"Contracts\", rpc_path: \"contracts\",\n\t\tfuncs: `\n\t\t\tdeletionQueueDepth: u32\n\t\t\tdeletionWeightLimit: u64\n\t\t\tdepositPerByte: u128\n\t\t\tdepositPerItem: u128\n\t\t\tschedule: PalletContractsSchedule\n\t\t`\n\t}, {\n\t\tname: \"Democracy\", rpc_path: \"democracy\",\n\t\tfuncs: `\n\t\t\tcooloffPeriod: u32\n\t\t\tenactmentPeriod: u32\n\t\t\tfastTrackVotingPeriod: u32\n\t\t\tinstantAllowed: bool\n\t\t\tlaunchPeriod: u32\n\t\t\tmaxProposals: u32\n\t\t\tmaxVotes: u32\n\t\t\tminimumDeposit: u128\n\t\t\tpreimageByteDeposit: u128\n\t\t\tvoteLockingPeriod: u32\n\t\t\tvotingPeriod: u32\n\t\t`\n\t}, {\n\t\tname: \"ElectionProviderMultiPhase\", rpc_path: \"electionProviderMultiPhase\",\n\t\tfuncs: `\n\t\t\tminerMaxLength: u32\n\t\t\tminerMaxWeight: u64\n\t\t\tminerTxPriority: u64\n\t\t\toffchainRepeat: u32\n\t\t\tsignedDepositBase: u128\n\t\t\tsignedDepositByte: u128\n\t\t\tsignedDepositWeight: u128\n\t\t\tsignedMaxSubmissions: u32\n\t\t\tsignedMaxWeight: u64\n\t\t\tsignedPhase: u32\n\t\t\tsignedRewardBase: u128\n\t\t\tsolutionImprovementThreshold: Perbill\n\t\t\tunsignedPhase: u32\n\t\t\tvoterSnapshotPerBlock: u32\n\t\t`\n\t}, {\n\t\tname: \"Elections\", rpc_path: \"elections\",\n\t\tfuncs: `\n\t\t\tcandidacyBond: u128\n\t\t\tdesiredMembers: u32\n\t\t\tdesiredRunnersUp: u32\n\t\t\tpalletId: [u8;8]\n\t\t\ttermDuration: u32\n\t\t\tvotingBondBase: u128\n\t\t\tvotingBondFactor: u128\n\t\t`\n\t}, {\n\t\tname: \"Gilt\", rpc_path: \"gilt\",\n\t\tfuncs: `\n\t\t\tfifoQueueLen: u32\n\t\t\tintakePeriod: u32\n\t\t\tmaxIntakeBids: u32\n\t\t\tmaxQueueLen: u32\n\t\t\tminFreeze: u128\n\t\t\tperiod: u32\n\t\t\tqueueCount: u32\n\t\t`\n\t}, {\n\t\tname: \"Grandpa\", rpc_path: \"grandpa\",\n\t\tfuncs: `\n\t\t\tmaxAuthorities: u32\n\t\t`\n\t}, {\n\t\tname: \"Identity\", rpc_path: \"identity\",\n\t\tfuncs: `\n\t\t\tbasicDeposit: u128\n\t\t\tfieldDeposit: u128\n\t\t\tmaxAdditionalFields: u32\n\t\t\tmaxRegistrars: u32\n\t\t\tmaxSubAccounts: u32\n\t\t\tsubAccountDeposit: u128\n\t\t`\n\t}, {\n\t\tname: \"ImOnline\", rpc_path: \"imOnline\",\n\t\tfuncs: `\n\t\t\tunsignedPriority: u64\n\t\t`\n\t}, {\n\t\tname: \"Indices\", rpc_path: \"indices\",\n\t\tfuncs: `\n\t\t\tdeposit: u128\n\t\t`\n\t}, {\n\t\tname: \"Lottery\", rpc_path: \"lottery\",\n\t\tfuncs: `\n\t\t\tmaxCalls: u32\n\t\t\tmaxGenerateRandom: u32\n\t\t\tpalletId: FrameSupportPalletId\n\t\t`\n\t}, {\n\t\tname: \"Multisig\", rpc_path: \"multisig\",\n\t\tfuncs: `\n\t\t\tdepositBase: u128\n\t\t\tdepositFactor: u128\n\t\t\tmaxSignatories: u16\n\t\t`\n\t}, {\n\t\tname: \"Proxy\", rpc_path: \"proxy\",\n\t\tfuncs: `\n\t\t\tannouncementDepositBase: u128\n\t\t\tannouncementDepositFactor: u128\n\t\t\tmaxPending: u32\n\t\t\tmaxProxies: u32\n\t\t\tproxyDepositBase: u128\n\t\t\tproxyDepositFactor: u128\n\t\t`\n\t}, {\n\t\tname: \"Recovery\", rpc_path: \"recovery\",\n\t\tfuncs: `\n\t\t\tconfigDepositBase: u128\n\t\t\tfriendDepositFactor: u128\n\t\t\tmaxFriends: u16\n\t\t\trecoveryDeposit: u128\n\t\t`\n\t}, {\n\t\tname: \"Scheduler\", rpc_path: \"scheduler\",\n\t\tfuncs: `\n\t\t\tmaximumWeight: u64\n\t\t\tmaxScheduledPerBlock: u32\n\t\t`\n\t}, {\n\t\tname: \"Society\", rpc_path: \"society\",\n\t\tfuncs: `\n\t\t\tcandidateDeposit: u128\n\t\t\tchallengePeriod: u32\n\t\t\tmaxCandidateIntake: u32\n\t\t\tmaxLockDuration: u32\n\t\t\tmaxStrikes: u32\n\t\t\tpalletId: FrameSupportPalletId\n\t\t\tperiodSpend: u128\n\t\t\trotationPeriod: u32\n\t\t\twrongSideDeduction: u128\n\t\t`\n\t}, {\n\t\tname: \"Staking\", rpc_path: \"staking\",\n\t\tfuncs: `\n\t\t\tbondingDuration: u32\n\t\t\tmaxNominatorRewardedPerValidator: u32\n\t\t\tsessionsPerEra: u32\n\t\t\tslashDeferDuration: u32\n\t\t`\n\t}, {\n\t\tname: \"System\", rpc_path: \"system\",\n\t\tfuncs: `\n\t\t\tblockHashCount: u32\n\t\t\tblockLength: FrameSystemLimitsBlockLength\n\t\t\tblockWeights: FrameSystemLimitsBlockWeights\n\t\t\tdbWeight: FrameSupportWeightsRuntimeDbWeight\n\t\t\tss58Prefix: u16\n\t\t\tversion: SpVersionRuntimeVersion\n\t\t`\n\t}, {\n\t\tname: \"Timestamp\", rpc_path: \"timestamp\",\n\t\tfuncs: `\n\t\t\tminimumPeriod: u64\n\t\t`\n\t}, {\n\t\tname: \"Tips\", rpc_path: \"tips\",\n\t\tfuncs: `\n\t\t\tdataDepositPerByte: u128\n\t\t\tmaximumReasonLength: u32\n\t\t\ttipCountdown: u32\n\t\t\ttipFindersFee: Percent\n\t\t\ttipReportDepositBase: u128\n\t\t`\n\t}, {\n\t\tname: \"TransactionPayment\", rpc_path: \"transactionPayment\",\n\t\tfuncs: `\n\t\t\toperationalFeeMultiplier: u8\n\t\t\ttransactionByteFee: u128\n\t\t\tweightToFee: Vec<FrameSupportWeightsWeightToFeeCoefficient>\n\t\t`\n\t}, {\n\t\tname: \"Treasury\", rpc_path: \"treasury\",\n\t\tfuncs: `\n\t\t\tburn: Permill\n\t\t\tmaxApprovals: u32\n\t\t\tpalletId: FrameSupportPalletId\n\t\t\tproposalBond: Permill\n\t\t\tproposalBondMaximum: Option<u128>\n\t\t\tproposalBondMinimum: u128\n\t\t\tspendPeriod: u32\n\t\t`\n\t}, {\n\t\tname: \"Uniques\", rpc_path: \"uniques\",\n\t\tfuncs: `\n\t\t\tattributeDepositBase: u128\n\t\t\tclassDeposit: u128\n\t\t\tdepositPerByte: u128\n\t\t\tinstanceDeposit: u128\n\t\t\tkeyLimit: u32\n\t\t\tmetadataDepositBase: u128\n\t\t\tstringLimit: u32\n\t\t\tvalueLimit: u32\n\t\t`\n\t}, {\n\t\tname: \"Utility\", rpc_path: \"utility\",\n\t\tfuncs: `\n\t\t\tbatchedCallsLimit: u32\n\t\t`\n\t}, {\n\t\tname: \"Vesting\", rpc_path: \"vesting\",\n\t\tfuncs: `\n\t\t\tmaxVestingSchedules: u32\n\t\t\tminVestedTransfer: u128\n\t\t`\n\t}\n]);","/**\n * import { Context } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotUtilCrypto } = window\n */\n\n\n/**\n * Convert mnemonic into a secret key\n * @blackprint node\n */\nBlackprint.registerNode(\"Polkadot.js/Convert/Mnemonic\",\nclass MnemonicNode extends Blackprint.Node {\n\t// Node's output/input port\n\tstatic input = {\n\t\t/** Mnemonic */\n\t\tText: String,\n\t};\n\tstatic output = {\n\t\t/** Secret key */\n\t\tSeed: Uint8Array,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Mnemonic\";\n\n\t\tthis._toast = new NodeToast(iface);\n\t}\n\n\t// Event listener can be registered after init\n\tinit(){\n\t\t// Clear the output port when the input cable was disconnected\n\t\tthis.iface.input.Text.on('disconnect', Context.EventSlot, ()=> {\n\t\t\tthis.output.Seed = null;\n\t\t});\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet { mnemonicToMiniSecret, mnemonicValidate } = polkadotUtilCrypto;\n\t\tlet toast = this._toast;\n\n\t\ttry{\n\t\t\tif(!mnemonicValidate(Input.Text))\n\t\t\t\treturn toast.warn(\"Invalid mnemonic\");\n\n\t\t\t// Convert to seed that can be imported to Keyring and put it to the output port\n\t\t\tOutput.Seed = mnemonicToMiniSecret(Input.Text);\n\t\t\ttoast.clear();\n\t\t} catch(e) {\n\t\t\treturn toast.warn(e.message);\n\t\t}\n\t}\n});","/**\n * import { Context, Signer } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotUtil } = window\n */\n\n\n/**\n * Sign a data with wallet's signer (private key)\n * The signed data can then be verified with the signer's wallet address (public key)\n * @blackprint node\n * @summary Sign a data\n */\nBlackprint.registerNode(\"Polkadot.js/Data/Sign\",\nclass SignNode extends Blackprint.Node {\n\t// Input port\n\tstatic input = {\n\t\t/** Start the signing process (trigger is required to ask access to browser wallet) */\n\t\tTrigger: Blackprint.Port.Trigger(function({ iface }){\n\t\t\tiface.node.trigger();\n\t\t}),\n\t\t/** Keypair's signer or browser extension's signer */\n\t\tSigner: Signer,\n\t\t/** Any data to be signed */\n\t\tData: Blackprint.Port.Union([String, Uint8Array]),\n\t};\n\n\t// Output port\n\tstatic output = {\n\t\t/** Data's signature */\n\t\tBytes: Uint8Array\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // use empty interface\n\t\tiface.title = \"Sign\";\n\t\tiface.description = \"Data/transaction signer\";\n\n\t\tthis._toast = new NodeToast(this.iface);\n\n\t\t// Manually call 'update' when any cable from input port was disconnected\n\t\tthis.iface.on('cable.disconnect', Context.EventSlot, ({ port })=> {\n\t\t\tif(port.source === 'input') this.update();\n\t\t});\n\t}\n\n\t_fail(msg){\n\t\tthis.output.Bytes = null; // Clear the output data if something was fail/error\n\t\tthis._toast.warn(msg);\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tupdate(){\n\t\tlet { Input } = this.ref; // Shortcut\n\n\t\tif(!Input.Signer)\n\t\t\treturn this._fail(\"Signer is required\");\n\n\t\tlet data = Input.Data;\n\t\tif(!data)\n\t\t\treturn this._fail(\"Data is required\");\n\n\t\tthis._toast.clear();\n\t}\n\n\tasync trigger(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\n\t\tif(!Input.Signer || !Input.Data)\n\t\t\treturn this._fail(\"Some input is required\");\n\n\t\tlet data = Input.Data;\n\t\tlet { signer, address, isPair } = Input.Signer;\n\n\t\tOutput.Bytes = null;\n\n\t\t// There's 2 source of Signer (from Keypair and Browser Extension)\n\t\tif(isPair){ // Signer from Keypair (polkadotApi.Keyring)\n\t\t\tif(data.constructor === String)\n\t\t\t\tdata = polkadotUtil.stringToU8a(data);\n\n\t\t\t// Sign with the keypair and put the data to the output port\n\t\t\tOutput.Bytes = signer.sign(data);\n\t\t}\n\t\telse { // Signer from extension (polkadotExtensionDapp)\n\t\t\tif(data.constructor === Uint8Array)\n\t\t\t\tdata = polkadotUtil.u8aToHex(data);\n\t\t\telse if(data.slice(0, 2) !== '0x')\n\t\t\t\tdata = polkadotUtil.stringToHex(data);\n\n\t\t\t// Sign with the extension and get the Hex\n\t\t\ttry{\n\t\t\t\tvar temp = signer.signRaw({\n\t\t\t\t\ttype: 'bytes',\n\t\t\t\t\tdata,\n\t\t\t\t\taddress,\n\t\t\t\t});\n\n\t\t\t\t// Store the promise to iface\n\t\t\t\tthis.iface.signing = temp;\n\t\t\t\ttemp = await temp;\n\t\t\t\t\n\t\t\t\tthis.iface.signing = false;\n\t\t\t} catch(e) {\n\t\t\t\tthis._fail(e.message);\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\t// Convert the returned Hex to Uint8Array and put the data to the output port\n\t\t\tOutput.Bytes = polkadotUtil.hexToU8a(temp.signature);\n\t\t}\n\t}\n});","/**\n * import { Context } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotUtil, polkadotUtilCrypto } = window\n */\n\n\n/**\n * Verify the validation of data with the data's signature\n * @blackprint node\n * @summary Verify signed data\n */\nBlackprint.registerNode(\"Polkadot.js/Data/Verify\",\nclass VerifyNode extends Blackprint.Node {\n\t// Input port\n\tstatic input = {\n\t\t/** Wallet/account address in base58 format */\n\t\tAddress: String,\n\t\t/** Original data */\n\t\tData: Blackprint.Port.Union([String, Uint8Array]),\n\t\t/** Data's signature */\n\t\tSignature: Blackprint.Port.Union([String, Uint8Array]),\n\t};\n\n\t// Output port\n\tstatic output = {\n\t\t/** Return true if the data's signature is valid */\n\t\tIsValid: Boolean\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // use empty interface\n\t\tiface.title = \"Verify\";\n\n\t\tthis._toast = new NodeToast(this.iface);\n\n\t\t// Manually call 'update' when any cable from input port was disconnected\n\t\tthis.iface.on('cable.disconnect', Context.EventSlot, ({ port })=> {\n\t\t\tif(port.source === 'input') this.update();\n\t\t});\n\t}\n\n\t_fail(msg){\n\t\tthis.output.IsValid = null; // Clear the output data if something was fail/error\n\t\tthis._toast.warn(msg);\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\n\t\tif(!Input.Data)\n\t\t\treturn this._fail(\"Data is required\");\n\n\t\tif(!Input.Address)\n\t\t\treturn this._fail(\"Address is required\");\n\n\t\tif(!Input.Signature)\n\t\t\treturn this._fail(\"Signature is required\");\n\n\t\t// If the Data was string, let's convert it to Uint8Array\n\t\tlet data = Input.Data;\n\t\tif(data.constructor === String){\n\t\t\tif(data.slice(0, 2) === '0x')\n\t\t\t\tdata = polkadotUtil.hexToU8a(data);\n\t\t\telse data = polkadotUtil.stringToU8a(data);\n\t\t}\n\n\t\t// If the Signature was string, maybe it was a Hex, let's convert it to Uint8Array\n\t\tlet sign = Input.Signature;\n\t\tif(sign.constructor === String){\n\t\t\tif(sign.slice(0, 2) === '0x')\n\t\t\t\tsign = polkadotUtil.hexToU8a(sign);\n\t\t\telse return this._fail(\"Signature must be Hex or Uint8Array\");\n\t\t}\n\n\t\t// Remove any node toast\n\t\tthis._toast.clear();\n\n\t\ttry{\n\t\t\t// Verify the message/data and the signature with the public key\n\t\t\tvar temp = polkadotUtilCrypto.signatureVerify(data, sign, Input.Address);\n\t\t} catch(e) {\n\t\t\tthis._fail(e.message);\n\t\t\tthrow e;\n\t\t}\n\n\t\tOutput.IsValid = temp.isValid;\n\t}\n});","/**\n * import { Context } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotApi } = window\n */\n\n\n/**\n * Listen to new block generated on parachain through WebSocket RPC\n * @blackprint node\n * @summary Listen for new blocks\n */\nBlackprint.registerNode(\"Polkadot.js/Events/Blocks\",\nclass BlocksNode extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\t// Input port\n\tstatic input = {\n\t\t/** Polkadot.js's WebSocket API */\n\t\tAPI: polkadotApi.ApiPromise,\n\t};\n\n\t// Output port\n\tstatic output = {\n\t\t/** Raw event data */\n\t\tData: Object,\n\t\t/** Block number */\n\t\tNumber: Number,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\t// Use custom interface\n\t\t// Engine: scroll down this file to \"Blackprint.registerInterface\"\n\t\t// Browser: ./Blocks.sf\n\t\tlet iface = this.setInterface('BPIC/Polkadot.js/Events/Blocks');\n\t\tiface.title = \"Blocks Event\";\n\n\t\tthis._toast = new NodeToast(iface);\n\t}\n\n\t// This will be called by the engine after the node has been loaded\n\t// and other data like cable connection has been connected/added\n\tinit(){\n\t\tlet { IInput } = this.ref; // Shortcut\n\n\t\t// Listen if the cable was disconnected from the input port\n\t\tIInput.API.on('disconnect', Context.EventSlot, ()=> {\n\t\t\tthis.iface.unsubscribe();\n\t\t});\n\t}\n\n\t// This will be called by the engine when this node is deleted\n\tdestroy(){\n\t\tthis.iface.unsubscribe();\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tasync update(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\n\t\t// If this node is already subscribing to blocks event, let's unsubscribe it\n\t\tthis.iface.unsubscribe();\n\n\t\tlet api = Input.API;\n\t\tif(!api) return;\n\n\t\tif(!api.hasSubscriptions)\n\t\t\treturn this._toast.error(\"Please use WebSocket for using this feature\");\n\n\t\tthis._toast.clear();\n\n\t\t// Subscribe to new heads/blocks and save the 'unsubscribe' function\n\t\tthis._toast.warn(\"Subscribing...\");\n\t\tthis.iface.unsubscribe = await api.rpc.chain.subscribeNewHeads(header => {\n\t\t\tOutput.Data = header;\n\t\t\tOutput.Number = this.iface.number = header.number.toNumber();\n\t\t});\n\n\t\t// Clear the toast\n\t\tthis._toast.clear();\n\t\tthis._toast.success(\"Subscribed!\");\n\t}\n});\n\n\n// Register Blackprint Interface (like an API for developer, or UI for sketch editor)\nBlackprint.registerInterface('BPIC/Polkadot.js/Events/Blocks',\nContext.IFace.EventsBlocks = class BlocksIFace extends Blackprint.Interface {\n\tconstructor(node){\n\t\tsuper(node);\n\n\t\tthis.number = 0; // blocks number\n\n\t\t// This will be replaced if subcribing to an event, default: no operation\n\t\tthis.unsubscribe = ()=> {};\n\t}\n});","/**\n * import { Substrate_BlackprintNodeGenerator } from \"../utils/SubstrateNodes.js\";\n */\n\n// This file may get changed on the future\n\n// https://polkadot.js.org/docs/substrate/storage\n// The parameters will be input port, and the returned data will be the output port\n// The function name will be the node's name (ex: Author HasKey)\n\nSubstrate_BlackprintNodeGenerator({\n\tnamespace: 'Extrinsics',\n\tdescription: '[Experimental] Substrate Extrinsics',\n\tapiPath: 'tx',\n\tloose: true,\n\tisExtrinsics: true, // All extrinsic doesn't seem return value, we will allow user to call other function instead\n}, [\n\t{\n\t\tname: \"Assets\", rpc_path: \"assets\",\n\t\tfuncs: `\n\t\t\tapproveTransfer(id: Compact<u32>, delegate: MultiAddress, amount: Compact<u128>)\n\t\t\tburn(id: Compact<u32>, who: MultiAddress, amount: Compact<u128>)\n\t\t\tcancelApproval(id: Compact<u32>, delegate: MultiAddress)\n\t\t\tclearMetadata(id: Compact<u32>)\n\t\t\tcreate(id: Compact<u32>, admin: MultiAddress, min_balance: u128)\n\t\t\tdestroy(id: Compact<u32>, witness: PalletAssetsDestroyWitness)\n\t\t\tforceAssetStatus(id: Compact<u32>, owner: MultiAddress, issuer: MultiAddress, admin: MultiAddress, freezer: MultiAddress, min_balance: Compact<u128>, is_sufficient: bool, is_frozen: bool)\n\t\t\tforceCancelApproval(id: Compact<u32>, owner: MultiAddress, delegate: MultiAddress)\n\t\t\tforceClearMetadata(id: Compact<u32>)\n\t\t\tforceCreate(id: Compact<u32>, owner: MultiAddress, is_sufficient: bool, min_balance: Compact<u128>)\n\t\t\tforceSetMetadata(id: Compact<u32>, name: Bytes, symbol: Bytes, decimals: u8, is_frozen: bool)\n\t\t\tforceTransfer(id: Compact<u32>, source: MultiAddress, dest: MultiAddress, amount: Compact<u128>)\n\t\t\tfreeze(id: Compact<u32>, who: MultiAddress)\n\t\t\tfreezeAsset(id: Compact<u32>)\n\t\t\tmint(id: Compact<u32>, beneficiary: MultiAddress, amount: Compact<u128>)\n\t\t\trefund(id: Compact<u32>, allow_burn: bool)\n\t\t\tsetMetadata(id: Compact<u32>, name: Bytes, symbol: Bytes, decimals: u8)\n\t\t\tsetTeam(id: Compact<u32>, issuer: MultiAddress, admin: MultiAddress, freezer: MultiAddress)\n\t\t\tthaw(id: Compact<u32>, who: MultiAddress)\n\t\t\tthawAsset(id: Compact<u32>)\n\t\t\ttouch(id: Compact<u32>)\n\t\t\ttransfer(id: Compact<u32>, target: MultiAddress, amount: Compact<u128>)\n\t\t\ttransferApproved(id: Compact<u32>, owner: MultiAddress, destination: MultiAddress, amount: Compact<u128>)\n\t\t\ttransferKeepAlive(id: Compact<u32>, target: MultiAddress, amount: Compact<u128>)\n\t\t\ttransferOwnership(id: Compact<u32>, owner: MultiAddress)\n\t\t`\n\t}, {\n\t\tname: \"Authorship\", rpc_path: \"authorship\",\n\t\tfuncs: `\n\t\t\tsetUncles(new_uncles: Vec<SpRuntimeHeader>)\n\t\t`\n\t}, {\n\t\tname: \"Babe\", rpc_path: \"babe\",\n\t\tfuncs: `\n\t\t\tplanConfigChange(config: SpConsensusBabeDigestsNextConfigDescriptor)\n\t\t\treportEquivocation(equivocation_proof: SpConsensusSlotsEquivocationProof, key_owner_proof: SpSessionMembershipProof)\n\t\t\treportEquivocationUnsigned(equivocation_proof: SpConsensusSlotsEquivocationProof, key_owner_proof: SpSessionMembershipProof)\n\t\t`\n\t}, {\n\t\tname: \"BagsList\", rpc_path: \"bagsList\",\n\t\tfuncs: `\n\t\t\tputInFrontOf(lighter: AccountId32)\n\t\t\trebag(dislocated: AccountId32)\n\t\t`\n\t}, {\n\t\tname: \"Balances\", rpc_path: \"balances\",\n\t\tfuncs: `\n\t\t\tforceTransfer(source: MultiAddress, dest: MultiAddress, value: Compact<u128>)\n\t\t\tforceUnreserve(who: MultiAddress, amount: u128)\n\t\t\tsetBalance(who: MultiAddress, new_free: Compact<u128>, new_reserved: Compact<u128>)\n\t\t\ttransfer(dest: MultiAddress, value: Compact<u128>)\n\t\t\ttransferAll(dest: MultiAddress, keep_alive: bool)\n\t\t\ttransferKeepAlive(dest: MultiAddress, value: Compact<u128>)\n\t\t`\n\t}, {\n\t\tname: \"Bounties\", rpc_path: \"bounties\",\n\t\tfuncs: `\n\t\t\tacceptCurator(bounty_id: Compact<u32>)\n\t\t\tapproveBounty(bounty_id: Compact<u32>)\n\t\t\tawardBounty(bounty_id: Compact<u32>, beneficiary: MultiAddress)\n\t\t\tclaimBounty(bounty_id: Compact<u32>)\n\t\t\tcloseBounty(bounty_id: Compact<u32>)\n\t\t\textendBountyExpiry(bounty_id: Compact<u32>, remark: Bytes)\n\t\t\tproposeBounty(value: Compact<u128>, description: Bytes)\n\t\t\tproposeCurator(bounty_id: Compact<u32>, curator: MultiAddress, fee: Compact<u128>)\n\t\t\tunassignCurator(bounty_id: Compact<u32>)\n\t\t`\n\t}, {\n\t\tname: \"ChildBounties\", rpc_path: \"childBounties\",\n\t\tfuncs: `\n\t\t\tacceptCurator(parent_bounty_id: Compact<u32>, child_bounty_id: Compact<u32>)\n\t\t\taddChildBounty(parent_bounty_id: Compact<u32>, value: Compact<u128>, description: Bytes)\n\t\t\tawardChildBounty(parent_bounty_id: Compact<u32>, child_bounty_id: Compact<u32>, beneficiary: MultiAddress)\n\t\t\tclaimChildBounty(parent_bounty_id: Compact<u32>, child_bounty_id: Compact<u32>)\n\t\t\tcloseChildBounty(parent_bounty_id: Compact<u32>, child_bounty_id: Compact<u32>)\n\t\t\tproposeCurator(parent_bounty_id: Compact<u32>, child_bounty_id: Compact<u32>, curator: MultiAddress, fee: Compact<u128>)\n\t\t\tunassignCurator(parent_bounty_id: Compact<u32>, child_bounty_id: Compact<u32>)\n\t\t`\n\t}, {\n\t\tname: \"Contracts\", rpc_path: \"contracts\",\n\t\tfuncs: `\n\t\t\tcall(dest: MultiAddress, value: Compact<u128>, gas_limit: Compact<u64>, storage_deposit_limit: Option<Compact<u128>>, data: Bytes)\n\t\t\tinstantiate(value: Compact<u128>, gas_limit: Compact<u64>, storage_deposit_limit: Option<Compact<u128>>, code_hash: H256, data: Bytes, salt: Bytes)\n\t\t\tinstantiateWithCode(value: Compact<u128>, gas_limit: Compact<u64>, storage_deposit_limit: Option<Compact<u128>>, code: Bytes, data: Bytes, salt: Bytes)\n\t\t\tremoveCode(code_hash: H256)\n\t\t\tuploadCode(code: Bytes, storage_deposit_limit: Option<Compact<u128>>)\n\t\t`\n\t}, {\n\t\tname: \"Council\", rpc_path: \"council\",\n\t\tfuncs: `\n\t\t\tclose(proposal_hash: H256, index: Compact<u32>, proposal_weight_bound: Compact<u64>, length_bound: Compact<u32>)\n\t\t\tdisapproveProposal(proposal_hash: H256)\n\t\t\texecute(proposal: Call, length_bound: Compact<u32>)\n\t\t\tpropose(threshold: Compact<u32>, proposal: Call, length_bound: Compact<u32>)\n\t\t\tsetMembers(new_members: Vec<AccountId32>, prime: Option<AccountId32>, old_count: u32)\n\t\t\tvote(proposal: H256, index: Compact<u32>, approve: bool)\n\t\t`\n\t}, {\n\t\tname: \"Democracy\", rpc_path: \"democracy\",\n\t\tfuncs: `\n\t\t\tblacklist(proposal_hash: H256, maybe_ref_index: Option<u32>)\n\t\t\tcancelProposal(prop_index: Compact<u32>)\n\t\t\tcancelQueued(which: u32)\n\t\t\tcancelReferendum(ref_index: Compact<u32>)\n\t\t\tclearPublicProposals()\n\t\t\tdelegate(to: AccountId32, conviction: PalletDemocracyConviction, balance: u128)\n\t\t\temergencyCancel(ref_index: u32)\n\t\t\tenactProposal(proposal_hash: H256, index: u32)\n\t\t\texternalPropose(proposal_hash: H256)\n\t\t\texternalProposeDefault(proposal_hash: H256)\n\t\t\texternalProposeMajority(proposal_hash: H256)\n\t\t\tfastTrack(proposal_hash: H256, voting_period: u32, delay: u32)\n\t\t\tnoteImminentPreimage(encoded_proposal: Bytes)\n\t\t\tnoteImminentPreimageOperational(encoded_proposal: Bytes)\n\t\t\tnotePreimage(encoded_proposal: Bytes)\n\t\t\tnotePreimageOperational(encoded_proposal: Bytes)\n\t\t\tpropose(proposal_hash: H256, value: Compact<u128>)\n\t\t\treapPreimage(proposal_hash: H256, proposal_len_upper_bound: Compact<u32>)\n\t\t\tremoveOtherVote(target: AccountId32, index: u32)\n\t\t\tremoveVote(index: u32)\n\t\t\tsecond(proposal: Compact<u32>, seconds_upper_bound: Compact<u32>)\n\t\t\tundelegate()\n\t\t\tunlock(target: AccountId32)\n\t\t\tvetoExternal(proposal_hash: H256)\n\t\t\tvote(ref_index: Compact<u32>, vote: PalletDemocracyVoteAccountVote)\n\t\t`\n\t}, {\n\t\tname: \"ElectionProviderMultiPhase\", rpc_path: \"electionProviderMultiPhase\",\n\t\tfuncs: `\n\t\t\tgovernanceFallback(maybe_max_voters: Option<u32>, maybe_max_targets: Option<u32>)\n\t\t\tsetEmergencyElectionResult(supports: Vec<(AccountId32,SpNposElectionsSupport)>)\n\t\t\tsetMinimumUntrustedScore(maybe_next_score: Option<[u128;3]>)\n\t\t\tsubmit(raw_solution: PalletElectionProviderMultiPhaseRawSolution, num_signed_submissions: u32)\n\t\t\tsubmitUnsigned(raw_solution: PalletElectionProviderMultiPhaseRawSolution, witness: PalletElectionProviderMultiPhaseSolutionOrSnapshotSize)\n\t\t`\n\t}, {\n\t\tname: \"Elections\", rpc_path: \"elections\",\n\t\tfuncs: `\n\t\t\tcleanDefunctVoters(num_voters: u32, num_defunct: u32)\n\t\t\tremoveMember(who: MultiAddress, has_replacement: bool)\n\t\t\tremoveVoter()\n\t\t\trenounceCandidacy(renouncing: PalletElectionsPhragmenRenouncing)\n\t\t\tsubmitCandidacy(candidate_count: Compact<u32>)\n\t\t\tvote(votes: Vec<AccountId32>, value: Compact<u128>)\n\t\t`\n\t}, {\n\t\tname: \"Gilt\", rpc_path: \"gilt\",\n\t\tfuncs: `\n\t\t\tplaceBid(amount: Compact<u128>, duration: u32)\n\t\t\tretractBid(amount: Compact<u128>, duration: u32)\n\t\t\tsetTarget(target: Compact<Perquintill>)\n\t\t\tthaw(index: Compact<u32>)\n\t\t`\n\t}, {\n\t\tname: \"Grandpa\", rpc_path: \"grandpa\",\n\t\tfuncs: `\n\t\t\tnoteStalled(delay: u32, best_finalized_block_number: u32)\n\t\t\treportEquivocation(equivocation_proof: SpFinalityGrandpaEquivocationProof, key_owner_proof: SpSessionMembershipProof)\n\t\t\treportEquivocationUnsigned(equivocation_proof: SpFinalityGrandpaEquivocationProof, key_owner_proof: SpSessionMembershipProof)\n\t\t`\n\t}, {\n\t\tname: \"Identity\", rpc_path: \"identity\",\n\t\tfuncs: `\n\t\t\taddRegistrar(account: AccountId32)\n\t\t\taddSub(sub: MultiAddress, data: Data)\n\t\t\tcancelRequest(reg_index: u32)\n\t\t\tclearIdentity()\n\t\t\tkillIdentity(target: MultiAddress)\n\t\t\tprovideJudgement(reg_index: Compact<u32>, target: MultiAddress, judgement: PalletIdentityJudgement)\n\t\t\tquitSub()\n\t\t\tremoveSub(sub: MultiAddress)\n\t\t\trenameSub(sub: MultiAddress, data: Data)\n\t\t\trequestJudgement(reg_index: Compact<u32>, max_fee: Compact<u128>)\n\t\t\tsetAccountId(index: Compact<u32>, new: AccountId32)\n\t\t\tsetFee(index: Compact<u32>, fee: Compact<u128>)\n\t\t\tsetFields(index: Compact<u32>, fields: PalletIdentityBitFlags)\n\t\t\tsetIdentity(info: PalletIdentityIdentityInfo)\n\t\t\tsetSubs(subs: Vec<(AccountId32,Data)>)\n\t\t`\n\t}, {\n\t\tname: \"ImOnline\", rpc_path: \"imOnline\",\n\t\tfuncs: `\n\t\t\theartbeat(heartbeat: PalletImOnlineHeartbeat, signature: PalletImOnlineSr25519AppSr25519Signature)\n\t\t`\n\t}, {\n\t\tname: \"Indices\", rpc_path: \"indices\",\n\t\tfuncs: `\n\t\t\tclaim(index: u32)\n\t\t\tforceTransfer(new: AccountId32, index: u32, freeze: bool)\n\t\t\tfree(index: u32)\n\t\t\tfreeze(index: u32)\n\t\t\ttransfer(new: AccountId32, index: u32)\n\t\t`\n\t}, {\n\t\tname: \"Lottery\", rpc_path: \"lottery\",\n\t\tfuncs: `\n\t\t\tbuyTicket(call: Call)\n\t\t\tsetCalls(calls: Vec<Call>)\n\t\t\tstartLottery(price: u128, length: u32, delay: u32, repeat: bool)\n\t\t\tstopRepeat()\n\t\t`\n\t}, {\n\t\tname: \"Multisig\", rpc_path: \"multisig\",\n\t\tfuncs: `\n\t\t\tapproveAsMulti(threshold: u16, other_signatories: Vec<AccountId32>, maybe_timepoint: Option<PalletMultisigTimepoint>, call_hash: [u8;32], max_weight: u64)\n\t\t\tasMulti(threshold: u16, other_signatories: Vec<AccountId32>, maybe_timepoint: Option<PalletMultisigTimepoint>, call: WrapperKeepOpaque<Call>, store_call: bool, max_weight: u64)\n\t\t\tasMultiThreshold1(other_signatories: Vec<AccountId32>, call: Call)\n\t\t\tcancelAsMulti(threshold: u16, other_signatories: Vec<AccountId32>, timepoint: PalletMultisigTimepoint, call_hash: [u8;32])\n\t\t`\n\t}, {\n\t\tname: \"Preimage\", rpc_path: \"preimage\",\n\t\tfuncs: `\n\t\t\tnotePreimage(bytes: Bytes)\n\t\t\trequestPreimage(hash: H256)\n\t\t\tunnotePreimage(hash: H256)\n\t\t\tunrequestPreimage(hash: H256)\n\t\t`\n\t}, {\n\t\tname: \"Proxy\", rpc_path: \"proxy\",\n\t\tfuncs: `\n\t\t\taddProxy(delegate: AccountId32, proxy_type: NodeRuntimeProxyType, delay: u32)\n\t\t\tannounce(real: AccountId32, call_hash: H256)\n\t\t\tanonymous(proxy_type: NodeRuntimeProxyType, delay: u32, index: u16)\n\t\t\tkillAnonymous(spawner: AccountId32, proxy_type: NodeRuntimeProxyType, index: u16, height: Compact<u32>, ext_index: Compact<u32>)\n\t\t\tproxy(real: AccountId32, force_proxy_type: Option<NodeRuntimeProxyType>, call: Call)\n\t\t\tproxyAnnounced(delegate: AccountId32, real: AccountId32, force_proxy_type: Option<NodeRuntimeProxyType>, call: Call)\n\t\t\trejectAnnouncement(delegate: AccountId32, call_hash: H256)\n\t\t\tremoveAnnouncement(real: AccountId32, call_hash: H256)\n\t\t\tremoveProxies()\n\t\t\tremoveProxy(delegate: AccountId32, proxy_type: NodeRuntimeProxyType, delay: u32)\n\t\t`\n\t}, {\n\t\tname: \"Recovery\", rpc_path: \"recovery\",\n\t\tfuncs: `\n\t\t\tasRecovered(account: AccountId32, call: Call)\n\t\t\tcancelRecovered(account: AccountId32)\n\t\t\tclaimRecovery(account: AccountId32)\n\t\t\tcloseRecovery(rescuer: AccountId32)\n\t\t\tcreateRecovery(friends: Vec<AccountId32>, threshold: u16, delay_period: u32)\n\t\t\tinitiateRecovery(account: AccountId32)\n\t\t\tremoveRecovery()\n\t\t\tsetRecovered(lost: AccountId32, rescuer: AccountId32)\n\t\t\tvouchRecovery(lost: AccountId32, rescuer: AccountId32)\n\t\t`\n\t}, {\n\t\tname: \"Scheduler\", rpc_path: \"scheduler\",\n\t\tfuncs: `\n\t\t\tcancel(when: u32, index: u32)\n\t\t\tcancelNamed(id: Bytes)\n\t\t\tschedule(when: u32, maybe_periodic: Option<(u32,u32)>, priority: u8, call: FrameSupportScheduleMaybeHashed)\n\t\t\tscheduleAfter(after: u32, maybe_periodic: Option<(u32,u32)>, priority: u8, call: FrameSupportScheduleMaybeHashed)\n\t\t\tscheduleNamed(id: Bytes, when: u32, maybe_periodic: Option<(u32,u32)>, priority: u8, call: FrameSupportScheduleMaybeHashed)\n\t\t\tscheduleNamedAfter(id: Bytes, after: u32, maybe_periodic: Option<(u32,u32)>, priority: u8, call: FrameSupportScheduleMaybeHashed)\n\t\t`\n\t}, {\n\t\tname: \"Session\", rpc_path: \"session\",\n\t\tfuncs: `\n\t\t\tpurgeKeys()\n\t\t\tsetKeys(keys: NodeRuntimeSessionKeys, proof: Bytes)\n\t\t`\n\t}, {\n\t\tname: \"Society\", rpc_path: \"society\",\n\t\tfuncs: `\n\t\t\tbid(value: u128)\n\t\t\tdefenderVote(approve: bool)\n\t\t\tfound(founder: AccountId32, max_members: u32, rules: Bytes)\n\t\t\tjudgeSuspendedCandidate(who: AccountId32, judgement: PalletSocietyJudgement)\n\t\t\tjudgeSuspendedMember(who: AccountId32, forgive: bool)\n\t\t\tpayout()\n\t\t\tsetMaxMembers(max: u32)\n\t\t\tunbid(pos: u32)\n\t\t\tunfound()\n\t\t\tunvouch(pos: u32)\n\t\t\tvote(candidate: MultiAddress, approve: bool)\n\t\t\tvouch(who: AccountId32, value: u128, tip: u128)\n\t\t`\n\t}, {\n\t\tname: \"Staking\", rpc_path: \"staking\",\n\t\tfuncs: `\n\t\t\tbond(controller: MultiAddress, value: Compact<u128>, payee: PalletStakingRewardDestination)\n\t\t\tbondExtra(max_additional: Compact<u128>)\n\t\t\tcancelDeferredSlash(era: u32, slash_indices: Vec<u32>)\n\t\t\tchill()\n\t\t\tchillOther(controller: AccountId32)\n\t\t\tforceNewEra()\n\t\t\tforceNewEraAlways()\n\t\t\tforceNoEras()\n\t\t\tforceUnstake(stash: AccountId32, num_slashing_spans: u32)\n\t\t\tincreaseValidatorCount(additional: Compact<u32>)\n\t\t\tkick(who: Vec<MultiAddress>)\n\t\t\tnominate(targets: Vec<MultiAddress>)\n\t\t\tpayoutStakers(validator_stash: AccountId32, era: u32)\n\t\t\treapStash(stash: AccountId32, num_slashing_spans: u32)\n\t\t\trebond(value: Compact<u128>)\n\t\t\tscaleValidatorCount(factor: Percent)\n\t\t\tsetController(controller: MultiAddress)\n\t\t\tsetHistoryDepth(new_history_depth: Compact<u32>, era_items_deleted: Compact<u32>)\n\t\t\tsetInvulnerables(invulnerables: Vec<AccountId32>)\n\t\t\tsetPayee(payee: PalletStakingRewardDestination)\n\t\t\tsetStakingConfigs(min_nominator_bond: u128, min_validator_bond: u128, max_nominator_count: Option<u32>, max_validator_count: Option<u32>, chill_threshold: Option<Percent>, min_commission: Perbill)\n\t\t\tsetValidatorCount(new: Compact<u32>)\n\t\t\tunbond(value: Compact<u128>)\n\t\t\tvalidate(prefs: PalletStakingValidatorPrefs)\n\t\t\twithdrawUnbonded(num_slashing_spans: u32)\n\t\t`\n\t}, {\n\t\tname: \"Sudo\", rpc_path: \"sudo\",\n\t\tfuncs: `\n\t\t\tsetKey(new: MultiAddress)\n\t\t\tsudo(call: Call)\n\t\t\tsudoAs(who: MultiAddress, call: Call)\n\t\t\tsudoUncheckedWeight(call: Call, weight: u64)\n\t\t`\n\t}, {\n\t\tname: \"System\", rpc_path: \"system\",\n\t\tfuncs: `\n\t\t\tfillBlock(ratio: Perbill)\n\t\t\tkillPrefix(prefix: Bytes, subkeys: u32)\n\t\t\tkillStorage(keys: Vec<Bytes>)\n\t\t\tremark(remark: Bytes)\n\t\t\tremarkWithEvent(remark: Bytes)\n\t\t\tsetCode(code: Bytes)\n\t\t\tsetCodeWithoutChecks(code: Bytes)\n\t\t\tsetHeapPages(pages: u64)\n\t\t\tsetStorage(items: Vec<(Bytes,Bytes)>)\n\t\t`\n\t}, {\n\t\tname: \"TechnicalCommittee\", rpc_path: \"technicalCommittee\",\n\t\tfuncs: `\n\t\t\tclose(proposal_hash: H256, index: Compact<u32>, proposal_weight_bound: Compact<u64>, length_bound: Compact<u32>)\n\t\t\tdisapproveProposal(proposal_hash: H256)\n\t\t\texecute(proposal: Call, length_bound: Compact<u32>)\n\t\t\tpropose(threshold: Compact<u32>, proposal: Call, length_bound: Compact<u32>)\n\t\t\tsetMembers(new_members: Vec<AccountId32>, prime: Option<AccountId32>, old_count: u32)\n\t\t\tvote(proposal: H256, index: Compact<u32>, approve: bool)\n\t\t`\n\t}, {\n\t\tname: \"TechnicalMembership\", rpc_path: \"technicalMembership\",\n\t\tfuncs: `\n\t\t\taddMember(who: AccountId32)\n\t\t\tchangeKey(new: AccountId32)\n\t\t\tclearPrime()\n\t\t\tremoveMember(who: AccountId32)\n\t\t\tresetMembers(members: Vec<AccountId32>)\n\t\t\tsetPrime(who: AccountId32)\n\t\t\tswapMember(remove: AccountId32, add: AccountId32)\n\t\t`\n\t}, {\n\t\tname: \"Timestamp\", rpc_path: \"timestamp\",\n\t\tfuncs: `\n\t\t\tset(now: Compact<u64>)\n\t\t`\n\t}, {\n\t\tname: \"Tips\", rpc_path: \"tips\",\n\t\tfuncs: `\n\t\t\tcloseTip(hash: H256)\n\t\t\treportAwesome(reason: Bytes, who: AccountId32)\n\t\t\tretractTip(hash: H256)\n\t\t\tslashTip(hash: H256)\n\t\t\ttip(hash: H256, tip_value: Compact<u128>)\n\t\t\ttipNew(reason: Bytes, who: AccountId32, tip_value: Compact<u128>)\n\t\t`\n\t}, {\n\t\tname: \"TransactionStorage\", rpc_path: \"transactionStorage\",\n\t\tfuncs: `\n\t\t\tcheckProof(proof: SpTransactionStorageProofTransactionStorageProof)\n\t\t\trenew(block: u32, index: u32)\n\t\t\tstore(data: Bytes)\n\t\t`\n\t}, {\n\t\tname: \"Treasury\", rpc_path: \"treasury\",\n\t\tfuncs: `\n\t\t\tapproveProposal(proposal_id: Compact<u32>)\n\t\t\tproposeSpend(value: Compact<u128>, beneficiary: MultiAddress)\n\t\t\trejectProposal(proposal_id: Compact<u32>)\n\t\t`\n\t}, {\n\t\tname: \"Uniques\", rpc_path: \"uniques\",\n\t\tfuncs: `\n\t\t\tapproveTransfer(class: Compact<u32>, instance: Compact<u32>, delegate: MultiAddress)\n\t\t\tburn(class: Compact<u32>, instance: Compact<u32>, check_owner: Option<MultiAddress>)\n\t\t\tcancelApproval(class: Compact<u32>, instance: Compact<u32>, maybe_check_delegate: Option<MultiAddress>)\n\t\t\tclearAttribute(class: Compact<u32>, maybe_instance: Option<u32>, key: Bytes)\n\t\t\tclearClassMetadata(class: Compact<u32>)\n\t\t\tclearMetadata(class: Compact<u32>, instance: Compact<u32>)\n\t\t\tcreate(class: Compact<u32>, admin: MultiAddress)\n\t\t\tdestroy(class: Compact<u32>, witness: PalletUniquesDestroyWitness)\n\t\t\tforceAssetStatus(class: Compact<u32>, owner: MultiAddress, issuer: MultiAddress, admin: MultiAddress, freezer: MultiAddress, free_holding: bool, is_frozen: bool)\n\t\t\tforceCreate(class: Compact<u32>, owner: MultiAddress, free_holding: bool)\n\t\t\tfreeze(class: Compact<u32>, instance: Compact<u32>)\n\t\t\tfreezeClass(class: Compact<u32>)\n\t\t\tmint(class: Compact<u32>, instance: Compact<u32>, owner: MultiAddress)\n\t\t\tredeposit(class: Compact<u32>, instances: Vec<u32>)\n\t\t\tsetAttribute(class: Compact<u32>, maybe_instance: Option<u32>, key: Bytes, value: Bytes)\n\t\t\tsetClassMetadata(class: Compact<u32>, data: Bytes, is_frozen: bool)\n\t\t\tsetMetadata(class: Compact<u32>, instance: Compact<u32>, data: Bytes, is_frozen: bool)\n\t\t\tsetTeam(class: Compact<u32>, issuer: MultiAddress, admin: MultiAddress, freezer: MultiAddress)\n\t\t\tthaw(class: Compact<u32>, instance: Compact<u32>)\n\t\t\tthawClass(class: Compact<u32>)\n\t\t\ttransfer(class: Compact<u32>, instance: Compact<u32>, dest: MultiAddress)\n\t\t\ttransferOwnership(class: Compact<u32>, owner: MultiAddress)\n\t\t`\n\t}, {\n\t\tname: \"Utility\", rpc_path: \"utility\",\n\t\tfuncs: `\n\t\t\tasDerivative(index: u16, call: Call)\n\t\t\tbatch(calls: Vec<Call>)\n\t\t\tbatchAll(calls: Vec<Call>)\n\t\t\tdispatchAs(as_origin: NodeRuntimeOriginCaller, call: Call)\n\t\t`\n\t}, {\n\t\tname: \"Vesting\", rpc_path: \"vesting\",\n\t\tfuncs: `\n\t\t\tforceVestedTransfer(source: MultiAddress, target: MultiAddress, schedule: PalletVestingVestingInfo)\n\t\t\tmergeSchedules(schedule1_index: u32, schedule2_index: u32)\n\t\t\tvest()\n\t\t\tvestOther(target: MultiAddress)\n\t\t\tvestedTransfer(target: MultiAddress, schedule: PalletVestingVestingInfo)\n\t\t`\n\t}\n]);","/**\n * import { Context, Signer } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotApi, polkadotUtilCrypto } = window\n */\n\n\n/**\n * Create a wallet with a random seed\n * This can be useful for testing something\n * @blackprint node\n * @summary Randomly generated wallet\n */\nBlackprint.registerNode(\"Polkadot.js/Keyring/RandomSeed\",\nclass extends Blackprint.Node {\n\t// Input port\n\tstatic input = {\n\t\t/** This must be one of ed25519, sr25519, ethereum, or ecdsa */\n\t\tKeyType: Blackprint.Port.Default(String, 'ed25519'),\n\t};\n\n\t// Output port\n\tstatic output = {\n\t\t/** Wallet/account address in base58 format */\n\t\tAddress: String,\n\t\t/** Random seed that was being used to generate this random wallet */\n\t\tSeed: Uint8Array,\n\t\t/** This wallet's signer */\n\t\tSigner: Signer,\n\t\t/** This wallet's pair key */\n\t\tPair: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // use empty interface\n\t\tiface.title = \"Random Key\";\n\t}\n\n\t// This will be called by the engine once the node has been loaded\n\timported(){ this.update() }\n\n\t// This will be called by the engine if the input port have a new value\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\n\t\t// Generate new seed and put it to the output port\n\t\tOutput.Seed = polkadotUtilCrypto.randomAsU8a(32);\n\n\t\tlet keyring = new polkadotApi.Keyring({\n\t\t\ttype: Input.KeyType, // default to ed25519\n\t\t\tss58Format: 0, // To use different format, Polkadot.js/Convert/Address To/Address is recommended\n\t\t});\n\n\t\t// Create keypair from seed and put it to the output port\n\t\tlet pair = Output.Pair = keyring.addFromSeed(Output.Seed);\n\n\t\t// Wrap the signer and put the public address to the output port\n\t\tOutput.Signer = new Signer(true, Output.Address, pair);\n\t\tOutput.Address = pair.address;\n\t}\n});","/**\n * import { Substrate_BlackprintNodeGenerator } from \"../utils/SubstrateNodes.js\";\n */\n\n// This file may get changed on the future\n\n// https://polkadot.js.org/docs/substrate/storage\n// The parameters will be input port, and the returned data will be the output port\n// The function name will be the node's name (ex: Author HasKey)\n\nSubstrate_BlackprintNodeGenerator({\n\tnamespace: 'Storage',\n\tdescription: '[Experimental] Substrate Storage',\n\tapiPath: 'query',\n\tloose: true,\n\ttypeAsName: true,\n}, [\n\t{\n\t\tname: \"Assets\", rpc_path: \"assets\",\n\t\tfuncs: `\n\t\t\taccount(u32, AccountId32): Option<PalletAssetsAssetAccount>\n\t\t\tapprovals(u32, AccountId32, AccountId32): Option<PalletAssetsApproval>\n\t\t\tasset(u32): Option<PalletAssetsAssetDetails>\n\t\t\tmetadata(u32): PalletAssetsAssetMetadata\n\t\t`\n\t}, {\n\t\tname: \"AuthorityDiscovery\", rpc_path: \"authorityDiscovery\",\n\t\tfuncs: `\n\t\t\tkeys(): Vec<SpAuthorityDiscoveryAppPublic>\n\t\t\tnextKeys(): Vec<SpAuthorityDiscoveryAppPublic>\n\t\t`\n\t}, {\n\t\tname: \"Authorship\", rpc_path: \"authorship\",\n\t\tfuncs: `\n\t\t\tauthor(): Option<AccountId32>\n\t\t\tdidSetUncles(): bool\n\t\t\tuncles(): Vec<PalletAuthorshipUncleEntryItem>\n\t\t`\n\t}, {\n\t\tname: \"Babe\", rpc_path: \"babe\",\n\t\tfuncs: `\n\t\t\tauthorities(): Vec<(SpConsensusBabeAppPublic,u64)>\n\t\t\tauthorVrfRandomness(): Option<[u8;32]>\n\t\t\tcurrentSlot(): u64\n\t\t\tepochConfig(): Option<SpConsensusBabeBabeEpochConfiguration>\n\t\t\tepochIndex(): u64\n\t\t\tepochStart(): (u32,u32)\n\t\t\tgenesisSlot(): u64\n\t\t\tinitialized(): Option<Option<[u8;32]>>\n\t\t\tlateness(): u32\n\t\t\tnextAuthorities(): Vec<(SpConsensusBabeAppPublic,u64)>\n\t\t\tnextEpochConfig(): Option<SpConsensusBabeBabeEpochConfiguration>\n\t\t\tnextRandomness(): [u8;32]\n\t\t\tpendingEpochConfigChange(): Option<SpConsensusBabeDigestsNextConfigDescriptor>\n\t\t\trandomness(): [u8;32]\n\t\t\tsegmentIndex(): u32\n\t\t\tunderConstruction(u32): Vec<[u8;32]>\n\t\t`\n\t}, {\n\t\tname: \"BagsList\", rpc_path: \"bagsList\",\n\t\tfuncs: `\n\t\t\tcounterForListNodes(): u32\n\t\t\tlistBags(u64): Option<PalletBagsListListBag>\n\t\t\tlistNodes(AccountId32): Option<PalletBagsListListNode>\n\t\t`\n\t}, {\n\t\tname: \"Balances\", rpc_path: \"balances\",\n\t\tfuncs: `\n\t\t\taccount(AccountId32): PalletBalancesAccountData\n\t\t\tlocks(AccountId32): Vec<PalletBalancesBalanceLock>\n\t\t\treserves(AccountId32): Vec<PalletBalancesReserveData>\n\t\t\tstorageVersion(): PalletBalancesReleases\n\t\t\ttotalIssuance(): u128\n\t\t`\n\t}, {\n\t\tname: \"Bounties\", rpc_path: \"bounties\",\n\t\tfuncs: `\n\t\t\tbounties(u32): Option<PalletBountiesBounty>\n\t\t\tbountyApprovals(): Vec<u32>\n\t\t\tbountyCount(): u32\n\t\t\tbountyDescriptions(u32): Option<Bytes>\n\t\t`\n\t}, {\n\t\tname: \"ChildBounties\", rpc_path: \"childBounties\",\n\t\tfuncs: `\n\t\t\tchildBounties(u32, u32): Option<PalletChildBountiesChildBounty>\n\t\t\tchildBountyCount(): u32\n\t\t\tchildBountyDescriptions(u32): Option<Bytes>\n\t\t\tchildrenCuratorFees(u32): u128\n\t\t\tparentChildBounties(u32): u32\n\t\t`\n\t}, {\n\t\tname: \"Contracts\", rpc_path: \"contracts\",\n\t\tfuncs: `\n\t\t\taccountCounter(): u64\n\t\t\tcodeStorage(H256): Option<PalletContractsWasmPrefabWasmModule>\n\t\t\tcontractInfoOf(AccountId32): Option<PalletContractsStorageRawContractInfo>\n\t\t\tdeletionQueue(): Vec<PalletContractsStorageDeletedContract>\n\t\t\townerInfoOf(H256): Option<PalletContractsWasmOwnerInfo>\n\t\t\tpristineCode(H256): Option<Bytes>\n\t\t`\n\t}, {\n\t\tname: \"Council\", rpc_path: \"council\",\n\t\tfuncs: `\n\t\t\tmembers(): Vec<AccountId32>\n\t\t\tprime(): Option<AccountId32>\n\t\t\tproposalCount(): u32\n\t\t\tproposalOf(H256): Option<Call>\n\t\t\tproposals(): Vec<H256>\n\t\t\tvoting(H256): Option<PalletCollectiveVotes>\n\t\t`\n\t}, {\n\t\tname: \"Democracy\", rpc_path: \"democracy\",\n\t\tfuncs: `\n\t\t\tblacklist(H256): Option<(u32,Vec<AccountId32>)>\n\t\t\tcancellations(H256): bool\n\t\t\tdepositOf(u32): Option<(Vec<AccountId32>,u128)>\n\t\t\tlastTabledWasExternal(): bool\n\t\t\tlocks(AccountId32): Option<u32>\n\t\t\tlowestUnbaked(): u32\n\t\t\tnextExternal(): Option<(H256,PalletDemocracyVoteThreshold)>\n\t\t\tpreimages(H256): Option<PalletDemocracyPreimageStatus>\n\t\t\tpublicPropCount(): u32\n\t\t\tpublicProps(): Vec<(u32,H256,AccountId32)>\n\t\t\treferendumCount(): u32\n\t\t\treferendumInfoOf(u32): Option<PalletDemocracyReferendumInfo>\n\t\t\tstorageVersion(): Option<PalletDemocracyReleases>\n\t\t\tvotingOf(AccountId32): PalletDemocracyVoteVoting\n\t\t`\n\t}, {\n\t\tname: \"ElectionProviderMultiPhase\", rpc_path: \"electionProviderMultiPhase\",\n\t\tfuncs: `\n\t\t\tcurrentPhase(): PalletElectionProviderMultiPhasePhase\n\t\t\tdesiredTargets(): Option<u32>\n\t\t\tminimumUntrustedScore(): Option<[u128;3]>\n\t\t\tqueuedSolution(): Option<PalletElectionProviderMultiPhaseReadySolution>\n\t\t\tround(): u32\n\t\t\tsignedSubmissionIndices(): BTreeMap<[u128;3], u32>\n\t\t\tsignedSubmissionNextIndex(): u32\n\t\t\tsignedSubmissionsMap(u32): Option<PalletElectionProviderMultiPhaseSignedSignedSubmission>\n\t\t\tsnapshot(): Option<PalletElectionProviderMultiPhaseRoundSnapshot>\n\t\t\tsnapshotMetadata(): Option<PalletElectionProviderMultiPhaseSolutionOrSnapshotSize>\n\t\t`\n\t}, {\n\t\tname: \"Elections\", rpc_path: \"elections\",\n\t\tfuncs: `\n\t\t\tcandidates(): Vec<(AccountId32,u128)>\n\t\t\telectionRounds(): u32\n\t\t\tmembers(): Vec<PalletElectionsPhragmenSeatHolder>\n\t\t\trunnersUp(): Vec<PalletElectionsPhragmenSeatHolder>\n\t\t\tvoting(AccountId32): PalletElectionsPhragmenVoter\n\t\t`\n\t}, {\n\t\tname: \"Gilt\", rpc_path: \"gilt\",\n\t\tfuncs: `\n\t\t\tactive(u32): Option<PalletGiltActiveGilt>\n\t\t\tactiveTotal(): PalletGiltActiveGiltsTotal\n\t\t\tqueues(u32): Vec<PalletGiltGiltBid>\n\t\t\tqueueTotals(): Vec<(u32,u128)>\n\t\t`\n\t}, {\n\t\tname: \"Grandpa\", rpc_path: \"grandpa\",\n\t\tfuncs: `\n\t\t\tcurrentSetId(): u64\n\t\t\tnextForced(): Option<u32>\n\t\t\tpendingChange(): Option<PalletGrandpaStoredPendingChange>\n\t\t\tsetIdSession(u64): Option<u32>\n\t\t\tstalled(): Option<(u32,u32)>\n\t\t\tstate(): PalletGrandpaStoredState\n\t\t`\n\t}, {\n\t\tname: \"Identity\", rpc_path: \"identity\",\n\t\tfuncs: `\n\t\t\tidentityOf(AccountId32): Option<PalletIdentityRegistration>\n\t\t\tregistrars(): Vec<Option<PalletIdentityRegistrarInfo>>\n\t\t\tsubsOf(AccountId32): (u128,Vec<AccountId32>)\n\t\t\tsuperOf(AccountId32): Option<(AccountId32,Data)>\n\t\t`\n\t}, {\n\t\tname: \"ImOnline\", rpc_path: \"imOnline\",\n\t\tfuncs: `\n\t\t\tauthoredBlocks(u32, AccountId32): u32\n\t\t\theartbeatAfter(): u32\n\t\t\tkeys(): Vec<PalletImOnlineSr25519AppSr25519Public>\n\t\t\treceivedHeartbeats(u32, u32): Option<WrapperOpaque<PalletImOnlineBoundedOpaqueNetworkState>>\n\t\t`\n\t}, {\n\t\tname: \"Indices\", rpc_path: \"indices\",\n\t\tfuncs: `\n\t\t\taccounts(u32): Option<(AccountId32,u128,bool)>\n\t\t`\n\t}, {\n\t\tname: \"Lottery\", rpc_path: \"lottery\",\n\t\tfuncs: `\n\t\t\tcallIndices(): Vec<(u8,u8)>\n\t\t\tlottery(): Option<PalletLotteryLotteryConfig>\n\t\t\tlotteryIndex(): u32\n\t\t\tparticipants(AccountId32): (u32,Vec<(u8,u8)>)\n\t\t\ttickets(u32): Option<AccountId32>\n\t\t\tticketsCount(): u32\n\t\t`\n\t}, {\n\t\tname: \"Mmr\", rpc_path: \"mmr\",\n\t\tfuncs: `\n\t\t\tnodes(u64): Option<H256>\n\t\t\tnumberOfLeaves(): u64\n\t\t\trootHash(): H256\n\t\t`\n\t}, {\n\t\tname: \"Multisig\", rpc_path: \"multisig\",\n\t\tfuncs: `\n\t\t\tcalls([u8;32]): Option<(WrapperKeepOpaque<Call>,AccountId32,u128)>\n\t\t\tmultisigs(AccountId32, [u8;32]): Option<PalletMultisigMultisig>\n\t\t`\n\t}, {\n\t\tname: \"Offences\", rpc_path: \"offences\",\n\t\tfuncs: `\n\t\t\tconcurrentReportsIndex([u8;16], Bytes): Vec<H256>\n\t\t\treports(H256): Option<SpStakingOffenceOffenceDetails>\n\t\t\treportsByKindIndex([u8;16]): Bytes\n\t\t`\n\t}, {\n\t\tname: \"Preimage\", rpc_path: \"preimage\",\n\t\tfuncs: `\n\t\t\tpreimageFor(H256): Option<Bytes>\n\t\t\tstatusFor(H256): Option<PalletPreimageRequestStatus>\n\t\t`\n\t}, {\n\t\tname: \"Proxy\", rpc_path: \"proxy\",\n\t\tfuncs: `\n\t\t\tannouncements(AccountId32): (Vec<PalletProxyAnnouncement>,u128)\n\t\t\tproxies(AccountId32): (Vec<PalletProxyProxyDefinition>,u128)\n\t\t`\n\t}, {\n\t\tname: \"RandomnessCollectiveFlip\", rpc_path: \"randomnessCollectiveFlip\",\n\t\tfuncs: `\n\t\t\trandomMaterial(): Vec<H256>\n\t\t`\n\t}, {\n\t\tname: \"Recovery\", rpc_path: \"recovery\",\n\t\tfuncs: `\n\t\t\tactiveRecoveries(AccountId32, AccountId32): Option<PalletRecoveryActiveRecovery>\n\t\t\tproxy(AccountId32): Option<AccountId32>\n\t\t\trecoverable(AccountId32): Option<PalletRecoveryRecoveryConfig>\n\t\t`\n\t}, {\n\t\tname: \"Scheduler\", rpc_path: \"scheduler\",\n\t\tfuncs: `\n\t\t\tagenda(u32): Vec<Option<PalletSchedulerScheduledV3>>\n\t\t\tlookup(Bytes): Option<(u32,u32)>\n\t\t`\n\t}, {\n\t\tname: \"Session\", rpc_path: \"session\",\n\t\tfuncs: `\n\t\t\tcurrentIndex(): u32\n\t\t\tdisabledValidators(): Vec<u32>\n\t\t\tkeyOwner((SpCoreCryptoKeyTypeId,Bytes)): Option<AccountId32>\n\t\t\tnextKeys(AccountId32): Option<NodeRuntimeSessionKeys>\n\t\t\tqueuedChanged(): bool\n\t\t\tqueuedKeys(): Vec<(AccountId32,NodeRuntimeSessionKeys)>\n\t\t\tvalidators(): Vec<AccountId32>\n\t\t`\n\t}, {\n\t\tname: \"Society\", rpc_path: \"society\",\n\t\tfuncs: `\n\t\t\tbids(): Vec<PalletSocietyBid>\n\t\t\tcandidates(): Vec<PalletSocietyBid>\n\t\t\tdefender(): Option<AccountId32>\n\t\t\tdefenderVotes(AccountId32): Option<PalletSocietyVote>\n\t\t\tfounder(): Option<AccountId32>\n\t\t\thead(): Option<AccountId32>\n\t\t\tmaxMembers(): u32\n\t\t\tmembers(): Vec<AccountId32>\n\t\t\tpayouts(AccountId32): Vec<(u32,u128)>\n\t\t\tpot(): u128\n\t\t\trules(): Option<H256>\n\t\t\tstrikes(AccountId32): u32\n\t\t\tsuspendedCandidates(AccountId32): Option<(u128,PalletSocietyBidKind)>\n\t\t\tsuspendedMembers(AccountId32): bool\n\t\t\tvotes(AccountId32, AccountId32): Option<PalletSocietyVote>\n\t\t\tvouching(AccountId32): Option<PalletSocietyVouchingStatus>\n\t\t`\n\t}, {\n\t\tname: \"Staking\", rpc_path: \"staking\",\n\t\tfuncs: `\n\t\t\tactiveEra(): Option<PalletStakingActiveEraInfo>\n\t\t\tbonded(AccountId32): Option<AccountId32>\n\t\t\tbondedEras(): Vec<(u32,u32)>\n\t\t\tcanceledSlashPayout(): u128\n\t\t\tchillThreshold(): Option<Percent>\n\t\t\tcounterForNominators(): u32\n\t\t\tcounterForValidators(): u32\n\t\t\tcurrentEra(): Option<u32>\n\t\t\tcurrentPlannedSession(): u32\n\t\t\tearliestUnappliedSlash(): Option<u32>\n\t\t\terasRewardPoints(u32): PalletStakingEraRewardPoints\n\t\t\terasStakers(u32, AccountId32): PalletStakingExposure\n\t\t\terasStakersClipped(u32, AccountId32): PalletStakingExposure\n\t\t\terasStartSessionIndex(u32): Option<u32>\n\t\t\terasTotalStake(u32): u128\n\t\t\terasValidatorPrefs(u32, AccountId32): PalletStakingValidatorPrefs\n\t\t\terasValidatorReward(u32): Option<u128>\n\t\t\tforceEra(): PalletStakingForcing\n\t\t\thistoryDepth(): u32\n\t\t\tinvulnerables(): Vec<AccountId32>\n\t\t\tledger(AccountId32): Option<PalletStakingStakingLedger>\n\t\t\tmaxNominatorsCount(): Option<u32>\n\t\t\tmaxValidatorsCount(): Option<u32>\n\t\t\tminCommission(): Perbill\n\t\t\tminimumValidatorCount(): u32\n\t\t\tminNominatorBond(): u128\n\t\t\tminValidatorBond(): u128\n\t\t\tnominators(AccountId32): Option<PalletStakingNominations>\n\t\t\tnominatorSlashInEra(u32, AccountId32): Option<u128>\n\t\t\toffendingValidators(): Vec<(u32,bool)>\n\t\t\tpayee(AccountId32): PalletStakingRewardDestination\n\t\t\tslashingSpans(AccountId32): Option<PalletStakingSlashingSlashingSpans>\n\t\t\tslashRewardFraction(): Perbill\n\t\t\tspanSlash((AccountId32,u32)): PalletStakingSlashingSpanRecord\n\t\t\tstorageVersion(): PalletStakingReleases\n\t\t\tunappliedSlashes(u32): Vec<PalletStakingUnappliedSlash>\n\t\t\tvalidatorCount(): u32\n\t\t\tvalidators(AccountId32): PalletStakingValidatorPrefs\n\t\t\tvalidatorSlashInEra(u32, AccountId32): Option<(Perbill,u128)>\n\t\t`\n\t}, {\n\t\tname: \"Substrate\", rpc_path: \"substrate\",\n\t\tfuncs: `\n\t\t\tchangesTrieConfig(): u32\n\t\t\tchildStorageKeyPrefix(): u32\n\t\t\tcode(): Bytes\n\t\t\textrinsicIndex(): u32\n\t\t\theapPages(): u64\n\t\t`\n\t}, {\n\t\tname: \"Sudo\", rpc_path: \"sudo\",\n\t\tfuncs: `\n\t\t\tkey(): Option<AccountId32>\n\t\t`\n\t}, {\n\t\tname: \"System\", rpc_path: \"system\",\n\t\tfuncs: `\n\t\t\taccount(AccountId32): FrameSystemAccountInfo\n\t\t\tallExtrinsicsLen(): Option<u32>\n\t\t\tblockHash(u32): H256\n\t\t\tblockWeight(): FrameSupportWeightsPerDispatchClassU64\n\t\t\tdigest(): SpRuntimeDigest\n\t\t\teventCount(): u32\n\t\t\tevents(): Vec<FrameSystemEventRecord>\n\t\t\teventTopics(H256): Vec<(u32,u32)>\n\t\t\texecutionPhase(): Option<FrameSystemPhase>\n\t\t\textrinsicCount(): Option<u32>\n\t\t\textrinsicData(u32): Bytes\n\t\t\tlastRuntimeUpgrade(): Option<FrameSystemLastRuntimeUpgradeInfo>\n\t\t\tnumber(): u32\n\t\t\tparentHash(): H256\n\t\t\tupgradedToTripleRefCount(): bool\n\t\t\tupgradedToU32RefCount(): bool\n\t\t`\n\t}, {\n\t\tname: \"TechnicalCommittee\", rpc_path: \"technicalCommittee\",\n\t\tfuncs: `\n\t\t\tmembers(): Vec<AccountId32>\n\t\t\tprime(): Option<AccountId32>\n\t\t\tproposalCount(): u32\n\t\t\tproposalOf(H256): Option<Call>\n\t\t\tproposals(): Vec<H256>\n\t\t\tvoting(H256): Option<PalletCollectiveVotes>\n\t\t`\n\t}, {\n\t\tname: \"TechnicalMembership\", rpc_path: \"technicalMembership\",\n\t\tfuncs: `\n\t\t\tmembers(): Vec<AccountId32>\n\t\t\tprime(): Option<AccountId32>\n\t\t`\n\t}, {\n\t\tname: \"Timestamp\", rpc_path: \"timestamp\",\n\t\tfuncs: `\n\t\t\tdidUpdate(): bool\n\t\t\tnow(): u64\n\t\t`\n\t}, {\n\t\tname: \"Tips\", rpc_path: \"tips\",\n\t\tfuncs: `\n\t\t\treasons(H256): Option<Bytes>\n\t\t\ttips(H256): Option<PalletTipsOpenTip>\n\t\t`\n\t}, {\n\t\tname: \"TransactionPayment\", rpc_path: \"transactionPayment\",\n\t\tfuncs: `\n\t\t\tnextFeeMultiplier(): u128\n\t\t\tstorageVersion(): PalletTransactionPaymentReleases\n\t\t`\n\t}, {\n\t\tname: \"TransactionStorage\", rpc_path: \"transactionStorage\",\n\t\tfuncs: `\n\t\t\tblockTransactions(): Vec<PalletTransactionStorageTransactionInfo>\n\t\t\tbyteFee(): Option<u128>\n\t\t\tchunkCount(u32): u32\n\t\t\tentryFee(): Option<u128>\n\t\t\tmaxBlockTransactions(): u32\n\t\t\tmaxTransactionSize(): u32\n\t\t\tproofChecked(): bool\n\t\t\tstoragePeriod(): u32\n\t\t\ttransactions(u32): Option<Vec<PalletTransactionStorageTransactionInfo>>\n\t\t`\n\t}, {\n\t\tname: \"Treasury\", rpc_path: \"treasury\",\n\t\tfuncs: `\n\t\t\tapprovals(): Vec<u32>\n\t\t\tproposalCount(): u32\n\t\t\tproposals(u32): Option<PalletTreasuryProposal>\n\t\t`\n\t}, {\n\t\tname: \"Uniques\", rpc_path: \"uniques\",\n\t\tfuncs: `\n\t\t\taccount(AccountId32, u32, u32): Option<Null>\n\t\t\tasset(u32, u32): Option<PalletUniquesInstanceDetails>\n\t\t\tattribute(u32, Option<u32>, Bytes): Option<(Bytes,u128)>\n\t\t\tclass(u32): Option<PalletUniquesClassDetails>\n\t\t\tclassAccount(AccountId32, u32): Option<Null>\n\t\t\tclassMetadataOf(u32): Option<PalletUniquesClassMetadata>\n\t\t\tinstanceMetadataOf(u32, u32): Option<PalletUniquesInstanceMetadata>\n\t\t`\n\t}, {\n\t\tname: \"Vesting\", rpc_path: \"vesting\",\n\t\tfuncs: `\n\t\t\tstorageVersion(): PalletVestingReleases\n\t\t\tvesting(AccountId32): Option<Vec<PalletVestingVestingInfo>>\n\t\t`\n\t}\n]);","/**\n * import { Context, Transaction, Signer } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n */\n\n/**\n * Combine transactions into one transaction to be executed in batch\n * @blackprint node\n * @summary Combine multiple transaction\n */\nBlackprint.registerNode(\"Polkadot.js/Transaction/Batch\",\nclass BatchNode extends Blackprint.Node {\n\t// Input port\n\tstatic input = {\n\t\t/** Multiple unsigned transactions */\n\t\tTxn: Blackprint.Port.ArrayOf(Transaction),\n\t};\n\n\t// Output port\n\tstatic output = {\n\t\t/** One unsigned transaction */\n\t\tTxn: Transaction,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // use default interface\n\t\tiface.title = \"Batch Transaction\";\n\t\tthis._toast = new NodeToast(iface);\n\n\t\t// Manually call 'update' when any cable from input port was disconnected\n\t\tthis.iface.on('cable.disconnect', Context.EventSlot, ({ port })=> {\n\t\t\tif(port.source === 'input') this.update();\n\t\t});\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet toast = this._toast;\n\n\t\tif(Input.Txn.length === 0) return toast.warn(\"Txn is required\");\n\t\ttoast.clear();\n\n\t\tlet api = Input.Txn[0].api;\n\t\tif(api.tx.utility?.batchAll == null)\n\t\t\treturn this._toast.error(\"The network doesn't support this feature\");\n\n\t\t// batchAll: The whole transaction will rollback and fail if any of the calls was failed.\n\t\tlet txn = api.tx.utility.batchAll(Input.Txn.map(val => val.txn));\n\n\t\tOutput.Txn = new Transaction(txn, api, true);\n\t}\n});","/**\n * import { Context, Transaction, Signer } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n */\n\n/**\n * Retrieve a payment info from an signed/unsigned transaction\n * @blackprint node\n * @summary Get transaction fee\n */\nBlackprint.registerNode(\"Polkadot.js/Transaction/PaymentInfo\",\nclass PaymentInfoNode extends Blackprint.Node {\n\t// Input port\n\tstatic input = {\n\t\t/** Sender's address */\n\t\tSender: String,\n\t\t/** Signed/unsigned transaction */\n\t\tTxn: Transaction,\n\t};\n\n\t// Output port\n\tstatic output = {\n\t\t/** Raw status response, right click to split the data */\n\t\tInfo: Blackprint.Port.StructOf(Object, {\n\t\t\t/** Fee that need to be paid for executing the transaction */\n\t\t\tFee: {type: Number, handle: v => +v.partialFee},\n\t\t\t/** Transaction weight */\n\t\t\tWeight: {type: Number, handle: v => +v.weight},\n\t\t}),\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // use default interface\n\t\tiface.title = \"Payment Info\";\n\t\tthis._toast = new NodeToast(iface);\n\n\t\t// Manually call 'update' when any cable from input port was disconnected\n\t\tthis.iface.on('cable.disconnect', Context.EventSlot, ({ port })=> {\n\t\t\tif(port.source === 'input') this.update();\n\t\t});\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tasync update(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet toast = this._toast;\n\n\t\tif(!Input.Sender) return toast.warn(\"Sender address is required\");\n\t\tif(!Input.Txn) return toast.warn(\"Txn is required\");\n\t\ttoast.clear();\n\n\t\tif(Input.Txn.api.rpc?.payment?.queryInfo == null)\n\t\t\treturn this._toast.error(\"The network doesn't support this feature\");\n\n\t\tlet info;\n\t\ttry{\n\t\t\ttoast.warn(\"Waiting responses\");\n\t\t\tinfo = await Input.Txn.txn.paymentInfo(Input.Sender);\n\t\t} catch(e) {\n\t\t\ttoast.clear();\n\n\t\t\tif(e.message.includes(\"32601: Method not found\"))\n\t\t\t\ttoast.error(\"The network doesn't support this feature\");\n\t\t\telse toast.error(e.message);\n\n\t\t\tthrow e;\n\t\t}\n\n\t\ttoast.clear();\n\t\tOutput.Info = info;\n\t}\n});","/**\n * import { Context, Transaction, Signer } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n */\n\n/**\n * Create an unsigned transaction\n * You may need to sign and send this to the RPC to be executed\n * @blackprint node\n * @summary Sign and submit transaction\n */\nBlackprint.registerNode(\"Polkadot.js/Transaction/Send\",\nclass TransferSendNode extends Blackprint.Node {\n\t// Input port\n\tstatic input = {\n\t\t/** Submit the transaction request into the parachain */\n\t\tSubmit: Blackprint.Port.Trigger(function({ iface }){\n\t\t\tiface.node.submit();\n\t\t}),\n\t\t/** Can be from extension or generated keypair (with mnemonic/seed) */\n\t\tSigner: Signer,\n\t\t/** Unsigned transaction that will be submitted */\n\t\tTxn: Transaction,\n\t\t/** Optional, in case if user want to override the nonce */\n\t\tNonce: Number,\n\t};\n\n\t// Output port\n\tstatic output = {\n\t\t/** Callback when the transaction was finalized and success */\n\t\tSuccess: Blackprint.Types.Trigger,\n\t\t/** Callback when the transaction was finalized and failed */\n\t\tFailed: Blackprint.Types.Trigger,\n\t\t/** Raw status from Polkadot.js */\n\t\tStatus: Object,\n\t\t/** This will have value after Ready status (before Broadcast) */\n\t\tTxHash: Uint8Array\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // use default interface\n\t\tiface.title = \"Send Transaction\";\n\t\tlet toast = this._toast = new NodeToast(iface);\n\n\t\t// After you submit the transaction\n\t\t// This function will be called when this node received response from the network\n\t\tthis._onStatus = ev => {\n\t\t\tlet { Input, Output } = this.ref;\n\t\t\tif(ev.status.type === \"Finalized\"){\n\t\t\t\ttoast.clear();\n\t\t\t\ttoast.success(ev.status.type);\n\n\t\t\t\t// Display error on finalized transaction for browser UI only\n\t\t\t\tif(Blackprint.Environment.isBrowser){\n\t\t\t\t\t// This will only exist if the events contains \"ExtrinsicFailed\" event\n\t\t\t\t\tlet error = ev.dispatchError;\n\n\t\t\t\t\t// Check error for batch transactions\n\t\t\t\t\tif(error == null && Input.Txn.length === 1) {\n\t\t\t\t\t\tlet api = Input.Txn.api;\n\n\t\t\t\t\t\t// Search for \"BatchInterrupted\" event\n\t\t\t\t\t\tfor(let i=0, n=ev.events.length; i < n; i++){\n\t\t\t\t\t\t\tif(api.events.utility.BatchInterrupted.is(ev.events[i].event)){\n\t\t\t\t\t\t\t\terror = ev.events[i].event.data[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Skip if no error\n\t\t\t\t\tif(error != null) {\n\t\t\t\t\t\tif(error.isModule){\n\t\t\t\t\t\t\tlet api = Input.Txn.api;\n\t\n\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\tlet decoded = api.registry.findMetaError(error.asModule);\n\t\t\t\t\t\t\t\tlet { docs, method, section } = decoded;\n\t\t\n\t\t\t\t\t\t\t\ttoast.error(docs.join(' ') || `${section}: ${method}`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch{\n\t\t\t\t\t\t\t\tconsole.log(\"Txn error data:\", error.toString());\n\t\t\t\t\t\t\t\ttoast.error(\"Transaction failed\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tconsole.log(\"Txn error data:\", error.toString());\n\t\t\t\t\t\t\ttoast.error(\"Transaction failed\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(ev.dispatchError != null)\n\t\t\t\t\tOutput.Failed();\n\t\t\t\telse Output.Success();\n\t\t\t}\n\t\t\telse toast.warn(ev.status.type);\n\n\t\t\tif(Output.TxHash == null && ev.txHash != null)\n\t\t\t\tOutput.TxHash = ev.txHash;\n\n\t\t\t// Store the raw response to the output port\n\t\t\tOutput.Status = ev;\n\t\t}\n\n\t\t// Manually call 'update' when any cable from input port was disconnected\n\t\tthis.iface.on('cable.disconnect', Context.EventSlot, ({ port })=> {\n\t\t\tif(port.source === 'input') this.update();\n\t\t});\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tupdate(){\n\t\tlet { Input } = this.ref; // Shortcut\n\t\tlet toast = this._toast;\n\n\t\tif(!Input.Signer) return toast.warn(\"Signer is required\");\n\t\tif(!Input.Txn) return toast.warn(\"Txn is required\");\n\t\ttoast.clear();\n\t}\n\n\t// Called from \"Submit\" input port (Blackprint.Port.Trigger)\n\tasync submit(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet toast = this._toast;\n\n\t\tif(!Input.Txn || !Input.Signer)\n\t\t\treturn toast.error(\"Some input port need to have a value\");\n\n\t\ttoast.clear();\n\t\tlet ref = Input.Signer;\n\n\t\tOutput.TxHash = null; // Remove old hash value if exist in the port\n\t\tOutput.Status = null;\n\n\t\tlet txn = Input.Txn.txn; // Obtain transaction reference\n\t\tlet options = {};\n\n\t\t// Override the nonce if user has inputted a value\n\t\tif(!!Input.Nonce && Input.Nonce !== 0)\n\t\t\toptions.nonce = Input.Nonce;\n\n\t\ttoast.warn(\"Sending request\");\n\n\t\ttry{\n\t\t\tif(!ref.isPair){  // Using browser's extension\n\t\t\t\toptions.signer = ref.signer;\n\t\t\t\tawait txn.signAndSend(ref.address, options, this._onStatus);\n\t\t\t}\n\t\t\telse await txn.signAndSend(ref.signer, options, this._onStatus);\n\t\t} catch(e) {\n\t\t\ttoast.clear();\n\n\t\t\tif(e.message.includes(\"32601: Method not found\"))\n\t\t\t\ttoast.error(\"The network doesn't support this feature\");\n\t\t\telse toast.error(e.message);\n\n\t\t\tOutput.Failed();\n\t\t}\n\t}\n});","/**\n * import { Context, Transaction } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotApi } = window;\n */\n\n/**\n * Transfer account's balance to another account (account = wallet)\n * The unsigned transaction need to be signed by the sender wallet\n * Value must be integer, different parachain may have different decimals\n * @blackprint node\n * @summary Transfer balance to an address\n */\nBlackprint.registerNode(\"Polkadot.js/Account/Transfer/Balance\",\nclass TransferNode extends Blackprint.Node {\n\t// Input port\n\tstatic input = {\n\t\t/** Polkadot's API connection */\n\t\tAPI: polkadotApi.ApiPromise,\n\t\t/** Target wallet/account address in base58 format */\n\t\tAddress: String,\n\t\t/** Amount of transfer (must be positive and lower than 2^53 - 1) */\n\t\tValue: Number,\n\t};\n\n\t// Output port\n\tstatic output = {\n\t\t/**\n\t\t * Unsigned transaction\n\t\t * \n\t\t * this must be signed by the sender before being\n\t\t * submitted to blockchain to be executed\n\t\t */\n\t\tTxn: Transaction,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // use default interface\n\t\tiface.title = \"Transfer Balance\";\n\t\tthis._toast = new NodeToast(iface);\n\n\t\t// Manually call 'update' when any cable from input port was disconnected\n\t\tthis.iface.on('cable.disconnect', Context.EventSlot, ({ port })=> {\n\t\t\tif(port.source === 'input') this.update();\n\t\t});\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet toast = this._toast;\n\n\t\tif(!Input.API) return toast.warn(\"API is required\");\n\t\tif(!Input.Address) return toast.warn(\"Address is required\");\n\n\t\t// Allow transfer for 0 value\n\t\tif(Input.Value == null) return toast.warn(\"Value is required\");\n\n\t\tlet value = Input.Value;\n\n\t\tif(value < 0)\n\t\t\treturn toast.warn(\"Value must be positive integer\");\n\n\t\tif(!Number.isInteger(value))\n\t\t\treturn toast.warn(\"Value must be integer, but found floating number: \"+value);\n\n\t\tif(value > Number.MAX_SAFE_INTEGER)\n\t\t\treturn toast.warn(\"Value must be lower than 2^53 - 1\");\n\n\t\ttoast.clear();\n\n\t\tlet txn = Input.API.tx.balances.transfer(Input.Address, value);\n\t\tOutput.Txn = new Transaction(txn, Input.API);\n\t}\n});","/**\n * import { Context } from \"../_init.js\";\n * { polkadotKeyring } = window\n */\n\n\n/**\n * Convert the wallet address into chain id's address\n * @blackprint node\n */\nBlackprint.registerNode(\"Polkadot.js/Convert/Address To/Address\",\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\t/** Wallet/account address in base58 format */\n\t\tAddress: String,\n\t\t/** Chain id */\n\t\tChainId: Number,\n\t};\n\tstatic output = {\n\t\t/** Wallet/account address in base58 format */\n\t\tAddress: String,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Address to Address\";\n\n\t\tthis._toast = new NodeToast(this.iface);\n\n\t\t// Manually call 'update' when any cable from input port was disconnected\n\t\tthis.iface.on('cable.disconnect', Context.EventSlot, ({ port })=> {\n\t\t\tif(port.source === 'input') this.update();\n\t\t});\n\t}\n\n\t_fail(msg){\n\t\tthis.output.Address = null;\n\t\tthis._toast.warn(msg);\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\n\t\tif(!Input.Address) return this._fail('Address is required');\n\n\t\tthis._toast.clear();\n\t\tOutput.Address = polkadotKeyring.encodeAddress(Input.Address, Input.ChainId);\n\t}\n});","/**\n * import { Context } from \"../_init.js\";\n * { polkadotKeyring } = window\n */\n\n\n/**\n * Convert the wallet address (in base58 format) into bytes\n * @blackprint node\n */\nBlackprint.registerNode(\"Polkadot.js/Convert/Address To/Uint8Array\",\nclass RandomSeedNode extends Blackprint.Node {\n\tstatic output = {\n\t\t/** Address's bytes */\n\t\tBytes: Uint8Array,\n\t};\n\tstatic input = {\n\t\t/** Wallet/account address in base58 format */\n\t\tAddress: String,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Address to Uint8Array\";\n\n\t\tthis._toast = new NodeToast(this.iface);\n\n\t\t// Manually call 'update' when any cable from input port was disconnected\n\t\tthis.iface.on('cable.disconnect', Context.EventSlot, ({ port })=> {\n\t\t\tif(port.source === 'input') this.update();\n\t\t});\n\t}\n\n\t_fail(msg){\n\t\tthis.output.Bytes = null;\n\t\tthis._toast.warn(msg);\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\n\t\tif(!Input.Address) return this._fail('Address is required');\n\n\t\tthis._toast.clear();\n\t\tOutput.Bytes = polkadotKeyring.decodeAddress(Input.Address);\n\t}\n});","/**\n * import { Context } from \"../_init.js\";\n * { polkadotUtil } = window\n */\n\n\n/**\n * Convert any string into bytes\n * @blackprint node\n */\nBlackprint.registerNode(\"Polkadot.js/Convert/String To/Uint8Array\",\nclass RandomSeedNode extends Blackprint.Node {\n\tstatic input = {In: String};\n\tstatic output = {Out: Uint8Array};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"String to Uint8Array\";\n\t}\n\n\t// Event listener can be registered after init\n\tinit(){\n\t\t// Clear the output port when the input cable was disconnected\n\t\tthis.iface.input.In.on('disconnect', Context.EventSlot, ()=> {\n\t\t\tthis.output.Out = null;\n\t\t});\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tOutput.Out = polkadotUtil.stringToU8a(Input.In);\n\t}\n});","/**\n * import { Context } from \"../_init.js\";\n * { polkadotUtil } = window\n */\n\n\n/**\n * Convert bytes into hex string\n * @blackprint node\n */\nBlackprint.registerNode(\"Polkadot.js/Convert/Uint8Array To/Hex\",\nclass RandomSeedNode extends Blackprint.Node {\n\tstatic input = {In: Uint8Array};\n\tstatic output = {Out: String};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Uint8Array to Hex\";\n\t}\n\n\t// Event listener can be registered after init\n\tinit(){\n\t\t// Clear the output port when the input cable was disconnected\n\t\tthis.iface.input.In.on('disconnect', Context.EventSlot, ()=> {\n\t\t\tthis.output.Out = null;\n\t\t});\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tOutput.Out = polkadotUtil.u8aToHex(Input.In);\n\t}\n});","/**\n * import { Context } from \"../_init.js\";\n * { polkadotUtil } = window\n */\n\n\n/**\n * Convert bytes into string\n * @blackprint node\n */\nBlackprint.registerNode(\"Polkadot.js/Convert/Uint8Array To/String\",\nclass RandomSeedNode extends Blackprint.Node {\n\tstatic input = {In: Uint8Array};\n\tstatic output = {Out: String};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Uint8Array to String\";\n\t}\n\n\t// Event listener can be registered after init\n\tinit(){\n\t\t// Clear the output port when the input cable was disconnected\n\t\tthis.iface.input.In.on('disconnect', Context.EventSlot, ()=> {\n\t\t\tthis.output.Out = null;\n\t\t});\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tOutput.Out = polkadotUtil.u8aToString(Input.In);\n\t}\n});","/**\n * import { Context } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotApi } = window\n */\n\n/**\n * Listen to balance changes of an account (wallet) through WebSocket RPC\n * @blackprint node\n * @summary Listen for balance changes\n */\nBlackprint.registerNode(\"Polkadot.js/Events/Account/Balance\",\nclass AccountBalanceNode extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\t// Input port\n\tstatic input = {\n\t\t/** Polkadot.js's WebSocket API */\n\t\tAPI: polkadotApi.ApiPromise,\n\t\t/** Wallet/account address in base58 format */\n\t\tAddress: String,\n\t};\n\n\t// Output port\n\tstatic output = {\n\t\t/** Raw event data, right click to split the data */\n\t\tData: Blackprint.Port.StructOf(Object, {\n\t\t\t/** Amount of account balance that transferrable */\n\t\t\tFree: {type: Number, handle: v => +v.data.free},\n\t\t\t/** Reserved balance */\n\t\t\tReserved: {type: Number, handle: v => +v.data.reserved},\n\t\t\t/** Frozen balances */\n\t\t\tMiscFrozen: {type: Number, handle: v => +v.data.miscFrozen},\n\t\t\t/** Frozen fee */\n\t\t\tFeeFrozen: {type: Number, handle: v => +v.data.feeFrozen},\n\t\t}),\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // Use default interface\n\t\tiface.title = \"Account Balance Event\";\n\t\tiface.type = 'event';\n\n\t\tthis._toast = new NodeToast(iface);\n\n\t\t// This will be replaced if subcribing to an event, default: no operation\n\t\tthis.unsubscribe = ()=> {};\n\t}\n\n\t// This will be called by the engine after the node has been loaded\n\t// and other data like cable connection has been connected/added\n\tinit(){\n\t\tlet { IInput } = this.ref; // Shortcut\n\n\t\t// Listen if the cable was disconnected from the input port\n\t\tIInput.API.on('disconnect', Context.EventSlot, ()=> {\n\t\t\tthis.unsubscribe();\n\t\t});\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tasync update(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\n\t\t// If this node is already subscribing to blocks event, let's unsubscribe it\n\t\tthis.unsubscribe();\n\n\t\tlet api = Input.API;\n\t\tif(!api) return;\n\n\t\tif(!api.hasSubscriptions)\n\t\t\treturn this._toast.error(\"Please use WebSocket for using this feature\");\n\n\t\tthis._toast.warn(\"Subscribing...\");\n\n\t\ttry {\n\t\t\tthis.unsubscribe = await api.query.system.account(Input.Address, ev => {\n\t\t\t\tOutput.Data = ev;\n\t\t\t});\n\t\t} catch(e) {\n\t\t\tthis._toast.clear();\n\t\t\tthis._toast.error(e.message);\n\t\t}\n\n\t\t// Clear the toast\n\t\tthis._toast.clear();\n\t\tthis._toast.success(\"Subscribed!\");\n\t}\n\n\t// This will be called by the engine when this node is deleted\n\tdestroy(){\n\t\tif(this.unsubscribe) this.unsubscribe();\n\t}\n});","/**\n * import { Context, Signer } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotExtensionDapp } = window\n */\n\n\n/**\n * Before using this node,\n * You must request for access into browser extension first with\n * Polkadot.js/Connection/Extension\n * @blackprint node\n * @summary Get wallet signer from browser extension\n */\nBlackprint.registerNode(\"Polkadot.js/Extension/Get/Signer\",\nclass SignerNode extends Blackprint.Node {\n\t// Node's input/output port\n\tstatic input = {\n\t\t/** Wallet/account address in base58 format */\n\t\tAddress: String,\n\t};\n\tstatic output = {\n\t\t/** This can be used for signing transaction */\n\t\tSigner: Signer,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // use empty interface\n\t\tiface.title = \"Signer\";\n\n\t\tthis._toast = new NodeToast(this.iface);\n\n\t\t// Manually call 'update' when any cable from input port was disconnected\n\t\tthis.iface.on('cable.disconnect', Context.EventSlot, ({ port })=> {\n\t\t\tif(port.source === 'input') this.update();\n\t\t});\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tasync update(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet toast = this._toast;\n\n\t\tif(!Input.Address)\n\t\t\treturn toast.warn(\"Address is required\");\n\n\t\t// Wait for permission\n\t\tif(Context._extensionEnabled !== true){\n\t\t\ttoast.warn(\"No access to browser extension\");\n\t\t\tawait Context._extensionEnabled;\n\t\t}\n\n\t\t// Clear any toast if exist\n\t\ttoast.clear();\n\n\t\t// Get the Web3 signer object\n\t\ttry{\n\t\t\tvar obj = await polkadotExtensionDapp.web3FromAddress(Input.Address);\n\t\t} catch(e) {\n\t\t\treturn toast.warn(e.message);\n\t\t}\n\n\t\t// Wrap it as Signer type and set it as output\n\t\tOutput.Signer = new Signer(false, Input.Address, obj.signer);\n\t}\n});","/**\n * import { Context, Signer } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotApi, polkadotUtilCrypto } = window\n */\n\n\n/**\n * Create a keypair and the signer from seed or mnemonic\n * @blackprint node\n */\nBlackprint.registerNode(\"Polkadot.js/Keyring/Create/Keypair\",\nclass KeypairNode extends Blackprint.Node {\n\t// Node's input/output port\n\tstatic input = {\n\t\t/**\n\t\t * Keypair to store the keyring\n\t\t * You can leave this unconnected to use internal keyring\n\t\t */\n\t\tKeyring: Blackprint.Port.Default(polkadotApi.Keyring, Context._internalKeyring),\n\t\t/** Hex string, or 32 bytes Uint8Array */\n\t\tSeed: Blackprint.Port.Union([String, Uint8Array]), \n\t\t/** 12 or 24 words */\n\t\tMnemonic: String, \n\t};\n\tstatic output = {\n\t\t/** Generated key pair */\n\t\tKeypair: Object,\n\t\t/** Wallet/account address in base58 format */\n\t\tAddress: String,\n\t\t/** This can be used for signing transaction */\n\t\tSigner: Signer,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // use empty interface\n\t\tiface.title = \"Create Keypair\";\n\t\tiface.description = \"Using internal keyring\";\n\n\t\tthis._toast = new NodeToast(this.iface);\n\n\t\t// Manually call 'update' when any cable from input port was disconnected\n\t\tthis.iface.on('cable.disconnect', Context.EventSlot, ({ port })=> {\n\t\t\tif(port.source === 'input') this.update();\n\t\t});\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tupdate(){\n\t\tlet { Input, Output, IInput } = this.ref; // Shortcut\n\t\tlet toast = this._toast;\n\n\t\tif(Input.Keyring === Context._internalKeyring)\n\t\t\tthis.iface.description = \"Using internal keyring: \"+Input.Keyring.type;\n\t\telse this.iface.description = \"Using connected keyring: \"+Input.Keyring.type;\n\n\t\t// Obtain last keyring and save the new keyring to this node object\n\t\tlet oldKeyring = this._keyring;\n\t\tthis._keyring = Input.Keyring;\n\n\t\t// If the input port was changed, remove keypair from the old keyring\n\t\tif(Output.Keypair != null){\n\t\t\toldKeyring.removePair(Output.Keypair.address);\n\t\t\tOutput.Keypair = null;\n\t\t}\n\n\t\tlet { Keyring, Seed, Mnemonic } = Input;\n\n\t\t// We only need one seed/mnemonic, let's disconnect the other connection\n\t\tif(Mnemonic && !!Seed){\n\t\t\t// this.update() will be called again after the cable was disconnected\n\n\t\t\tif(this._mnemonic === false && IInput.Seed.cables.length !== 0)\n\t\t\t\treturn IInput.Seed.disconnectAll();\n\n\t\t\tIInput.Mnemonic.disconnectAll();\n\t\t\treturn;\n\t\t}\n\n\t\tif(Mnemonic) {\n\t\t\tif(!polkadotUtilCrypto.mnemonicValidate(Mnemonic))\n\t\t\t\treturn toast.warn(\"Invalid mnemonic, it must be 12 or 24 words\");\n\n\t\t\tOutput.Keypair = Keyring.addFromMnemonic(Mnemonic);\n\t\t\tthis._mnemonic = true;\n\t\t}\n\t\telse if(Seed != null) {\n\t\t\t// The seed must be 32 bytes\n\t\t\tif(Seed.byteLength !== 32)\n\t\t\t\treturn toast.warn(\"Seed must be 32 bytes\");\n\n\t\t\tOutput.Keypair = Keyring.addFromSeed(Seed);\n\t\t\tthis._mnemonic = false;\n\t\t}\n\t\telse {\n\t\t\tOutput.Keypair = null;\n\t\t\tOutput.Address = null;\n\t\t\tOutput.Signer = null;\n\t\t\t// Output.PublicKey = null;\n\t\t\tthis._mnemonic = false;\n\t\t\treturn toast.warn(\"Seed or Mnemonic is required\");\n\t\t}\n\n\t\ttoast.clear();\n\t\tlet pair = Output.Keypair;\n\n\t\t// Wrap the signer and put it to the output port\n\t\tOutput.Signer = new Signer(true, pair.address, pair);\n\t\tOutput.Address = pair.address;\n\t\t// Output.PublicKey = pair.publicKey;\n\t}\n});","/**\n * import { Context } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotApi } = window\n */\n\n\n/**\n * Create a keyring to store keypairs\n * @blackprint node\n * @summary Collection of keypairs\n */\nBlackprint.registerNode(\"Polkadot.js/Keyring/Create/Keyring\",\nclass KeyringNode extends Blackprint.Node {\n\t// Input port\n\tstatic input = {\n\t\t/** This must be one of ed25519, sr25519, ethereum, or ecdsa */\n\t\tKeyType: Blackprint.Port.Default(String, 'ed25519'),\n\t};\n\n\t// Output port\n\tstatic output = {\n\t\t/** Polkadot.js's Keyring object */\n\t\tKeyring: polkadotApi.Keyring,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // use empty interface\n\t\tiface.title = \"Keyring\";\n\n\t\tthis._toast = new NodeToast(this.iface);\n\t}\n\n\t// This will be called by the engine once the node has been loaded\n\t// We will use event listener instead 'update()'\n\timported(){\n\t\tlet { Input, Output, IInput } = this.ref; // Shortcut\n\n\t\t// Create initial Keyring\n\t\tthis.currentKeyType = Input.KeyType;\n\t\tOutput.Keyring = new polkadotApi.Keyring({\n\t\t\ttype: Input.KeyType, // default to ed25519\n\t\t\tss58Format: 0, // To use different format, Polkadot.js/Convert/Address To/Address is recommended\n\t\t});\n\n\t\t// Manually call 'update' when any cable from input port was disconnected\n\t\tIInput.KeyType.on('disconnect', Context.EventSlot, () => this.update());\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet keyType = Input.KeyType.toLowerCase();\n\t\tlet toast = this._toast;\n\n\t\t// Update only if keytype was changed (ed25519 <~> sr25519)\n\t\tif(this.currentKeyType === keyType)\n\t\t\treturn toast.clear();\n\n\t\tif(keyType !== 'ed25519'\n\t\t\t&& keyType !== 'sr25519'\n\t\t\t&& keyType !== 'ethereum'\n\t\t\t&& keyType !== 'ecdsa'){\n\t\t\treturn toast.warn(\"Invalid KeyType, it must be ed25519, sr25519, ethereum, or ecdsa\");\n\t\t}\n\n\t\t// Recreate Keyring\n\t\tOutput.Keyring = new polkadotApi.Keyring({\n\t\t\ttype: keyType, // default to ed25519\n\t\t\tss58Format: 0, // To use different format, Polkadot.js/Convert/Address To/Address is recommended\n\t\t});\n\n\t\tthis.currentKeyType = keyType;\n\t\ttoast.clear();\n\t}\n});","/**\n * { polkadotUtilCrypto } = window\n */\n\n\n/**\n * Create a random mnemonic that can be used for key pair or generating a wallet\n * @blackprint node\n * @summary Generate random mnemonic\n */\nBlackprint.registerNode(\"Polkadot.js/Keyring/Create/Mnemonic\",\nclass RandomSeedNode extends Blackprint.Node {\n\t// Input port\n\t// static input = { Length: Blackprint.Port.Default(Number, 12) };\n\n\t// Output port\n\tstatic output = {\n\t\t/** Random mnemonic */\n\t\tText: String,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // use empty interface\n\t\tiface.title = \"Create Mnemonic\";\n\t}\n\n\t// This will be called by the engine once the node has been loaded\n\timported(){\n\t\t// this.update();\n\t\tthis.output.Text = polkadotUtilCrypto.mnemonicGenerate(12);\n\t}\n});","/**\n * import { Context } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotUtil } = window\n */\n\n\n/**\n * Create a random seed that can be used for key pair or generating a wallet\n * @blackprint node\n * @summary Generate random seed\n */\nBlackprint.registerNode(\"Polkadot.js/Keyring/Create/Seed\",\nclass RandomSeedNode extends Blackprint.Node {\n\t// Output port\n\tstatic output = {\n\t\t/** Random seed */\n\t\tSeed: Uint8Array,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // use empty interface\n\t\tiface.title = \"Random Seed\";\n\t}\n\n\t// This will be called by the engine once the node has been loaded\n\timported(){\n\t\tthis.output.Seed = polkadotUtilCrypto.randomAsU8a(32);\n\t}\n});"]}