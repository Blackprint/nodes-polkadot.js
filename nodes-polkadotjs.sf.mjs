!async function(e,t){"use strict";async function o(e){return"undefined"!=typeof sf&&void 0!==sf.loader?await sf.loader.mjs(e):Promise.all(e.map((e=>import(e))))}t.exports&&t.exports!==globalThis&&Object.defineProperty(t.exports,"__esModule",{value:!0}),o.task=function(){return"undefined"!=typeof sf&&void 0!==sf.loader?sf.loader.task:null},e.templates||(e.templates={});var i=sf.dom||sf.$,n=e.templates;e._sf_internal=e._sf_internal||{body_map:{},_replace(e,t){let o=i(t);return this.body_map[e]&&this.body_map[e].remove(),this.reinitViews&&this.reinitViews(o),this.body_map[e]=o},append(e,t){i(document.body).append(this._replace.apply(this,arguments))},prepend(e,t){i(document.body).prepend(this._replace.apply(this,arguments))}};await o.task();let r=await e.Blackprint.loadScope({url:import.meta.url}),s=(sf.$,await r.getContext("Polkadot.js"));n["BPIC/Polkadot.js/Connection/Extension.sf"]='<div class="node" style="transform: translate({{x}}px, {{y}}px)"><sf-template path="Blackprint/nodes/template/routes.sf"></sf-template><sf-template path="Blackprint/nodes/template/header.sf"></sf-template><div class="content"><input type="text" sf-bind="data.dAppName" placeholder="Your dApp Name"><div class="left-port"><sf-template path="Blackprint/nodes/template/input-port.sf"></sf-template></div><div class="right-port"><sf-template path="Blackprint/nodes/template/output-port.sf"></sf-template></div></div><sf-template path="Blackprint/nodes/template/other.sf"></sf-template></div>',r.Sketch.registerInterface("BPIC/Polkadot.js/Connection/Extension",s.IFace.ConnectionExtension),n["BPIC/Polkadot.js/Connection/HTTP.sf"]='<div class="node trigger" style="transform: translate({{x}}px, {{y}}px)"><sf-template path="Blackprint/nodes/template/routes.sf"></sf-template><sf-template path="Blackprint/nodes/template/header.sf"></sf-template><div class="content"><input type="text" sf-bind="data.rpcURL" placeholder="Type RPC URL here"><div class="left-port"><sf-template path="Blackprint/nodes/template/input-port.sf"></sf-template></div><div class="right-port"><sf-template path="Blackprint/nodes/template/output-port.sf"></sf-template></div></div><sf-template path="Blackprint/nodes/template/other.sf"></sf-template></div>',r.Sketch.registerInterface("BPIC/Polkadot.js/Connection/HTTP",s.IFace.ConnectionHTTP),n["BPIC/Polkadot.js/Connection/WebSocket.sf"]='<div class="node trigger" style="transform: translate({{x}}px, {{y}}px)"><sf-template path="Blackprint/nodes/template/routes.sf"></sf-template><sf-template path="Blackprint/nodes/template/header.sf"></sf-template><div class="content"><input type="text" sf-bind="data.rpcURL" placeholder="Type RPC URL here"><div class="left-port"><sf-template path="Blackprint/nodes/template/input-port.sf"></sf-template></div><div class="right-port"><sf-template path="Blackprint/nodes/template/output-port.sf"></sf-template></div></div><sf-template path="Blackprint/nodes/template/other.sf"></sf-template></div>',r.Sketch.registerInterface("BPIC/Polkadot.js/Connection/WebSocket",s.IFace.ConnectionWebSocket),r.Sketch.registerDocs({"Polkadot.js":{Constants:{Alliance:{AllyDeposit:{description:"The deposit required for submitting candidacy"},MaxAnnouncementsCount:{description:"The maximum number of announcements"},MaxMembersCount:{description:"The maximum number of members per member role. Should not exceed the sum of `MaxFounders` and `MaxFellows`"},MaxUnscrupulousItems:{description:"The maximum number of the unscrupulous items supported by the pallet"},MaxWebsiteUrlLength:{description:"The maximum length of a website URL"}},Assets:{ApprovalDeposit:{description:"The amount of funds that must be reserved when creating a new approval"},AssetAccountDeposit:{description:"The amount of funds that must be reserved for a non-provider asset account to be maintained"},AssetDeposit:{description:"The basic amount of funds that must be reserved for an asset"},MetadataDepositBase:{description:"The basic amount of funds that must be reserved when adding metadata to your asset"},MetadataDepositPerByte:{description:"The additional funds that must be reserved for the number of bytes you store in your metadata"},StringLimit:{description:"The maximum length of a name or symbol stored on-chain"}},Authorship:{UncleGenerations:{description:"The number of blocks back we should accept uncles. This means that we will deal with uncle-parents that are `UncleGenerations + 1` before `now`"}},Babe:{EpochDuration:{description:"The amount of time, in slots, that each epoch should last. NOTE: Currently it is not possible to change the epoch duration after the chain has started. Attempting to do so will brick block production"},ExpectedBlockTime:{description:"The expected average block time at which BABE should be creating blocks. Since BABE is probabilistic it is not trivial to figure out what the expected average block time should be based on the slot duration and the security parameter `c` (where `1 - c` represents the probability of a slot being empty)"},MaxAuthorities:{description:"Max number of authorities allowed"}},BagsList:{BagThresholds:{description:"The list of thresholds separating the various bags"}},Balances:{ExistentialDeposit:{description:"The minimum amount required to keep an account open"},MaxLocks:{description:"The maximum number of locks that should exist on an account. Not strictly enforced, but used for weight estimation"},MaxReserves:{description:"The maximum number of named reserves that can exist on an account"}},Bounties:{BountyDepositBase:{description:"The amount held on deposit for placing a bounty proposal"},BountyDepositPayoutDelay:{description:"The delay period for which a bounty beneficiary need to wait before claim the payout"},BountyUpdatePeriod:{description:"Bounty duration in blocks"},BountyValueMinimum:{description:"Minimum value for a bounty"},CuratorDepositMax:{description:"Maximum amount of funds that should be placed in a deposit for making a proposal"},CuratorDepositMin:{description:"Minimum amount of funds that should be placed in a deposit for making a proposal"},CuratorDepositMultiplier:{description:"The curator deposit is calculated as a percentage of the curator fee"},DataDepositPerByte:{description:"The amount held on deposit per byte within the tip report reason or bounty description"},MaximumReasonLength:{description:"Maximum acceptable reason length"}},ChildBounties:{ChildBountyValueMinimum:{description:"Minimum value for a child-bounty"},MaxActiveChildBountyCount:{description:"Maximum number of child bounties that can be added to a parent bounty"}},Contracts:{ContractAccessWeight:{description:"The weight per byte of code that is charged when loading a contract from storage"},DeletionQueueDepth:{description:"The maximum number of contracts that can be pending for deletion"},DeletionWeightLimit:{description:"The maximum amount of weight that can be consumed per block for lazy trie removal"},DepositPerByte:{description:"The amount of balance a caller has to pay for each byte of storage"},DepositPerItem:{description:"The amount of balance a caller has to pay for each storage item"},Schedule:{description:"Cost schedule and limits"}},ConvictionVoting:{MaxVotes:{description:"The maximum number of concurrent votes an account may have"},VoteLockingPeriod:{description:"The minimum period of vote locking"}},Democracy:{CooloffPeriod:{description:"Period in blocks where an external proposal may not be re-submitted after being vetoed"},EnactmentPeriod:{description:"The period between a proposal being approved and enacted"},FastTrackVotingPeriod:{description:"Minimum voting period allowed for a fast-track referendum"},InstantAllowed:{description:"Indicator for whether an emergency origin is even allowed to happen. Some chains may want to set this permanently to `false`, others may want to condition it on things such as an upgrade having happened recently"},LaunchPeriod:{description:"How often (in blocks) new public referenda are launched"},MaxProposals:{description:"The maximum number of public proposals that can exist at any time"},MaxVotes:{description:"The maximum number of votes for an account"},MinimumDeposit:{description:"The minimum amount to be used as a deposit for a public referendum proposal"},PreimageByteDeposit:{description:"The amount of balance that must be deposited per byte of preimage stored"},VoteLockingPeriod:{description:"The minimum period of vote locking"},VotingPeriod:{description:"How often (in blocks) to check for new votes"}},ElectionProviderMultiPhase:{BetterSignedThreshold:{description:'The minimum amount of improvement to the solution score that defines a solution as "better" in the Signed phase'},BetterUnsignedThreshold:{description:'The minimum amount of improvement to the solution score that defines a solution as "better" in the Unsigned phase'},MaxElectableTargets:{description:"The maximum number of electable targets to put in the snapshot"},MaxElectingVoters:{description:"The maximum number of electing voters to put in the snapshot. At the moment, snapshots are only over a single block, but once multi-block elections are introduced they will take place over multiple blocks"},MinerTxPriority:{description:"The priority of the unsigned transaction submitted in the unsigned-phase"},OffchainRepeat:{description:"The repeat threshold of the offchain worker"},SignedDepositBase:{description:"Base deposit for a signed solution"},SignedDepositByte:{description:"Per-byte deposit for a signed solution"},SignedDepositWeight:{description:"Per-weight deposit for a signed solution"},SignedMaxRefunds:{description:"The maximum amount of unchecked solutions to refund the call fee for"},SignedMaxSubmissions:{description:"Maximum number of signed submissions that can be queued"},SignedMaxWeight:{description:"Maximum weight of a signed solution"},SignedPhase:{description:"Duration of the signed phase"},SignedRewardBase:{description:"Base reward for a signed solution"},UnsignedPhase:{description:"Duration of the unsigned phase"}},Elections:{CandidacyBond:{description:"How much should be locked up in order to submit one's candidacy"},DesiredMembers:{description:"Number of members to elect"},DesiredRunnersUp:{description:"Number of runners_up to keep"},PalletId:{description:"Identifier for the elections-phragmen pallet's lock"},TermDuration:{description:"How long each seat is kept. This defines the next block number at which an election round will happen. If set to zero, no elections are ever triggered and the module will be in passive mode"},VotingBondBase:{description:"Base deposit associated with voting"},VotingBondFactor:{description:"The amount of bond that need to be locked for each vote (32 bytes)"}},Gilt:{FifoQueueLen:{description:"Portion of the queue which is free from ordering and just a FIFO"},IntakePeriod:{description:"The number of blocks between consecutive attempts to issue more gilts in an effort to get to the target amount to be frozen"},MaxIntakeBids:{description:"The maximum amount of bids that can be turned into issued gilts each block. A larger value here means less of the block available for transactions should there be a glut of bids to make into gilts to reach the target"},MaxQueueLen:{description:"Maximum number of items that may be in each duration queue"},MinFreeze:{description:"The minimum amount of funds that may be offered to freeze for a gilt. Note that this does not actually limit the amount which may be frozen in a gilt since gilts may be split up in order to satisfy the desired amount of funds under gilts"},Period:{description:"The base period for the duration queues. This is the common multiple across all supported freezing durations that can be bid upon"},QueueCount:{description:"Number of duration queues in total. This sets the maximum duration supported, which is this value multiplied by `Period`"}},Grandpa:{MaxAuthorities:{description:"Max Authorities in use"}},Identity:{BasicDeposit:{description:"The amount held on deposit for a registered identity"},FieldDeposit:{description:"The amount held on deposit per additional field for a registered identity"},MaxAdditionalFields:{description:"Maximum number of additional fields that may be stored in an ID. Needed to bound the I/O required to access an identity, but can be pretty high"},MaxRegistrars:{description:"Maxmimum number of registrars allowed in the system. Needed to bound the complexity of, e.g., updating judgements"},MaxSubAccounts:{description:"The maximum number of sub-accounts allowed per identified account"},SubAccountDeposit:{description:"The amount held on deposit for a registered subaccount. This should account for the fact that one storage item's value will increase by the size of an account ID, and there will be another trie item whose value is the size of an account ID plus 32 bytes"}},ImOnline:{UnsignedPriority:{description:"A configuration for base priority of unsigned transactions"}},Indices:{Deposit:{description:"The deposit needed for reserving an index"}},Lottery:{MaxCalls:{description:"The max number of calls available in a single lottery"},MaxGenerateRandom:{description:"Number of time we should try to generate a random number that has no modulo bias. The larger this number, the more potential computation is used for picking the winner, but also the more likely that the chosen winner is done fairly"},PalletId:{description:"The Lottery's pallet id"}},Multisig:{DepositBase:{description:"The base amount of currency needed to reserve for creating a multisig execution or to store a dispatch call for later"},DepositFactor:{description:"The amount of currency needed per unit threshold when creating a multisig execution"},MaxSignatories:{description:"The maximum amount of signatories allowed in the multisig"}},NominationPools:{MaxPointsToBalance:{description:"The maximum pool points-to-balance ratio that an `open` pool can have"},PalletId:{description:"The nomination pool's pallet id"}},Proxy:{AnnouncementDepositBase:{description:"The base amount of currency needed to reserve for creating an announcement"},AnnouncementDepositFactor:{description:"The amount of currency needed per announcement made"},MaxPending:{description:"The maximum amount of time-delayed announcements that are allowed to be pending"},MaxProxies:{description:"The maximum amount of proxies allowed for a single account"},ProxyDepositBase:{description:"The base amount of currency needed to reserve for creating a proxy"},ProxyDepositFactor:{description:"The amount of currency needed per proxy added"}},RankedPolls:{AlarmInterval:{description:"Quantization level for the referendum wakeup scheduler. A higher number will result in fewer storage reads/writes needed for smaller voters, but also result in delays to the automatic referendum status changes. Explicit servicing instructions are unaffected"},MaxQueued:{description:"Maximum size of the referendum queue for a single track"},SubmissionDeposit:{description:"The minimum amount to be used as a deposit for a public referendum proposal"},UndecidingTimeout:{description:"The number of blocks after submission that a referendum must begin being decided by. Once this passes, then anyone may cancel the referendum"}},Recovery:{ConfigDepositBase:{description:"The base amount of currency needed to reserve for creating a recovery configuration"},FriendDepositFactor:{description:"The amount of currency needed per additional user when creating a recovery configuration"},MaxFriends:{description:"The maximum amount of friends allowed in a recovery configuration"},RecoveryDeposit:{description:"The base amount of currency needed to reserve for starting a recovery"}},Referenda:{AlarmInterval:{description:"Quantization level for the referendum wakeup scheduler. A higher number will result in fewer storage reads/writes needed for smaller voters, but also result in delays to the automatic referendum status changes. Explicit servicing instructions are unaffected"},MaxQueued:{description:"Maximum size of the referendum queue for a single track"},SubmissionDeposit:{description:"The minimum amount to be used as a deposit for a public referendum proposal"},UndecidingTimeout:{description:"The number of blocks after submission that a referendum must begin being decided by. Once this passes, then anyone may cancel the referendum"}},Scheduler:{MaximumWeight:{description:"The maximum weight that may be scheduled per block for any dispatchables of less priority than `schedule::HARD_DEADLINE`"},MaxScheduledPerBlock:{description:"The maximum number of scheduled calls in the queue for a single block. Not strictly enforced, but used for weight estimation"}},Society:{CandidateDeposit:{description:"The minimum amount of a deposit required for a bid to be made"},ChallengePeriod:{description:"The number of blocks between membership challenges"},MaxCandidateIntake:{description:"The maximum number of candidates that we accept per round"},MaxLockDuration:{description:"The maximum duration of the payout lock"},MaxStrikes:{description:"The number of times a member may vote the wrong way (or not at all, when they are a skeptic) before they become suspended"},PalletId:{description:"The societies's pallet id"},PeriodSpend:{description:"The amount of incentive paid within each period. Doesn't include VoterTip"},RotationPeriod:{description:"The number of blocks between candidate/membership rotation periods"},WrongSideDeduction:{description:"The amount of the unpaid reward that gets deducted in the case that either a skeptic doesn't vote or someone votes in the wrong way"}},Staking:{BondingDuration:{description:"Number of eras that staked funds must remain bonded for"},MaxNominations:{description:"Maximum number of nominations per nominator"},MaxNominatorRewardedPerValidator:{description:"The maximum number of nominators rewarded for each validator"},MaxUnlockingChunks:{description:"The maximum number of `unlocking` chunks a [`StakingLedger`] can have. Effectively determines how many unique eras a staker may be unbonding in"},SessionsPerEra:{description:"Number of sessions per era"},SlashDeferDuration:{description:"Number of eras that slashes are deferred by, after computation"}},StateTrieMigration:{MaxKeyLen:{description:"Maximal number of bytes that a key can have"}},System:{BlockHashCount:{description:"Maximum number of block number to block hash mappings to keep (oldest pruned first)"},BlockLength:{description:"The maximum length of a block (in bytes)"},BlockWeights:{description:"Block & extrinsics weights: base values and limits"},DbWeight:{description:"The weight of runtime database operations the runtime can invoke"},Ss58Prefix:{description:"The designated SS85 prefix of this chain"},Version:{description:"Get the chain's current version"}},Timestamp:{MinimumPeriod:{description:"The minimum period between blocks. Beware that this is different to the *expected* period that the block production apparatus provides. Your chosen consensus system will generally work with this to determine a sensible block time. e.g. For Aura, it will be double this period on default settings"}},Tips:{DataDepositPerByte:{description:"The amount held on deposit per byte within the tip report reason or bounty description"},MaximumReasonLength:{description:"Maximum acceptable reason length"},TipCountdown:{description:"The period for which a tip remains open after is has achieved threshold tippers"},TipFindersFee:{description:"The percent of the final tip which goes to the original reporter of the tip"},TipReportDepositBase:{description:"The amount held on deposit for placing a tip report"}},TransactionPayment:{OperationalFeeMultiplier:{description:'A fee mulitplier for `Operational` extrinsics to compute "virtual tip" to boost their `priority`'}},Treasury:{Burn:{description:"Percentage of spare funds (if any) that are burnt per spend period"},MaxApprovals:{description:"The maximum number of approvals that can wait in the spending queue"},PalletId:{description:"The treasury's pallet id, used for deriving its sovereign account ID"},ProposalBond:{description:"Fraction of a proposal's value that should be bonded in order to place the proposal. An accepted proposal gets these back. A rejected proposal does not"},ProposalBondMaximum:{description:"Maximum amount of funds that should be placed in a deposit for making a proposal"},ProposalBondMinimum:{description:"Minimum amount of funds that should be placed in a deposit for making a proposal"},SpendPeriod:{description:"Period between successive spends"}},Uniques:{AttributeDepositBase:{description:"The basic amount of funds that must be reserved when adding an attribute to an item"},CollectionDeposit:{description:"The basic amount of funds that must be reserved for collection"},DepositPerByte:{description:'The additional funds that must be reserved for the number of bytes store in metadata, either "normal" metadata or attribute metadata'},ItemDeposit:{description:"The basic amount of funds that must be reserved for an item"},KeyLimit:{description:"The maximum length of an attribute key"},MetadataDepositBase:{description:"The basic amount of funds that must be reserved when adding metadata to your item"},StringLimit:{description:"The maximum length of data stored on-chain"},ValueLimit:{description:"The maximum length of an attribute value"}},Utility:{BatchedCallsLimit:{description:"The limit on the number of batched calls"}},Vesting:{MinVestedTransfer:{description:"The minimum amount transferred to call `vested_transfer`"}}}}}),n["BPIC/Polkadot.js/Events/Blocks.sf"]='<div class="node event" style="transform: translate({{x}}px, {{y}}px)"><sf-template path="Blackprint/nodes/template/routes.sf"></sf-template><sf-template path="Blackprint/nodes/template/header.sf"></sf-template><div class="content"><div class="block-number">{{number}}</div><div class="left-port"><sf-template path="Blackprint/nodes/template/input-port.sf"></sf-template></div><div class="right-port"><sf-template path="Blackprint/nodes/template/output-port.sf"></sf-template></div></div><sf-template path="Blackprint/nodes/template/other.sf"></sf-template></div>',r.Sketch.registerInterface("BPIC/Polkadot.js/Events/Blocks",s.IFace.EventsBlocks),r.Sketch.registerDocs({"Polkadot.js":{Extrinsics:{Alliance:{AddUnscrupulousItems:{description:"Add accounts or websites to the list of unscrupulous items"},Announce:{description:"Make an announcement of a new IPFS CID about alliance issues"},Close:{description:"Close a vote that is either approved, disapproved, or whose voting period has ended"},ElevateAlly:{description:"Elevate an ally to fellow"},InitMembers:{description:"Initialize the founders, fellows, and allies"},JoinAlliance:{description:"Submit oneself for candidacy. A fixed deposit is reserved"},KickMember:{description:"Kick a member from the alliance and slash its deposit"},NominateAlly:{description:"A founder or fellow can nominate someone to join the alliance as an Ally. There is no deposit required to the nominator or nominee"},Propose:{description:"Add a new proposal to be voted on"},RemoveAnnouncement:{description:"Remove an announcement"},RemoveUnscrupulousItems:{description:"Deem an item no longer unscrupulous"},Retire:{description:"As a member, retire from the alliance and unreserve the deposit"},Set:{Rule:{description:"Set a new IPFS CID to the alliance rule"}},Veto:{description:"Veto a proposal about `set_rule` and `elevate_ally`, close, and remove it from the system, regardless of its current state"},Vote:{description:"Add an aye or nay vote for the sender to the given proposal"}},AllianceMotion:{Close:{description:"Close a vote that is either approved, disapproved or whose voting period has ended"},DisapproveProposal:{description:"Disapprove a proposal, close, and remove it from the system, regardless of its current state"},Execute:{description:"Dispatch a proposal from a member using the `Member` origin"},Propose:{description:"Add a new proposal to either be voted on or executed directly"},Set:{Members:{description:"Set the collective's membership"}},Vote:{description:"Add an aye or nay vote for the sender to the given proposal"}},Assets:{ApproveTransfer:{description:"Approve an amount of asset for transfer by a delegated third-party account"},Burn:{description:"Reduce the balance of `who` by as much as possible up to `amount` assets of `id`"},CancelApproval:{description:"Cancel all of some asset approved for delegated transfer by a third-party account"},ClearMetadata:{description:"Clear the metadata for an asset"},Create:{description:"Issue a new class of fungible assets from a public origin"},Destroy:{description:"Destroy a class of fungible assets"},ForceAssetStatus:{description:"Alter the attributes of a given asset"},ForceCancelApproval:{description:"Cancel all of some asset approved for delegated transfer by a third-party account"},ForceClearMetadata:{description:"Clear the metadata for an asset"},ForceCreate:{description:"Issue a new class of fungible assets from a privileged origin"},ForceSetMetadata:{description:"Force the metadata for an asset to some value"},ForceTransfer:{description:"Move some assets from one account to another"},Freeze:{description:"Disallow further unprivileged transfers from an account"},FreezeAsset:{description:"Disallow further unprivileged transfers for the asset class"},Mint:{description:"Mint assets of a particular class"},Refund:{description:"Return the deposit (if any) of an asset account"},Set:{Metadata:{description:"Set the metadata for an asset"},Team:{description:"Change the Issuer, Admin and Freezer of an asset"}},Thaw:{description:"Allow unprivileged transfers from an account again"},ThawAsset:{description:"Allow unprivileged transfers for the asset again"},Touch:{description:"Create an asset account for non-provider assets"},Transfer:{description:"Move some assets from the sender account to another"},TransferApproved:{description:"Transfer some asset balance from a previously delegated account to some third-party account"},TransferKeepAlive:{description:"Move some assets from the sender account to another, keeping the sender account alive"},TransferOwnership:{description:"Change the Owner of an asset"}},Authorship:{Set:{Uncles:{description:"Provide a set of uncles"}}},Babe:{PlanConfigChange:{description:"Plan an epoch config change. The epoch config change is recorded and will be enacted on the next call to `enact_epoch_change`. The config will be activated one epoch after. Multiple calls to this method will replace any existing planned config change that had not been enacted yet"},ReportEquivocation:{description:"Report authority equivocation/misbehavior. This method will verify the equivocation proof and validate the given key ownership proof against the extracted offender. If both are valid, the offence will be reported"},ReportEquivocationUnsigned:{description:"Report authority equivocation/misbehavior. This method will verify the equivocation proof and validate the given key ownership proof against the extracted offender. If both are valid, the offence will be reported. This extrinsic must be called unsigned and it is expected that only block authors will call it (validated in `ValidateUnsigned`), as such if the block author is defined it will be defined as the equivocation reporter"}},BagsList:{PutInFrontOf:{description:"Move the caller's Id directly in front of `lighter`"},Rebag:{description:"Declare that some `dislocated` account has, through rewards or penalties, sufficiently changed its score that it should properly fall into a different bag than its current one"}},Balances:{ForceTransfer:{description:"Exactly as `transfer`, except the origin must be root and the source account may be specified"},ForceUnreserve:{description:"Unreserve some balance from a user by force"},Set:{Balance:{description:"Set the balances of a given account"}},Transfer:{description:"Transfer some liquid free balance to another account"},TransferAll:{description:"Transfer the entire transferable balance from the caller account"},TransferKeepAlive:{description:"Same as the [`transfer`] call, but with a check that the transfer will not kill the origin account"}},Bounties:{AcceptCurator:{description:"Accept the curator role for a bounty. A deposit will be reserved from curator and refund upon successful payout"},ApproveBounty:{description:"Approve a bounty proposal. At a later time, the bounty will be funded and become active and the original deposit will be returned"},AwardBounty:{description:"Award bounty to a beneficiary account. The beneficiary will be able to claim the funds after a delay"},ClaimBounty:{description:"Claim the payout from an awarded bounty after payout delay"},CloseBounty:{description:"Cancel a proposed or active bounty. All the funds will be sent to treasury and the curator deposit will be unreserved if possible"},ExtendBountyExpiry:{description:"Extend the expiry time of an active bounty"},ProposeBounty:{description:"Propose a new bounty"},ProposeCurator:{description:"Assign a curator to a funded bounty"},UnassignCurator:{description:"Unassign curator from a bounty"}},ChildBounties:{AcceptCurator:{description:"Accept the curator role for the child-bounty"},AddChildBounty:{description:"Add a new child-bounty"},AwardChildBounty:{description:"Award child-bounty to a beneficiary"},ClaimChildBounty:{description:"Claim the payout from an awarded child-bounty after payout delay"},CloseChildBounty:{description:"Cancel a proposed or active child-bounty. Child-bounty account funds are transferred to parent bounty account. The child-bounty curator deposit may be unreserved if possible"},ProposeCurator:{description:"Propose curator for funded child-bounty"},UnassignCurator:{description:"Unassign curator from a child-bounty"}},Contracts:{Call:{description:"Makes a call to an account, optionally transferring some balance"},Instantiate:{description:"Instantiates a contract from a previously deployed wasm binary"},InstantiateWithCode:{description:"Instantiates a new contract from the supplied `code` optionally transferring some balance"},RemoveCode:{description:"Remove the code stored under `code_hash` and refund the deposit to its owner"},Set:{Code:{description:"Privileged function that changes the code of an existing contract"}},UploadCode:{description:"Upload new `code` without instantiating a contract from it"}},ConvictionVoting:{Delegate:{description:"Delegate the voting power (with some given conviction) of the sending account for a particular class of polls"},RemoveOtherVote:{description:"Remove a vote for a poll"},RemoveVote:{description:"Remove a vote for a poll"},Undelegate:{description:"Undelegate the voting power of the sending account for a particular class of polls"},Unlock:{description:"Remove the lock caused prior voting/delegating which has expired within a particluar class"},Vote:{description:"Vote in a poll. If `vote.is_aye()`, the vote is to enact the proposal; otherwise it is a vote to keep the status quo"}},Council:{Close:{description:"Close a vote that is either approved, disapproved or whose voting period has ended"},DisapproveProposal:{description:"Disapprove a proposal, close, and remove it from the system, regardless of its current state"},Execute:{description:"Dispatch a proposal from a member using the `Member` origin"},Propose:{description:"Add a new proposal to either be voted on or executed directly"},Set:{Members:{description:"Set the collective's membership"}},Vote:{description:"Add an aye or nay vote for the sender to the given proposal"}},Democracy:{Blacklist:{description:"Permanently place a proposal into the blacklist. This prevents it from ever being proposed again"},CancelProposal:{description:"Remove a proposal"},CancelQueued:{description:"Cancel a proposal queued for enactment"},CancelReferendum:{description:"Remove a referendum"},ClearPublicProposals:{description:"Clears all public proposals"},Delegate:{description:"Delegate the voting power (with some given conviction) of the sending account"},EmergencyCancel:{description:"Schedule an emergency cancellation of a referendum. Cannot happen twice to the same referendum"},EnactProposal:{description:"Enact a proposal from a referendum. For now we just make the weight be the maximum"},ExternalPropose:{description:"Schedule a referendum to be tabled once it is legal to schedule an external referendum"},ExternalProposeDefault:{description:"Schedule a negative-turnout-bias referendum to be tabled next once it is legal to schedule an external referendum"},ExternalProposeMajority:{description:"Schedule a majority-carries referendum to be tabled next once it is legal to schedule an external referendum"},FastTrack:{description:"Schedule the currently externally-proposed majority-carries referendum to be tabled immediately. If there is no externally-proposed referendum currently, or if there is one but it is not a majority-carries referendum then it fails"},NoteImminentPreimage:{description:"Register the preimage for an upcoming proposal. This requires the proposal to be in the dispatch queue. No deposit is needed. When this call is successful, i.e. the preimage has not been uploaded before and matches some imminent proposal, no fee is paid"},NoteImminentPreimageOperational:{description:"Same as `note_imminent_preimage` but origin is `OperationalPreimageOrigin`"},NotePreimage:{description:"Register the preimage for an upcoming proposal. This doesn't require the proposal to be in the dispatch queue but does require a deposit, returned once enacted"},NotePreimageOperational:{description:"Same as `note_preimage` but origin is `OperationalPreimageOrigin`"},Propose:{description:"Propose a sensitive action to be taken"},ReapPreimage:{description:"Remove an expired proposal preimage and collect the deposit"},RemoveOtherVote:{description:"Remove a vote for a referendum"},RemoveVote:{description:"Remove a vote for a referendum"},Second:{description:"Signals agreement with a particular proposal"},Undelegate:{description:"Undelegate the voting power of the sending account"},Unlock:{description:"Unlock tokens that have an expired lock"},VetoExternal:{description:"Veto and blacklist the external proposal hash"},Vote:{description:"Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal; otherwise it is a vote to keep the status quo"}},ElectionProviderMultiPhase:{GovernanceFallback:{description:"Trigger the governance fallback"},Set:{EmergencyElectionResult:{description:"Set a solution in the queue, to be handed out to the client of this pallet in the next call to `ElectionProvider::elect`"},MinimumUntrustedScore:{description:"Set a new value for `MinimumUntrustedScore`"}},Submit:{description:"Submit a solution for the signed phase"},SubmitUnsigned:{description:"Submit a solution for the unsigned phase"}},Elections:{CleanDefunctVoters:{description:"Clean all voters who are defunct (i.e. they do not serve any purpose at all). The deposit of the removed voters are returned"},RemoveMember:{description:"Remove a particular member from the set. This is effective immediately and the bond of the outgoing member is slashed"},RemoveVoter:{description:"Remove `origin` as a voter"},RenounceCandidacy:{description:"Renounce one's intention to be a candidate for the next election round. 3 potential outcomes exist:"},SubmitCandidacy:{description:"Submit oneself for candidacy. A fixed amount of deposit is recorded"},Vote:{description:"Vote for a set of candidates for the upcoming round of election. This can be called to set the initial votes, or update already existing votes"}},Gilt:{PlaceBid:{description:"Place a bid for a gilt to be issued"},RetractBid:{description:"Retract a previously placed bid"},Set:{Target:{description:"Set target proportion of gilt-funds"}},Thaw:{description:"Remove an active but expired gilt. Reserved funds under gilt are freed and balance is adjusted to ensure that the funds grow or shrink to maintain the equivalent proportion of effective total issued funds"}},Grandpa:{NoteStalled:{description:"Note that the current authority set of the GRANDPA finality gadget has stalled"},ReportEquivocation:{description:"Report voter equivocation/misbehavior. This method will verify the equivocation proof and validate the given key ownership proof against the extracted offender. If both are valid, the offence will be reported"},ReportEquivocationUnsigned:{description:"Report voter equivocation/misbehavior. This method will verify the equivocation proof and validate the given key ownership proof against the extracted offender. If both are valid, the offence will be reported"}},Identity:{AddRegistrar:{description:"Add a registrar to the system"},AddSub:{description:"Add the given account to the sender's subs"},CancelRequest:{description:"Cancel a previous request"},ClearIdentity:{description:"Clear an account's identity info and all sub-accounts and return all deposits"},KillIdentity:{description:"Remove an account's identity and sub-account information and slash the deposits"},ProvideJudgement:{description:"Provide a judgement for an account's identity"},QuitSub:{description:"Remove the sender as a sub-account"},RemoveSub:{description:"Remove the given account from the sender's subs"},RenameSub:{description:"Alter the associated name of the given sub-account"},RequestJudgement:{description:"Request a judgement from a registrar"},Set:{AccountId:{description:"Change the account associated with a registrar"},Fee:{description:"Set the fee required for a judgement to be requested from a registrar"},Fields:{description:"Set the field information for a registrar"},Identity:{description:"Set an account's identity information and reserve the appropriate deposit"},Subs:{description:"Set the sub-accounts of the sender"}}},ImOnline:{Heartbeat:{description:""}},Indices:{Claim:{description:"Assign an previously unassigned index"},ForceTransfer:{description:"Force an index to an account. This doesn't require a deposit. If the index is already held, then any deposit is reimbursed to its current owner"},Free:{description:"Free up an index owned by the sender"},Freeze:{description:"Freeze an index so it will always point to the sender account. This consumes the deposit"},Transfer:{description:"Assign an index already owned by the sender to another account. The balance reservation is effectively transferred to the new account"}},Lottery:{BuyTicket:{description:"Buy a ticket to enter the lottery"},Set:{Calls:{description:"Set calls in storage which can be used to purchase a lottery ticket"}},StartLottery:{description:"Start a lottery using the provided configuration"},StopRepeat:{description:"If a lottery is repeating, you can use this to stop the repeat. The lottery will continue to run to completion"}},Multisig:{ApproveAsMulti:{description:"Register approval for a dispatch to be made from a deterministic composite account if approved by a total of `threshold - 1` of `other_signatories`"},AsMulti:{description:"Register approval for a dispatch to be made from a deterministic composite account if approved by a total of `threshold - 1` of `other_signatories`"},AsMultiThreshold1:{description:"Immediately dispatch a multi-signature call using a single approval from the caller"},CancelAsMulti:{description:"Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously for this operation will be unreserved on success"}},NominationPools:{BondExtra:{description:"Bond `extra` more funds from `origin` into the pool to which they already belong"},Chill:{description:"Chill on behalf of the pool"},ClaimPayout:{description:"A bonded member can use this to claim their payout based on the rewards that the pool has accumulated since their last claimed payout (OR since joining if this is there first time claiming rewards). The payout will be transferred to the member's account"},Create:{description:"Create a new delegation pool"},Join:{description:"Stake funds with a pool. The amount to bond is transferred from the member to the pools account and immediately increases the pools bond"},Nominate:{description:"Nominate on behalf of the pool"},PoolWithdrawUnbonded:{description:"Call `withdraw_unbonded` for the pools account. This call can be made by any account"},Set:{Configs:{description:"Update configurations for the nomination pools. The origin for this call must be Root"},Metadata:{description:"Set a new metadata for the pool"},State:{description:"Set a new state for the pool"}},Unbond:{description:"Unbond up to `unbonding_points` of the `member_account`'s funds from the pool. It implicitly collects the rewards one last time, since not doing so would mean some rewards would be forfeited"},UpdateRoles:{description:"Update the roles of the pool"},WithdrawUnbonded:{description:"Withdraw unbonded funds from `member_account`. If no bonded funds can be unbonded, an error is returned"}},Preimage:{NotePreimage:{description:"Register a preimage on-chain"},RequestPreimage:{description:"Request a preimage be uploaded to the chain without paying any fees or deposits"},UnnotePreimage:{description:"Clear an unrequested preimage from the runtime storage"},UnrequestPreimage:{description:"Clear a previously made request for a preimage"}},Proxy:{AddProxy:{description:"Register a proxy account for the sender that is able to make calls on its behalf"},Announce:{description:"Publish the hash of a proxy-call that will be made in the future"},Anonymous:{description:"Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and initialize it with a proxy of `proxy_type` for `origin` sender"},KillAnonymous:{description:"Removes a previously spawned anonymous proxy"},Proxy:{description:"Dispatch the given `call` from an account that the sender is authorised for through `add_proxy`"},ProxyAnnounced:{description:"Dispatch the given `call` from an account that the sender is authorized for through `add_proxy`"},RejectAnnouncement:{description:"Remove the given announcement of a delegate"},RemoveAnnouncement:{description:"Remove a given announcement"},RemoveProxies:{description:"Unregister all proxy accounts for the sender"},RemoveProxy:{description:"Unregister a proxy account for the sender"}},RankedCollective:{AddMember:{description:"Introduce a new member"},CleanupPoll:{description:"Remove votes from the given poll. It must have ended"},DemoteMember:{description:"Decrement the rank of an existing member by one. If the member is already at rank zero, then they are removed entirely"},PromoteMember:{description:"Increment the rank of an existing member by one"},RemoveMember:{description:"Remove the member entirely"},Vote:{description:"Add an aye or nay vote for the sender to the given proposal"}},RankedPolls:{Cancel:{description:"Cancel an ongoing referendum"},Kill:{description:"Cancel an ongoing referendum and slash the deposits"},NudgeReferendum:{description:"Advance a referendum onto its next logical state. Only used internally"},OneFewerDeciding:{description:"Advance a track onto its next logical state. Only used internally"},PlaceDecisionDeposit:{description:"Post the Decision Deposit for a referendum"},RefundDecisionDeposit:{description:"Refund the Decision Deposit for a closed referendum back to the depositor"},Submit:{description:"Propose a referendum on a privileged action"}},Recovery:{AsRecovered:{description:"Send a call through a recovered account"},CancelRecovered:{description:"Cancel the ability to use `as_recovered` for `account`"},ClaimRecovery:{description:"Allow a successful rescuer to claim their recovered account"},CloseRecovery:{description:"As the controller of a recoverable account, close an active recovery process for your account"},CreateRecovery:{description:"Create a recovery configuration for your account. This makes your account recoverable"},InitiateRecovery:{description:"Initiate the process for recovering a recoverable account"},RemoveRecovery:{description:"Remove the recovery process for your account. Recovered accounts are still accessible"},Set:{Recovered:{description:"Allow ROOT to bypass the recovery process and set an a rescuer account for a lost account directly"}},VouchRecovery:{description:'Allow a "friend" of a recoverable account to vouch for an active recovery process for that account'}},Referenda:{Cancel:{description:"Cancel an ongoing referendum"},Kill:{description:"Cancel an ongoing referendum and slash the deposits"},NudgeReferendum:{description:"Advance a referendum onto its next logical state. Only used internally"},OneFewerDeciding:{description:"Advance a track onto its next logical state. Only used internally"},PlaceDecisionDeposit:{description:"Post the Decision Deposit for a referendum"},RefundDecisionDeposit:{description:"Refund the Decision Deposit for a closed referendum back to the depositor"},Submit:{description:"Propose a referendum on a privileged action"}},Remark:{Store:{description:"Index and store data off chain"}},Scheduler:{Cancel:{description:"Cancel an anonymously scheduled task"},CancelNamed:{description:"Cancel a named scheduled task"},Schedule:{description:"Anonymously schedule a task"},ScheduleAfter:{description:"Anonymously schedule a task after a delay"},ScheduleNamed:{description:"Schedule a named task"},ScheduleNamedAfter:{description:"Schedule a named task after a delay"}},Session:{PurgeKeys:{description:"Removes any session key(s) of the function caller"},Set:{Keys:{description:"Sets the session key(s) of the function caller to `keys`. Allows an account to set its session key prior to becoming a validator. This doesn't take effect until the next session"}}},Society:{Bid:{description:"A user outside of the society can make a bid for entry"},DefenderVote:{description:"As a member, vote on the defender"},Found:{description:"Found the society"},JudgeSuspendedCandidate:{description:"Allow suspended judgement origin to make judgement on a suspended candidate"},JudgeSuspendedMember:{description:"Allow suspension judgement origin to make judgement on a suspended member"},Payout:{description:"Transfer the first matured payout for the sender and remove it from the records"},Set:{MaxMembers:{description:"Allows root origin to change the maximum number of members in society. Max membership count must be greater than 1"}},Unbid:{description:"A bidder can remove their bid for entry into society. By doing so, they will have their candidate deposit returned or they will unvouch their voucher"},Unfound:{description:"Annul the founding of the society"},Unvouch:{description:"As a vouching member, unvouch a bid. This only works while vouched user is only a bidder (and not a candidate)"},Vote:{description:"As a member, vote on a candidate"},Vouch:{description:"As a member, vouch for someone to join society by placing a bid on their behalf"}},Staking:{Bond:{description:"Take the origin account as a stash and lock up `value` of its balance. `controller` will be the account that controls it"},BondExtra:{description:"Add some extra amount that have appeared in the stash `free_balance` into the balance up for staking"},CancelDeferredSlash:{description:"Cancel enactment of a deferred slash"},Chill:{description:"Declare no desire to either validate or nominate"},ChillOther:{description:"Declare a `controller` to stop participating as either a validator or nominator"},ForceApplyMinCommission:{description:"Force a validator to have at least the minimum commission. This will not affect a validator who already has a commission greater than or equal to the minimum. Any account can call this"},ForceNewEra:{description:"Force there to be a new era at the end of the next session. After this, it will be reset to normal (non-forced) behaviour"},ForceNewEraAlways:{description:"Force there to be a new era at the end of sessions indefinitely"},ForceNoEras:{description:"Force there to be no new eras indefinitely"},ForceUnstake:{description:"Force a current staker to become completely unstaked, immediately"},IncreaseValidatorCount:{description:"Increments the ideal number of validators"},Kick:{description:"Remove the given nominations from the calling validator"},Nominate:{description:"Declare the desire to nominate `targets` for the origin controller"},PayoutStakers:{description:"Pay out all the stakers behind a single validator for a single era"},ReapStash:{description:"Remove all data structures concerning a staker/stash once it is at a state where it can be considered `dust` in the staking system. The requirements are:"},Rebond:{description:"Rebond a portion of the stash scheduled to be unlocked"},ScaleValidatorCount:{description:"Scale up the ideal number of validators by a factor"},Set:{Controller:{description:"(Re-)set the controller of a stash"},HistoryDepth:{description:"Set `HistoryDepth` value. This function will delete any history information when `HistoryDepth` is reduced"},Invulnerables:{description:"Set the validators who cannot be slashed (if any)"},Payee:{description:"(Re-)set the payment target for a controller"},StakingConfigs:{description:"Update the various staking configurations "},ValidatorCount:{description:"Sets the ideal number of validators"}},Unbond:{description:"Schedule a portion of the stash to be unlocked ready for transfer out after the bond period ends. If this leaves an amount actively bonded less than T::Currency::minimum_balance(), then it is increased to the full amount"},Validate:{description:"Declare the desire to validate for the origin controller"},WithdrawUnbonded:{description:"Remove any unlocked chunks from the `unlocking` queue from our management"}},StateTrieMigration:{ContinueMigrate:{description:"Continue the migration for the given `limits`"},ControlAutoMigration:{description:"Control the automatic migration"},ForceSetProgress:{description:"Forcefully set the progress the running migration"},MigrateCustomChild:{description:"Migrate the list of child keys by iterating each of them one by one"},MigrateCustomTop:{description:"Migrate the list of top keys by iterating each of them one by one"},Set:{SignedMaxLimits:{description:"Set the maximum limit of the signed migration"}}},Sudo:{Set:{Key:{description:"Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key"}},Sudo:{description:"Authenticates the sudo key and dispatches a function call with `Root` origin"},SudoAs:{description:"Authenticates the sudo key and dispatches a function call with `Signed` origin from a given account"},SudoUncheckedWeight:{description:"Authenticates the sudo key and dispatches a function call with `Root` origin. This function does not check the weight of the call, and instead allows the Sudo user to specify the weight of the call"}},System:{FillBlock:{description:"A dispatch that will fill the block weight up to the given ratio"},KillPrefix:{description:"Kill all storage items with a key that starts with the given prefix"},KillStorage:{description:"Kill some items from storage"},Remark:{description:"Make some on-chain remark"},RemarkWithEvent:{description:"Make some on-chain remark and emit event"},Set:{Code:{description:"Set the new runtime code"},CodeWithoutChecks:{description:"Set the new runtime code without doing any checks of the given `code`"},HeapPages:{description:"Set the number of pages in the WebAssembly environment's heap"},Storage:{description:"Set some items of storage"}}},TechnicalCommittee:{Close:{description:"Close a vote that is either approved, disapproved or whose voting period has ended"},DisapproveProposal:{description:"Disapprove a proposal, close, and remove it from the system, regardless of its current state"},Execute:{description:"Dispatch a proposal from a member using the `Member` origin"},Propose:{description:"Add a new proposal to either be voted on or executed directly"},Set:{Members:{description:"Set the collective's membership"}},Vote:{description:"Add an aye or nay vote for the sender to the given proposal"}},TechnicalMembership:{AddMember:{description:"Add a member `who` to the set"},ChangeKey:{description:"Swap out the sending member for some other key `new`"},ClearPrime:{description:"Remove the prime member if it exists"},RemoveMember:{description:"Remove a member `who` from the set"},ResetMembers:{description:"Change the membership to a new set, disregarding the existing membership. Be nice and pass `members` pre-sorted"},Set:{Prime:{description:"Set the prime member. Must be a current member"}},SwapMember:{description:"Swap out one member `remove` for another `add`"}},Timestamp:{Set:{description:"Set the current time"}},Tips:{CloseTip:{description:"Close and payout a tip"},ReportAwesome:{description:"Report something `reason` that deserves a tip and claim any eventual the finder's fee"},RetractTip:{description:"Retract a prior tip-report from `report_awesome`, and cancel the process of tipping"},SlashTip:{description:"Remove and slash an already-open tip"},Tip:{description:"Declare a tip value for an already-open tip"},TipNew:{description:"Give a tip for something new; no finder's fee will be taken"}},TransactionStorage:{CheckProof:{description:"Check storage proof for block number `block_number() - StoragePeriod`. If such block does not exist the proof is expected to be `None`"},Renew:{description:"Renew previously stored data. Parameters are the block number that contains previous `store` or `renew` call and transaction index within that block. Transaction index is emitted in the `Stored` or `Renewed` event. Applies same fees as `store`"},Store:{description:"Index and store data off chain. Minimum data size is 1 bytes, maximum is `MaxTransactionSize`. Data will be removed after `STORAGE_PERIOD` blocks, unless `renew` is called. #"}},Treasury:{ApproveProposal:{description:"Approve a proposal. At a later time, the proposal will be allocated to the beneficiary and the original deposit will be returned"},ProposeSpend:{description:"Put forward a suggestion for spending. A deposit proportional to the value is reserved and slashed if the proposal is rejected. It is returned once the proposal is awarded"},RejectProposal:{description:"Reject a proposed spend. The original deposit will be slashed"},RemoveApproval:{description:"Force a previously approved proposal to be removed from the approval queue. The original deposit will no longer be returned"},Spend:{description:"Propose and approve a spend of treasury funds"}},Uniques:{ApproveTransfer:{description:"Approve an item to be transferred by a delegated third-party account"},Burn:{description:"Destroy a single item"},BuyItem:{description:"Allows to buy an item if it's up for sale"},CancelApproval:{description:"Cancel the prior approval for the transfer of an item by a delegate"},ClearAttribute:{description:"Clear an attribute for a collection or item"},ClearCollectionMetadata:{description:"Clear the metadata for a collection"},ClearMetadata:{description:"Clear the metadata for an item"},Create:{description:"Issue a new collection of non-fungible items from a public origin"},Destroy:{description:"Destroy a collection of fungible items"},ForceCreate:{description:"Issue a new collection of non-fungible items from a privileged origin"},ForceItemStatus:{description:"Alter the attributes of a given item"},Freeze:{description:"Disallow further unprivileged transfer of an item"},FreezeCollection:{description:"Disallow further unprivileged transfers for a whole collection"},Mint:{description:"Mint an item of a particular collection"},Redeposit:{description:"Reevaluate the deposits on some items"},Set:{AcceptOwnership:{description:"Set (or reset) the acceptance of ownership for a particular account"},Attribute:{description:"Set an attribute for a collection or item"},CollectionMaxSupply:{description:"Set the maximum amount of items a collection could have"},CollectionMetadata:{description:"Set the metadata for a collection"},Metadata:{description:"Set the metadata for an item"},Price:{description:"Set (or reset) the price for an item"},Team:{description:"Change the Issuer, Admin and Freezer of a collection"}},Thaw:{description:"Re-allow unprivileged transfer of an item"},ThawCollection:{description:"Re-allow unprivileged transfers for a whole collection"},Transfer:{description:"Move an item from the sender account to another"},TransferOwnership:{description:"Change the Owner of a collection"},TryIncrementId:{description:"Increments the `CollectionId` stored in `NextCollectionId`"}},Utility:{AsDerivative:{description:"Send a call through an indexed pseudonym of the sender"},Batch:{description:"Send a batch of dispatch calls"},BatchAll:{description:"Send a batch of dispatch calls and atomically execute them. The whole transaction will rollback and fail if any of the calls failed"},DispatchAs:{description:"Dispatches a function call with a provided origin"},ForceBatch:{description:"Send a batch of dispatch calls. Unlike `batch`, it allows errors and won't interrupt"}},Vesting:{ForceVestedTransfer:{description:"Force a vested transfer"},MergeSchedules:{description:"Merge two vesting schedules together, creating a new vesting schedule that unlocks over the highest possible start and end blocks. If both schedules have already started the current block will be used as the schedule start; with the caveat that if one schedule is finished by the current block, the other will be treated as the new merged schedule, unmodified"},Vest:{description:"Unlock any vested funds of the sender account"},VestOther:{description:"Unlock any vested funds of a `target` account"},VestedTransfer:{description:"Create a vested transfer"}}}}}),r.Sketch.registerDocs({"Polkadot.js":{RPC:{Author:{Has:{Key:{description:"Returns true if the keystore has private keys for the given public key and key type"},SessionKeys:{description:"Returns true if the keystore has private keys for the given session public keys"}},InsertKey:{description:"Insert a key into the keystore"},PendingExtrinsics:{description:"Returns all pending extrinsics, potentially grouped by sender"},RemoveExtrinsic:{description:"Remove given extrinsic from the pool and temporarily ban it to prevent reimporting"},RotateKeys:{description:"Generate new session keys and returns the corresponding public keys"},SubmitAndWatchExtrinsic:{description:"Submit and subscribe to watch an extrinsic until unsubscribed"},SubmitExtrinsic:{description:"Submit a fully formatted extrinsic for block inclusion"}},Babe:{EpochAuthorship:{description:"Returns data about which slots (primary or secondary) can be claimed in the current epoch with the keys in the keystore"}},Beefy:{Get:{FinalizedHead:{description:"Returns hash of the latest BEEFY finalized block as seen by this client"}},SubscribeJustifications:{description:"Returns the block most recently finalized by BEEFY, alongside side its justification"}},Chain:{Get:{Block:{description:"Get header and body of a relay chain block"},BlockHash:{description:"Get the block hash for a specific block"},FinalizedHead:{description:"Get hash of the last finalized block in the canon chain"},Header:{description:"Retrieves the header for a specific block"}},SubscribeAllHeads:{description:"Retrieves the newest header via subscription"},SubscribeFinalizedHeads:{description:"Retrieves the best finalized header via subscription"},SubscribeNewHeads:{description:"Retrieves the best header via subscription"}},ChildState:{Get:{Keys:{description:"Returns the keys with prefix from a child storage, leave empty to get all the keys"},KeysPaged:{description:"Returns the keys with prefix from a child storage with pagination support"},Storage:{description:"Returns a child storage entry at a specific block state"},StorageEntries:{description:"Returns child storage entries for multiple keys at a specific block state"},StorageHash:{description:"Returns the hash of a child storage entry at a block state"},StorageSize:{description:"Returns the size of a child storage entry at a block state"}}},Contracts:{Call:{description:"Executes a call to a contract"},Get:{Storage:{description:"Returns the value under a specified storage key in a contract"}},Instantiate:{description:"Instantiate a new contract"},RentProjection:{description:"Returns the projected time a given contract will be able to sustain paying its rent"},UploadCode:{description:"Upload new code without instantiating a contract from it"}},Dev:{Get:{BlockStats:{description:"Reexecute the specified `block_hash` and gather statistics while doing so"}}},Engine:{CreateBlock:{description:"Instructs the manual-seal authorship task to create a new block"},FinalizeBlock:{description:"Instructs the manual-seal authorship task to finalize a block"}},Eth:{Accounts:{description:"Returns accounts list"},BlockNumber:{description:"Returns the blockNumber"},Call:{description:"Call contract, returning the output data"},ChainId:{description:"Returns the chain ID used for transaction signing at the current best block. None is returned if not available"},Coinbase:{description:"Returns block author"},EstimateGas:{description:"Estimate gas needed for execution of given contract"},FeeHistory:{description:"Returns fee history for given block count & reward percentiles"},GasPrice:{description:"Returns current gas price"},Get:{Balance:{description:"Returns balance of the given account"},BlockBy:{Hash:{description:"Returns block with given hash"},Number:{description:"Returns block with given number"}},BlockTransactionCountBy:{Hash:{description:"Returns the number of transactions in a block with given hash"},Number:{description:"Returns the number of transactions in a block with given block number"}},Code:{description:"Returns the code at given address at given time (block number)"},FilterChanges:{description:"Returns filter changes since last poll"},FilterLogs:{description:"Returns all logs matching given filter (in a range 'from' - 'to')"},Logs:{description:"Returns logs matching given filter object"},Proof:{description:"Returns proof for account and storage"},StorageAt:{description:"Returns content of the storage at given address"},TransactionBy:{BlockHashAndIndex:{description:"Returns transaction at given block hash and index"},BlockNumberAndIndex:{description:"Returns transaction by given block number and index"},Hash:{description:"Get transaction by its hash"}},TransactionCount:{description:"Returns the number of transactions sent from given address at given time (block number)"},TransactionReceipt:{description:"Returns transaction receipt by transaction hash"},UncleBy:{BlockHashAndIndex:{description:"Returns an uncles at given block and index"},BlockNumberAndIndex:{description:"Returns an uncles at given block and index"}},UncleCountBy:{BlockHash:{description:"Returns the number of uncles in a block with given hash"},BlockNumber:{description:"Returns the number of uncles in a block with given block number"}},Work:{description:"Returns the hash of the current block, the seedHash, and the boundary condition to be met"}},Hashrate:{description:"Returns the number of hashes per second that the node is mining with"},MaxPriorityFeePerGas:{description:"Returns max priority fee per gas"},Mining:{description:"Returns true if client is actively mining new blocks"},New:{BlockFilter:{description:"Returns id of new block filter"},Filter:{description:"Returns id of new filter"},PendingTransactionFilter:{description:"Returns id of new block filter"}},ProtocolVersion:{description:"Returns protocol version encoded as a string (quotes are necessary)"},SendRawTransaction:{description:"Sends signed transaction, returning its hash"},SendTransaction:{description:"Sends transaction; will block waiting for signer to return the transaction hash"},SubmitHashrate:{description:"Used for submitting mining hashrate"},SubmitWork:{description:"Used for submitting a proof-of-work solution"},Subscribe:{description:"Subscribe to Eth subscription"},Syncing:{description:"Returns an object with data about the sync status or false"},UninstallFilter:{description:"Uninstalls filter"}},Net:{Listening:{description:"Returns true if client is actively listening for network connections. Otherwise false"},PeerCount:{description:"Returns number of peers connected to node"},Version:{description:"Returns protocol version"}},Web3:{ClientVersion:{description:"Returns current client version"},Sha3:{description:"Returns sha3 of the given data"}},Grandpa:{ProveFinality:{description:"Prove finality for the given block number, returning the Justification for the last block in the set"},RoundState:{description:"Returns the state of the current best round state as well as the ongoing background rounds"},SubscribeJustifications:{description:"Subscribes to grandpa justifications"}},Mmr:{GenerateBatchProof:{description:"Generate MMR proof for the given leaf indices"},GenerateProof:{description:"Generate MMR proof for given leaf index"}},OffChain:{LocalStorageGet:{description:"Get offchain local storage under given key and prefix"},LocalStorageSet:{description:"Set offchain local storage under given key and prefix"}},Payment:{QueryFeeDetails:{description:"Query the detailed fee of a given encoded extrinsic"},QueryInfo:{description:"Retrieves the fee information for an encoded extrinsic"}},Rpc:{Methods:{description:"Retrieves the list of RPC methods that are exposed by the node"}},State:{Call:{description:"Perform a call to a builtin on the chain"},Get:{ChildKeys:{description:"Retrieves the keys with prefix of a specific child storage"},ChildReadProof:{description:"Returns proof of storage for child key entries at a specific block state"},ChildStorage:{description:"Retrieves the child storage for a key"},ChildStorageHash:{description:"Retrieves the child storage hash"},ChildStorageSize:{description:"Retrieves the child storage size"},Keys:{description:"Retrieves the keys with a certain prefix"},KeysPaged:{description:"Returns the keys with prefix with pagination support"},Metadata:{description:"Returns the runtime metadata"},Pairs:{description:"Returns the keys with prefix, leave empty to get all the keys (deprecated: Use getKeysPaged)"},ReadProof:{description:"Returns proof of storage entries at a specific block state"},RuntimeVersion:{description:"Get the runtime version"},Storage:{description:"Retrieves the storage for a key"},StorageHash:{description:"Retrieves the storage hash"},StorageSize:{description:"Retrieves the storage size"}},QueryStorage:{description:"Query historical storage entries (by key) starting from a start block"},QueryStorageAt:{description:"Query storage entries (by key) starting at block hash given as the second parameter"},SubscribeRuntimeVersion:{description:"Retrieves the runtime version via subscription"},SubscribeStorage:{description:"Subscribes to storage changes for the provided keys"},TraceBlock:{description:"Provides a way to trace the re-execution of a single block"},TrieMigrationStatus:{description:"Check current migration state"}},SyncState:{GenSyncSpec:{description:"Returns the json-serialized chainspec running the node, with a sync state"}},System:{AccountNextIndex:{description:"Retrieves the next accountIndex as available on the node"},AddLogFilter:{description:"Adds the supplied directives to the current log filter"},AddReservedPeer:{description:"Adds a reserved peer"},Chain:{description:"Retrieves the chain"},ChainType:{description:"Retrieves the chain type"},DryRun:{description:"Dry run an extrinsic at a given block"},Health:{description:"Return health status of the node"},LocalListenAddresses:{description:"The addresses include a trailing /p2p/ with the local PeerId, and are thus suitable to be passed to addReservedPeer or as a bootnode address for example"},LocalPeerId:{description:"Returns the base58-encoded PeerId of the node"},Name:{description:"Retrieves the node name"},NetworkState:{description:"Returns current state of the network"},NodeRoles:{description:"Returns the roles the node is running as"},Peers:{description:"Returns the currently connected peers"},Properties:{description:"Get a custom set of properties as a JSON object, defined in the chain spec"},RemoveReservedPeer:{description:"Remove a reserved peer"},ReservedPeers:{description:"Returns the list of reserved peers"},ResetLogFilter:{description:"Resets the log filter to Substrate defaults"},SyncState:{description:"Returns the state of the syncing of the node"},Version:{description:"Retrieves the version of the node"}}}}}),r.Sketch.registerDocs({"Polkadot.js":{Storage:{Alliance:{Announcements:{description:"The current IPFS CIDs of any announcements"},DepositOf:{description:"Maps members to their candidacy deposit"},Members:{description:"Maps member type to members of each type"},Rule:{description:"The IPFS CID of the alliance rule. Founders and fellows can propose a new rule with a super-majority"},UnscrupulousAccounts:{description:"The current list of accounts deemed unscrupulous. These accounts non grata cannot submit candidacy"},UnscrupulousWebsites:{description:"The current list of websites deemed unscrupulous"},UpForKicking:{description:"A set of members that are (potentially) being kicked out. They cannot retire until the motion is settled"}},AllianceMotion:{Members:{description:"The current members of the collective. This is stored sorted (just by value)"},Prime:{description:"The prime member that helps determine the default vote behavior in case of absentations"},ProposalCount:{description:"Proposals so far"},ProposalOf:{description:"Actual proposal for a given hash, if it's current"},Proposals:{description:"The hashes of the active proposals"},Voting:{description:"Votes on a given proposal, if it is ongoing"}},Assets:{Account:{description:"The holdings of a specific account for a specific asset"},Approvals:{description:"Approved balance transfers. First balance is the amount approved for transfer. Second is the amount of `T::Currency` reserved for storing this. First key is the asset ID, second key is the owner and third key is the delegate"},Asset:{description:"Details of an asset"},Metadata:{description:"Metadata of an asset"}},AuthorityDiscovery:{Keys:{description:"Keys of the current authority set"},NextKeys:{description:"Keys of the next authority set"}},Authorship:{Author:{description:"Author of current block"},DidSetUncles:{description:"Whether uncles were already set in this block"},Uncles:{description:"Uncles"}},Babe:{Authorities:{description:"Current epoch authorities"},AuthorVrfRandomness:{description:"This field should always be populated during block processing unless secondary plain slots are enabled (which don't contain a VRF output)"},CurrentSlot:{description:"Current slot number"},EpochConfig:{description:"The configuration for the current epoch. Should never be `None` as it is initialized in genesis"},EpochIndex:{description:"Current epoch index"},EpochStart:{description:"The block numbers when the last and current epoch have started, respectively `N-1` and `N`. NOTE: We track this is in order to annotate the block number when a given pool of entropy was fixed (i.e. it was known to chain observers). Since epochs are defined in slots, which may be skipped, the block numbers may not line up with the slot numbers"},GenesisSlot:{description:"The slot at which the first epoch actually started. This is 0 until the first block of the chain"},Initialized:{description:"Temporary value (cleared at block finalization) which is `Some` if per-block initialization has already been called for current block"},Lateness:{description:"How late the current block is compared to its parent"},NextAuthorities:{description:"Next epoch authorities"},NextEpochConfig:{description:"The configuration for the next epoch, `None` if the config will not change (you can fallback to `EpochConfig` instead in that case)"},NextRandomness:{description:"Next epoch randomness"},PendingEpochConfigChange:{description:"Pending epoch configuration change that will be applied when the next epoch is enacted"},Randomness:{description:"The epoch randomness for the *current* epoch"},SegmentIndex:{description:"Randomness under construction"},UnderConstruction:{description:"TWOX-NOTE: `SegmentIndex` is an increasing integer, so this is okay"}},BagsList:{CounterForListNodes:{description:"Counter for the related counted storage map"},ListBags:{description:"A bag stored in storage"},ListNodes:{description:"A single node, within some bag"}},Balances:{Account:{description:"The Balances pallet example of storing the balance of an account"},Locks:{description:"Any liquidity locks on some account balances. NOTE: Should only be accessed when setting, changing and freeing a lock"},Reserves:{description:"Named reserves on some account balances"},StorageVersion:{description:"Storage version of the pallet"},TotalIssuance:{description:"The total units issued in the system"}},Bounties:{Bounties:{description:"Bounties that have been made"},BountyApprovals:{description:"Bounty indices that have been approved but not yet funded"},BountyCount:{description:"Number of bounty proposals that have been made"},BountyDescriptions:{description:"The description of each bounty"}},ChildBounties:{ChildBounties:{description:"Child bounties that have been added"},ChildBountyCount:{description:"Number of total child bounties"},ChildBountyDescriptions:{description:"The description of each child-bounty"},ChildrenCuratorFees:{description:"The cumulative child-bounty curator fee for each parent bounty"},ParentChildBounties:{description:"Number of child bounties per parent bounty. Map of parent bounty index to number of child bounties"}},Contracts:{CodeStorage:{description:"A mapping between an original code hash and instrumented wasm code, ready for execution"},ContractInfoOf:{description:"The code associated with a given account"},DeletionQueue:{description:"Evicted contracts that await child trie deletion"},Nonce:{description:"This is a **monotonic** counter incremented on contract instantiation"},OwnerInfoOf:{description:"A mapping between an original code hash and its owner information"},PristineCode:{description:"A mapping from an original code hash to the original code, untouched by instrumentation"}},ConvictionVoting:{ClassLocksFor:{description:"The voting classes which have a non-zero lock requirement and the lock amounts which they require. The actual amount locked on behalf of this pallet should always be the maximum of this list"},VotingFor:{description:"All voting for a particular voter in a particular voting class. We store the balance for the number of votes that we have recorded"}},Council:{Members:{description:"The current members of the collective. This is stored sorted (just by value)"},Prime:{description:"The prime member that helps determine the default vote behavior in case of absentations"},ProposalCount:{description:"Proposals so far"},ProposalOf:{description:"Actual proposal for a given hash, if it's current"},Proposals:{description:"The hashes of the active proposals"},Voting:{description:"Votes on a given proposal, if it is ongoing"}},Democracy:{Blacklist:{description:"A record of who vetoed what. Maps proposal hash to a possible existent block number (until when it may not be resubmitted) and who vetoed it"},Cancellations:{description:"Record of all proposals that have been subject to emergency cancellation"},DepositOf:{description:"Those who have locked a deposit"},LastTabledWasExternal:{description:"True if the last referendum tabled was submitted externally. False if it was a public proposal"},LowestUnbaked:{description:"The lowest referendum index representing an unbaked referendum. Equal to `ReferendumCount` if there isn't a unbaked referendum"},NextExternal:{description:"The referendum to be tabled whenever it would be valid to table an external proposal. This happens when a referendum needs to be tabled and one of two conditions are met:"},Preimages:{description:"Map of hashes to the proposal preimage, along with who registered it and their deposit. The block number is the block at which it was deposited"},PublicPropCount:{description:"The number of (public) proposals that have been made so far"},PublicProps:{description:"The public proposals. Unsorted. The second item is the proposal's hash"},ReferendumCount:{description:"The next free referendum index, aka the number of referenda started so far"},ReferendumInfoOf:{description:"Information concerning any given referendum"},StorageVersion:{description:"Storage version of the pallet"},VotingOf:{description:"All votes for a particular voter. We store the balance for the number of votes that we have recorded. The second item is the total amount of delegations, that will be added"}},ElectionProviderMultiPhase:{CurrentPhase:{description:"Current phase"},DesiredTargets:{description:"Desired number of targets to elect for this round"},MinimumUntrustedScore:{description:"The minimum score that each 'untrusted' solution must attain in order to be considered feasible"},QueuedSolution:{description:"Current best solution, signed or unsigned, queued to be returned upon `elect`"},Round:{description:"Internal counter for the number of rounds"},SignedSubmissionIndices:{description:"A sorted, bounded set of `(score, index)`, where each `index` points to a value in `SignedSubmissions`"},SignedSubmissionNextIndex:{description:"The next index to be assigned to an incoming signed submission"},SignedSubmissionsMap:{description:"Unchecked, signed solutions"},Snapshot:{description:"Snapshot data of the round"},SnapshotMetadata:{description:"The metadata of the [`RoundSnapshot`]"}},Elections:{Candidates:{description:"The present candidate list. A current member or runner-up can never enter this vector and is always implicitly assumed to be a candidate"},ElectionRounds:{description:"The total number of vote rounds that have happened, excluding the upcoming one"},Members:{description:"The current elected members"},RunnersUp:{description:"The current reserved runners-up"},Voting:{description:"Votes and locked stake of a particular voter"}},Gilt:{Active:{description:"The currently active gilts, indexed according to the order of creation"},ActiveTotal:{description:"Information relating to the gilts currently active"},Queues:{description:"The queues of bids ready to become gilts. Indexed by duration (in `Period`s)"},QueueTotals:{description:"The totals of items and balances within each queue. Saves a lot of storage reads in the case of sparsely packed queues"}},Grandpa:{CurrentSetId:{description:'The number of changes (both in terms of keys and underlying economic responsibilities) in the "set" of Grandpa validators from genesis'},NextForced:{description:"next block number where we can force a change"},PendingChange:{description:"Pending change: (signaled at, scheduled change)"},Set:{IdSession:{description:"A mapping from grandpa set ID to the index of the *most recent* session for which its members were responsible"}},Stalled:{description:"`true` if we are currently stalled"},State:{description:"State of the current authority set"}},Identity:{IdentityOf:{description:"Information that is pertinent to identify the entity behind an account"},Registrars:{description:"The set of registrars. Not expected to get very big as can only be added through a special origin (likely a council motion)"},SubsOf:{description:'Alternative "sub" identities of this account'},SuperOf:{description:'The super-identity of an alternative "sub" identity together with its name, within that context. If the account is not some other account\'s sub-identity, then just `None`'}},ImOnline:{AuthoredBlocks:{description:"For each session index, we keep a mapping of `ValidatorId<T>` to the number of blocks authored by the given authority"},HeartbeatAfter:{description:"The block number after which it's ok to send heartbeats in the current session"},Keys:{description:"The current set of keys that may issue a heartbeat"},ReceivedHeartbeats:{description:"For each session index, we keep a mapping of `SessionIndex` and `AuthIndex` to `WrapperOpaque<BoundedOpaqueNetworkState>`"}},Indices:{Accounts:{description:"The lookup from index to account"}},Lottery:{CallIndices:{description:"The calls stored in this pallet to be used in an active lottery if configured by `Config::ValidateCall`"},Lottery:{description:"The configuration for the current lottery"},Participants:{description:"Users who have purchased a ticket. (Lottery Index, Tickets Purchased)"},Tickets:{description:"Each ticket's owner"},TicketsCount:{description:"Total number of tickets sold"}},Mmr:{Nodes:{description:"Hashes of the nodes in the MMR"},NumberOfLeaves:{description:"Current size of the MMR (number of leaves)"},RootHash:{description:"Latest MMR Root hash"}},Multisig:{Multisigs:{description:"The set of open multisig operations"}},NominationPools:{BondedPools:{description:"Storage for bonded pools"},CounterForBondedPools:{description:"Counter for the related counted storage map"},CounterForMetadata:{description:"Counter for the related counted storage map"},CounterForPoolMembers:{description:"Counter for the related counted storage map"},CounterForReversePoolIdLookup:{description:"Counter for the related counted storage map"},CounterForRewardPools:{description:"Counter for the related counted storage map"},CounterForSubPoolsStorage:{description:"Counter for the related counted storage map"},LastPoolId:{description:"Ever increasing number of all pools created so far"},MaxPoolMembers:{description:"Maximum number of members that can exist in the system. If `None`, then the count members are not bound on a system wide basis"},MaxPoolMembersPerPool:{description:"Maximum number of members that may belong to pool. If `None`, then the count of members is not bound on a per pool basis"},MaxPools:{description:"Maximum number of nomination pools that can exist. If `None`, then an unbounded number of pools can exist"},Metadata:{description:"Metadata for the pool"},MinCreateBond:{description:"Minimum bond required to create a pool"},MinJoinBond:{description:"Minimum amount to bond to join a pool"},PoolMembers:{description:"Active members"},ReversePoolIdLookup:{description:"A reverse lookup from the pool's account id to its id"},RewardPools:{description:"Reward pools. This is where there rewards for each pool accumulate. When a members payout is claimed, the balance comes out fo the reward pool. Keyed by the bonded pools account"},SubPoolsStorage:{description:"Groups of unbonding pools. Each group of unbonding pools belongs to a bonded pool, hence the name sub-pools. Keyed by the bonded pools account"}},Offences:{ConcurrentReportsIndex:{description:"A vector of reports of the same kind that happened at the same time slot"},Reports:{description:"The primary structure that holds all offence records keyed by report identifiers"},ReportsBy:{KindIndex:{description:"Enumerates all reports of a kind along with the time they happened"}}},Preimage:{PreimageFor:{description:"The preimages stored by this pallet"},StatusFor:{description:"The request status of a given hash"}},Proxy:{Announcements:{description:"The announcements made by the proxy (key)"},Proxies:{description:"The set of account proxies. Maps the account which has delegated to the accounts which are being delegated to, together with the amount held on deposit"}},RandomnessCollectiveFlip:{RandomMaterial:{description:"Series of block headers from the last 81 blocks that acts as random seed material. This is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of the oldest hash"}},RankedCollective:{IdToIndex:{description:"The index of each ranks's member into the group of members who have at least that rank"},IndexToId:{description:"The members in the collective by index. All indices in the range `0..MemberCount` will return `Some`, however a member's index is not guaranteed to remain unchanged over time"},MemberCount:{description:"The number of members in the collective who have at least the rank according to the index of the vec"},Members:{description:"The current members of the collective"},Voting:{description:"Votes on a given proposal, if it is ongoing"}},RankedPolls:{DecidingCount:{description:"The number of referenda being decided currently"},ReferendumCount:{description:"The next free referendum index, aka the number of referenda started so far"},ReferendumInfoFor:{description:"Information concerning any given referendum"},TrackQueue:{description:"The sorted list of referenda ready to be decided but not yet being decided, ordered by conviction-weighted approvals"}},Recovery:{ActiveRecoveries:{description:"Active recovery attempts"},Proxy:{description:"The list of allowed proxy accounts"},Recoverable:{description:"The set of recoverable accounts and their recovery configuration"}},Referenda:{DecidingCount:{description:"The number of referenda being decided currently"},ReferendumCount:{description:"The next free referendum index, aka the number of referenda started so far"},ReferendumInfoFor:{description:"Information concerning any given referendum"},TrackQueue:{description:"The sorted list of referenda ready to be decided but not yet being decided, ordered by conviction-weighted approvals"}},Scheduler:{Agenda:{description:"Items to be executed, indexed by the block number that they should be executed on"},Lookup:{description:"Lookup from identity to the block number and index of the task"}},Session:{CurrentIndex:{description:"Current index of the session"},DisabledValidators:{description:"Indices of disabled validators"},KeyOwner:{description:"The owner of a key. The key is the `KeyTypeId` + the encoded key"},NextKeys:{description:"The next session keys for a validator"},QueuedChanged:{description:"True if the underlying economic identities or weighting behind the validators has changed in the queued validator set"},QueuedKeys:{description:"The queued keys for the next session. When the next session begins, these keys will be used to determine the validator's session keys"},Validators:{description:"The current set of validators"}},Society:{Bids:{description:"The current bids, stored ordered by the value of the bid"},Candidates:{description:"The current set of candidates; bidders that are attempting to become members"},Defender:{description:"The defending member currently being challenged"},DefenderVotes:{description:"Votes for the defender"},Founder:{description:"The first member"},Head:{description:"The most primary from the most recently approved members"},MaxMembers:{description:"The max number of members for the society at one time"},Members:{description:"The current set of members, ordered"},Payouts:{description:"Pending payouts; ordered by block number, with the amount that should be paid out"},Pot:{description:"Amount of our account balance that is specifically for the next round's bid(s)"},Rules:{description:"A hash of the rules of this society concerning membership. Can only be set once and only by the founder"},Strikes:{description:"The ongoing number of losing votes cast by the member"},SuspendedCandidates:{description:"The set of suspended candidates"},SuspendedMembers:{description:"The set of suspended members"},Votes:{description:"Double map from Candidate -> Voter -> (Maybe) Vote"},Vouching:{description:"Members currently vouching or banned from vouching again"}},Staking:{ActiveEra:{description:"The active era information, it holds index and start"},Bonded:{description:'Map from all locked "stash" accounts to the controller account'},BondedEras:{description:"A mapping from still-bonded eras to the first session index of that era"},CanceledSlashPayout:{description:"The amount of currency given to reporters of a slash event which was canceled by extraordinary circumstances (e.g. governance)"},ChillThreshold:{description:"The threshold for when users can start calling `chill_other` for other validators / nominators. The threshold is compared to the actual number of validators / nominators (`CountFor*`) in the system compared to the configured max (`Max*Count`)"},CounterForNominators:{description:"Counter for the related counted storage map"},CounterForValidators:{description:"Counter for the related counted storage map"},CurrentEra:{description:"The current era index"},CurrentPlannedSession:{description:"The last planned session scheduled by the session pallet"},ErasRewardPoints:{description:"Rewards for the last `HISTORY_DEPTH` eras. If reward hasn't been set or has been removed then 0 reward is returned"},ErasStakers:{description:"Exposure of validator at era"},ErasStakersClipped:{description:"Clipped Exposure of validator at era"},ErasStartSessionIndex:{description:"The session index at which the era start for the last `HISTORY_DEPTH` eras"},ErasTotalStake:{description:"The total amount staked for the last `HISTORY_DEPTH` eras. If total hasn't been set or has been removed then 0 stake is returned"},ErasValidatorPrefs:{description:"Similar to `ErasStakers`, this holds the preferences of validators"},ErasValidatorReward:{description:"The total validator era payout for the last `HISTORY_DEPTH` eras"},ForceEra:{description:"Mode of era forcing"},HistoryDepth:{description:"Number of eras to keep in history"},Invulnerables:{description:"Any validators that may never be slashed or forcibly kicked. It's a Vec since they're easy to initialize and the performance hit is minimal (we expect no more than four invulnerables) and restricted to testnets"},Ledger:{description:'Map from all (unlocked) "controller" accounts to the info regarding the staking'},MaxNominatorsCount:{description:"The maximum nominator count before we stop allowing new validators to join"},MaxValidatorsCount:{description:"The maximum validator count before we stop allowing new validators to join"},MinCommission:{description:"The minimum amount of commission that validators can set"},MinimumValidatorCount:{description:"Minimum number of staking participants before emergency conditions are imposed"},MinNominatorBond:{description:"The minimum active bond to become and maintain the role of a nominator"},MinValidatorBond:{description:"The minimum active bond to become and maintain the role of a validator"},Nominators:{description:"The map from nominator stash key to their nomination preferences, namely the validators that they wish to support"},NominatorSlashInEra:{description:"All slashing events on nominators, mapped by era to the highest slash value of the era"},OffendingValidators:{description:"Indices of validators that have offended in the active era and whether they are currently disabled"},Payee:{description:"Where the reward payment should be made. Keyed by stash"},SlashingSpans:{description:"Slashing spans for stash accounts"},SlashRewardFraction:{description:"The percentage of the slash that is distributed to reporters"},SpanSlash:{description:"Records information about the maximum slash of a stash within a slashing span, as well as how much reward has been paid out"},StorageVersion:{description:"True if network has been upgraded to this version. Storage version of the pallet"},UnappliedSlashes:{description:"All unapplied slashes that are queued for later"},ValidatorCount:{description:"The ideal number of staking participants"},Validators:{description:"The map from (wannabe) validator stash key to the preferences of that validator"},ValidatorSlashInEra:{description:"All slashing events on validators, mapped by era to the highest slash proportion and slash value of the era"}},StateTrieMigration:{AutoLimits:{description:"The limits that are imposed on automatic migrations"},MigrationProcess:{description:"Migration progress"},SignedMigrationMaxLimits:{description:"The maximum limits that the signed migration could use"}},Substrate:{ChangesTrieConfig:{description:"Changes trie configuration is stored under this key"},ChildStorageKeyPrefix:{description:"Prefix of child storage keys"},Code:{description:"Wasm code of the runtime"},ExtrinsicIndex:{description:"Current extrinsic index (u32) is stored under this key"},HeapPages:{description:"Number of wasm linear memory pages required for execution of the runtime"}},Sudo:{Key:{description:"The `AccountId` of the sudo key"}},System:{Account:{description:"The full account information for a particular account ID"},AllExtrinsicsLen:{description:"Total length (in bytes) for all extrinsics put together, for the current block"},BlockHash:{description:"Map of block numbers to block hashes"},BlockWeight:{description:"The current weight for the block"},Digest:{description:"Digest of the current block, also part of the block header"},EventCount:{description:"The number of events in the `Events<T>` list"},Events:{description:"Events deposited for the current block"},EventTopics:{description:"Mapping between a topic (represented by T::Hash) and a vector of indexes of events in the `<Events<T>>` list"},ExecutionPhase:{description:"The execution phase of the block"},ExtrinsicCount:{description:"Total extrinsics count for the current block"},ExtrinsicData:{description:"Extrinsics data for the current block (maps an extrinsic's index to its data)"},LastRuntimeUpgrade:{description:"Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened"},Number:{description:"The current block number being processed. Set by `execute_block`"},ParentHash:{description:"Hash of the previous block"},UpgradedToTripleRefCount:{description:"True if we have upgraded so that AccountInfo contains three types of `RefCount`. False (default) if not"},UpgradedToU32RefCount:{description:"True if we have upgraded so that `type RefCount` is `u32`. False (default) if not"}},TechnicalCommittee:{Members:{description:"The current members of the collective. This is stored sorted (just by value)"},Prime:{description:"The prime member that helps determine the default vote behavior in case of absentations"},ProposalCount:{description:"Proposals so far"},ProposalOf:{description:"Actual proposal for a given hash, if it's current"},Proposals:{description:"The hashes of the active proposals"},Voting:{description:"Votes on a given proposal, if it is ongoing"}},TechnicalMembership:{Members:{description:"The current membership, stored as an ordered Vec"},Prime:{description:"The current prime member, if one exists"}},Timestamp:{DidUpdate:{description:"Did the timestamp get updated in this block?"},Now:{description:"Current time for the current block"}},Tips:{Reasons:{description:"Simple preimage lookup from the reason's hash to the original data. Again, has an insecure enumerable hash since the key is guaranteed to be the result of a secure hash"},Tips:{description:"TipsMap that are not yet completed. Keyed by the hash of `(reason, who)` from the value. This has the insecure enumerable hash function since the key itself is already guaranteed to be a secure hash"}},TransactionStorage:{ByteFee:{description:"Storage fee per byte"},ChunkCount:{description:"Count indexed chunks for each block"},EntryFee:{description:"Storage fee per transaction"},ProofChecked:{description:"Was the proof checked in this block?"},StoragePeriod:{description:"Storage period for data in blocks. Should match `sp_storage_proof::DEFAULT_STORAGE_PERIOD` for block authoring"},Transactions:{description:"Collection of transaction metadata by block number"}},Treasury:{Approvals:{description:"Proposal indices that have been approved but not yet awarded"},ProposalCount:{description:"Number of proposals that have been made"},Proposals:{description:"Proposals that have been made"}},Uniques:{Account:{description:"The items held by any given account; set out this way so that items owned by a single account can be enumerated"},Asset:{description:"The items in existence and their ownership details"},Attribute:{description:"Attributes of a collection"},Class:{description:"Details of a collection"},ClassAccount:{description:"The collections owned by any given account; set out this way so that collections owned by a single account can be enumerated"},ClassMetadataOf:{description:"Metadata of a collection"},CollectionMaxSupply:{description:"Keeps track of the number of items a collection might have"},InstanceMetadataOf:{description:"Metadata of an item"},ItemPriceOf:{description:"Price of an asset instance"},NextCollectionId:{description:"Stores the `CollectionId` that is going to be used for the next collection. This gets incremented by 1 whenever a new collection is created"},OwnershipAcceptance:{description:"The collection, if any, of which an account is willing to take ownership"}},Vesting:{StorageVersion:{description:"Storage version of the pallet"},Vesting:{description:"Information regarding the vesting of a given account"}}}}})}("undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:this,"undefined"!=typeof module?module:{exports:this});
//# sourceMappingURL=nodes-polkadotjs.sf.mjs.map