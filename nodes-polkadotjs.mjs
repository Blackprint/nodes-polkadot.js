/* MIT Licensed */
"use strict";var _class,_class2,_class3,_class4,_class5,_class6,_class7,_class8,_class9,_class10,_class11,_class12,_class13,_class14,_class15,_class16,_class17,_class18,_class19,_class20,_class21,_class22,_class23;if(void 0===window)var window=globalThis;async function imports(t){return"undefined"!=typeof sf&&void 0!==sf.loader?await sf.loader.mjs(t):Promise.all(t.map((t=>import(t))))}imports.task=function(){return"undefined"!=typeof sf&&void 0!==sf.loader?sf.loader.task:null};var polkadotApi,polkadotKeyring,polkadotTypes,polkadotUtilCrypto,polkadotUtil,polkadotExtensionDapp,Blackprint=window.Blackprint.loadScope({url:import.meta.url,hasInterface:!0,hasDocs:!0});let crypto=window.crypto;if(!1===Blackprint.Environment.loadFromURL)if(Blackprint.Environment.isNode){crypto=(await import("node:crypto")).webcrypto,window.addEventListener??=()=>{};try{polkadotUtil=await import("@polkadot/util"),polkadotUtilCrypto=await import("@polkadot/util-crypto"),polkadotKeyring=await import("@polkadot/keyring"),polkadotTypes=await import("@polkadot/types"),polkadotApi=await import("@polkadot/api")}catch(t){console.log(t),setTimeout((()=>process.exit()),500)}}else{let t="file:///"+process.cwd();await import(t+"/node_modules/@polkadot/util/bundle-polkadot-util.js"),await import(t+"/node_modules/@polkadot/util-crypto/bundle-polkadot-util-crypto.js"),await import(t+"/node_modules/@polkadot/keyring/bundle-polkadot-keyring.js"),await import(t+"/node_modules/@polkadot/types/bundle-polkadot-types.js"),await import(t+"/node_modules/@polkadot/api/bundle-polkadot-api.js"),Blackprint.Environment.isBrowser&&await import(t+"/node_modules/@polkadot/extension-dapp/bundle-polkadot-extension-dapp.js"),({polkadotApi:polkadotApi,polkadotKeyring:polkadotKeyring,polkadotTypes:polkadotTypes,polkadotUtilCrypto:polkadotUtilCrypto,polkadotUtil:polkadotUtil,polkadotExtensionDapp:polkadotExtensionDapp}=window)}else{let t=["https://cdn.jsdelivr.net/npm/@polkadot/util@^12/bundle-polkadot-util.min.js","https://cdn.jsdelivr.net/npm/@polkadot/util-crypto@^12/bundle-polkadot-util-crypto.min.js","https://cdn.jsdelivr.net/npm/@polkadot/keyring@^12/bundle-polkadot-keyring.min.js","https://cdn.jsdelivr.net/npm/@polkadot/types@^10/bundle-polkadot-types.min.js","https://cdn.jsdelivr.net/npm/@polkadot/api@^10/bundle-polkadot-api.min.js"];if(window.Blackprint.Environment.isBrowser&&t.push("https://cdn.jsdelivr.net/npm/@polkadot/extension-dapp@^0.46/bundle-polkadot-extension-dapp.min.js"),null!=window.sf?.loader)await sf.loader.js(t,{ordered:!0});else for(var i=0;i<t.length;i++)await import(t[i]);({polkadotApi:polkadotApi,polkadotKeyring:polkadotKeyring,polkadotTypes:polkadotTypes,polkadotUtilCrypto:polkadotUtilCrypto,polkadotUtil:polkadotUtil,polkadotExtensionDapp:polkadotExtensionDapp}=window)}var Context=Blackprint.createContext("Polkadot.js");Context.EventSlot={slot:"my-private-event-slot"},Context._internalKeyring=new polkadotApi.Keyring({type:"ed25519",ss58Format:0});class Transaction{constructor(t,e,n){this.txn=t,this.api=e,this.isBatch=n}}class Signer{constructor(t,e,n){this.isPair=t,this.address=e,this.signer=n}}Blackprint.utils.renameTypeName({Transaction:Transaction,Signer:Signer,ApiPromise:polkadotApi.ApiPromise,Keyring:polkadotApi.Keyring,WsProvider:polkadotApi.WsProvider,HttpProvider:polkadotApi.HttpProvider});let _extensionEnabled,NodeToast=Context.NodeToast=class{constructor(t){this.iface=t}clear(){this.haveInfo&&this.haveInfo.destroy(),this.haveWarn&&this.haveWarn.destroy(),this.haveError&&this.haveError.destroy(),this.haveInfo=!1,this.haveWarn=!1,this.haveError=!1}_reduceText(t){return t.replace(/\w{15,}/g,(t=>t.slice(0,5)+"..."))}info(t){if(!this.iface.$decoration)return;let e=t;t=this._reduceText(t),this.haveInfo?this.haveInfo.text=t:this.haveInfo=this.iface.$decoration.info(t),this.haveInfo._raw=e}warn(t){if(!this.iface.$decoration)return;let e=t;t=this._reduceText(t),this.haveWarn?this.haveWarn.text=t:this.haveWarn=this.iface.$decoration.warn(t),this.haveWarn._raw=e}error(t){if(!this.iface.$decoration)return;let e=t;t=this._reduceText(t),this.haveError?this.haveError.text=t:this.haveError=this.iface.$decoration.error(t),this.haveError._raw=e}success(t){if(!this.iface.$decoration)return;this.iface.$decoration.success(this._reduceText(t))._raw=t}},SubstrateMetadata=!0,SubstrateSubscriber={SubmitAndWatchExtrinsic:"author",Subscribe:"eth",SubscribeAllHeads:"chain",SubscribeFinalizedHeads:"chain",SubscribeJustifications:"grandpa",SubscribeNewHeads:"chain",SubscribeRuntimeVersion:"state",SubscribeStorage:"state"},TypeAny=Blackprint.Types.Any,SubstrateTypeData={AccountId:String,ApplyExtrinsicResult:TypeAny,BeefySignedCommitment:TypeAny,BlockHash:TypeAny,BlockNumber:Number,Bytes:String,ChainProperties:TypeAny,ChainType:TypeAny,ContractCallRequest:TypeAny,ContractExecResult:TypeAny,ContractInstantiateResult:TypeAny,CreatedBlock:TypeAny,EthAccount:TypeAny,EthCallRequest:TypeAny,EthFilter:TypeAny,EthFilterChanges:TypeAny,EthLog:TypeAny,EthReceipt:TypeAny,EthRichBlock:TypeAny,EthSubKind:TypeAny,EthSubParams:TypeAny,EthSyncStatus:TypeAny,EthTransaction:TypeAny,EthTransactionRequest:TypeAny,EthWork:TypeAny,Extrinsic:TypeAny,ExtrinsicOrHash:TypeAny,ExtrinsicStatus:TypeAny,FeeDetails:TypeAny,H64:String,H160:String,H256:String,Hash:String,"HashMap<AuthorityId,EpochAuthorship>":TypeAny,Header:TypeAny,EncodedFinalityProofs:TypeAny,Health:TypeAny,Index:TypeAny,InstantiateRequest:TypeAny,Json:TypeAny,Justification:TypeAny,JustificationNotification:TypeAny,KeyValue:Object,Metadata:TypeAny,MmrLeafProof:TypeAny,NetworkState:TypeAny,NodeRole:TypeAny,Null:TypeAny,PeerInfo:TypeAny,PrefixedStorageKey:TypeAny,ReadProof:TypeAny,ReportedRoundStates:TypeAny,RpcMethods:TypeAny,RuntimeDispatchInfo:TypeAny,RuntimeVersion:TypeAny,SignedBlock:TypeAny,StorageChangeSet:TypeAny,StorageData:TypeAny,StorageKey:TypeAny,StorageKind:TypeAny,String:String,SyncState:TypeAny,Text:String,TraceBlockResponse:TypeAny,U64:Number,U256:Number,bool:Boolean,u32:Number,u64:Number};function functionParser(t,e){let n=t.trim().replace(/\t+| /g,"").split("\n");for(var a=0;a<n.length;a++){let t,s,r,i=n[a];e.isExtrinsics&&(i+=":Null"),e.isConst&&(i=i.replace(":","():")),[i,r]=i.split("):"),[t,s]=i.split("("),void 0===s&&console.error(`Incorrect format "${i}", `);let c=[];if(e.typeAsName)try{c=s.split(","),s=c.join(";;")}catch(t){console.error(`Incorrect format "${i}", `,t)}else s=s.replace(/,?([a-zA-Z0-9_?]+):/g,(function(t,e){return c.push(e),";;"})).replace(/^;;/m,"");let u={};if(""!==s){s=s.split(";;");for(var o=0;o<s.length;o++){let t=c[o];t=t.slice(0,1).toUpperCase()+t.slice(1),s[o]=s[o].replace(/^Option<(.*?)>$/m,((e,n)=>(t+="?",n))),u[t]=s[o]}}let l=!1;r=r.replace(/Option<(.*?)>$/m,((t,e)=>(l=!0,e))),r=r.replace(/(Vec|HashMap)<(.*?)>$/m,fillLooseType);for(let t in u)u[t]=u[t].replace(/(Vec|HashMap)<(.*?)>$/m,fillLooseType);n[a]={name:t.slice(0,1).toUpperCase()+t.slice(1),args:u,returnType:r,optionalReturn:l}}return n}function fillLooseType(t,e,n){return null!=SubstrateTypeData[n]||"HashMap"===e&&(SubstrateTypeData[n]=Object),n}function Substrate_BlackprintNodeGenerator(t,e){if(!1===SubstrateMetadata)return;let{namespace:n,description:a,apiPath:o,isConst:s,isExtrinsics:r}=t;for(var i=0;i<e.length;i++){let u=e[i],l=functionParser(u.funcs,t);t:for(var c=0;c<l.length;c++){let e=l[c];if(/subscribe|watch/i.test(e.name)&&!t.loose){void 0===SubstrateSubscriber[e.name]&&console.error(`Substrate subscriber for "${e.name}" was not found`);continue}if(void 0===SubstrateTypeData[e.returnType]&&!t.loose){console.error(`Substrate type data for "${e.returnType}" was not found`);continue}let i=e.returnType,p=TypeAny;if("Null"!==e.returnType){let n=e.returnType.replace(/(Vec|HashMap)<(.*?)>$/m,(function(t,e,n){return n}));t.loose&&void 0===SubstrateTypeData[e.returnType]&&(SubstrateTypeData[e.returnType]=TypeAny),p=SubstrateTypeData[e.returnType],p!==Number&&p!==String&&p!==Boolean&&(p=TypeAny),null==p&&(p=TypeAny),e.optionalReturn&&(n+="?"),e.returnType={[n]:SubstrateTypeData[e.returnType]},i=n}else e.returnType=void 0;r&&(e.returnType={Finished:Blackprint.Types.Trigger});let d=e.args,h=Object.keys(d);for(let e in d){let n=d[e];if(t.loose&&void 0===SubstrateTypeData[n]&&(SubstrateTypeData[n]=TypeAny),void 0===SubstrateTypeData[n]){console.error(`Substrate type data for "${n}" was not found`);continue t}d[e]=SubstrateTypeData[n]}let m=e.name.replace(/By([A-Z].*)/,(function(t,e){return"By/"+e})).replace(/^(Get|Set|Has|New)([A-Z].*)/,(function(t,e,n){return e+"/"+n})),y=e.name.slice(0,1).toLowerCase()+e.name.slice(1),g={API:polkadotApi.ApiPromise,Trigger:Blackprint.Port.Trigger((function({iface:t}){t.node.trigger()}))};if(s&&delete g.Trigger,e.optionalReturn){let t={};for(let n in e.returnType)t[n.replace("?","")]=e.returnType[n];e.returnType=t}class f extends Blackprint.Node{constructor(t){super(t);let n=this.setInterface();n.title=`${u.name} ${e.name}`,n.description=a,this._toast=new NodeToast(n)}update(){let{Input:t,Output:e}=this.ref;if(this._toast.clear(),null!=t.API){if(null==t.API[o][u.rpc_path]?.[y])return void this._toast.error("This network doesn't support this feature")}else r||(e[i]=null);s&&this.trigger()}async trigger(){let{Input:t,Output:e}=this.ref,n=this._toast;if(null===t.API)return n.warn("API is required");let a=t.API[o][u.rpc_path];if(null==a)return n.error("This network doesn't support this feature");let c=[];for(var l=0;l<h.length;l++)c.push(t[h[l]]);try{var d=s?a[y]:await a[y].apply(a,c)}catch(t){return e[i]=null,void n.error(t.message)}r?e.OnFinish():(p!==TypeAny&&(d=p(d)),void 0!==d.value&&(d=d.value),e[i]=d)}}f.skipSuggestTypeAny=!0,f.isGenerated=!0,f.output=e.returnType,f.input=Object.assign(g,d),Blackprint.registerNode(`Polkadot.js/${n}/${u.name}/${m}`,f)}}}Substrate_BlackprintNodeGenerator({namespace:"RPC",description:"[Experimental] Substrate JSON-RPC",apiPath:"rpc"},[{name:"Author",rpc_path:"author",funcs:"\n\t\t\thasKey(publicKey: Bytes, keyType: Text): bool\n\t\t\thasSessionKeys(sessionKeys: Bytes): bool\n\t\t\tinsertKey(keyType: Text, suri: Text, publicKey: Bytes): Bytes\n\t\t\tpendingExtrinsics(): Vec<Extrinsic>\n\t\t\tremoveExtrinsic(bytesOrHash: Vec<ExtrinsicOrHash>): Vec<Hash>\n\t\t\trotateKeys(): Bytes\n\t\t\tsubmitAndWatchExtrinsic(extrinsic: Extrinsic): ExtrinsicStatus\n\t\t\tsubmitExtrinsic(extrinsic: Extrinsic): Hash\n\t\t"},{name:"Babe",rpc_path:"babe",funcs:"\n\t\t\tepochAuthorship(): HashMap<AuthorityId, EpochAuthorship>\n\t\t"},{name:"Beefy",rpc_path:"beefy",funcs:"\n\t\t\tsubscribeJustifications(): BeefySignedCommitment\n\t\t"},{name:"Chain",rpc_path:"chain",funcs:"\n\t\t\tgetBlock(hash?: BlockHash): SignedBlock\n\t\t\tgetBlockHash(blockNumber?: BlockNumber): BlockHash\n\t\t\tgetFinalizedHead(): BlockHash\n\t\t\tgetHeader(hash?: BlockHash): Header\n\t\t\tsubscribeAllHeads(): Header\n\t\t\tsubscribeFinalizedHeads(): Header\n\t\t\tsubscribeNewHeads(): Header\n\t\t"},{name:"ChildState",rpc_path:"childstate",funcs:"\n\t\t\tgetKeys(childKey: PrefixedStorageKey, prefix: StorageKey, at?: Hash): Vec<StorageKey>\n\t\t\tgetKeysPaged(childKey: PrefixedStorageKey, prefix: StorageKey, count: u32, startKey?: StorageKey, at?: Hash): Vec<StorageKey>\n\t\t\tgetStorage(childKey: PrefixedStorageKey, key: StorageKey, at?: Hash): Option<StorageData>\n\t\t\tgetStorageEntries(childKey: PrefixedStorageKey, keys: Vec<StorageKey>, at?: Hash): Vec<Option<StorageData>>\n\t\t\tgetStorageHash(childKey: PrefixedStorageKey, key: StorageKey, at?: Hash): Option<Hash>\n\t\t\tgetStorageSize(childKey: PrefixedStorageKey, key: StorageKey, at?: Hash): Option<u64>\n\t\t"},{name:"Contracts",rpc_path:"contracts",funcs:"\n\t\t\tcall(callRequest: ContractCallRequest, at?: BlockHash): ContractExecResult\n\t\t\tgetStorage(address: AccountId, key: H256, at?: BlockHash): Option<Bytes>\n\t\t\tinstantiate(request: InstantiateRequest, at?: BlockHash): ContractInstantiateResult\n\t\t\trentProjection(address: AccountId, at?: BlockHash): Option<BlockNumber>\n\t\t"},{name:"Engine",rpc_path:"engine",funcs:"\n\t\t\tcreateBlock(createEmpty: bool, finalize: bool, parentHash?: BlockHash): CreatedBlock\n\t\t\tfinalizeBlock(hash: BlockHash, justification?: Justification): bool\n\t\t"},{name:"Eth",rpc_path:"eth",funcs:"\n\t\t\taccounts(): Vec<H160>\n\t\t\tblockNumber(): U256\n\t\t\tcall(request: EthCallRequest, number?: BlockNumber): Bytes\n\t\t\tchainId(): U64\n\t\t\tcoinbase(): H160\n\t\t\testimateGas(request: EthCallRequest, number?: BlockNumber): U256\n\t\t\tgasPrice(): U256\n\t\t\tgetBalance(address: H160, number?: BlockNumber): U256\n\t\t\tgetBlockByHash(hash: H256, full: bool): Option<EthRichBlock>\n\t\t\tgetBlockByNumber(block: BlockNumber, full: bool): Option<EthRichBlock>\n\t\t\tgetBlockTransactionCountByHash(hash: H256): U256\n\t\t\tgetBlockTransactionCountByNumber(block: BlockNumber): U256\n\t\t\tgetCode(address: H160, number?: BlockNumber): Bytes\n\t\t\tgetFilterChanges(index: U256): EthFilterChanges\n\t\t\tgetFilterLogs(index: U256): Vec<EthLog>\n\t\t\tgetLogs(filter: EthFilter): Vec<EthLog>\n\t\t\tgetProof(address: H160, storageKeys: Vec<H256>, number: BlockNumber): EthAccount\n\t\t\tgetStorageAt(address: H160, index: U256, number?: BlockNumber): H256\n\t\t\tgetTransactionByBlockHashAndIndex(hash: H256, index: U256): EthTransaction\n\t\t\tgetTransactionByBlockNumberAndIndex(number: BlockNumber, index: U256): EthTransaction\n\t\t\tgetTransactionByHash(hash: H256): EthTransaction\n\t\t\tgetTransactionCount(hash: H256, number?: BlockNumber): U256\n\t\t\tgetTransactionReceipt(hash: H256): EthReceipt\n\t\t\tgetUncleByBlockHashAndIndex(hash: H256, index: U256): EthRichBlock\n\t\t\tgetUncleByBlockNumberAndIndex(number: BlockNumber, index: U256): EthRichBlock\n\t\t\tgetUncleCountByBlockHash(hash: H256): U256\n\t\t\tgetUncleCountByBlockNumber(number: BlockNumber): U256\n\t\t\tgetWork(): EthWork\n\t\t\thashrate(): U256\n\t\t\tmining(): bool\n\t\t\tnewBlockFilter(): U256\n\t\t\tnewFilter(filter: EthFilter): U256\n\t\t\tnewPendingTransactionFilter(): U256\n\t\t\tprotocolVersion(): u64\n\t\t\tsendRawTransaction(bytes: Bytes): H256\n\t\t\tsendTransaction(tx: EthTransactionRequest): H256\n\t\t\tsubmitHashrate(index: U256, hash: H256): bool\n\t\t\tsubmitWork(nonce: H64, headerHash: H256, mixDigest: H256): bool\n\t\t\tsubscribe(kind: EthSubKind, params?: EthSubParams): Null\n\t\t\tsyncing(): EthSyncStatus\n\t\t\tuninstallFilter(index: U256): bool\n\t\t"},{name:"Net",rpc_path:"net",funcs:"\n\t\t\tlistening(): bool\n\t\t\tpeerCount(): String\n\t\t\tversion(): String\n\t\t"},{name:"Web3",rpc_path:"web3",funcs:"\n\t\t\tclientVersion(): String\n\t\t\tsha3(data: Bytes): H256\n\t\t"},{name:"Grandpa",rpc_path:"grandpa",funcs:"\n\t\t\tproveFinality(begin: BlockHash, end: BlockHash, authoritiesSetId?: u64): Option<EncodedFinalityProofs>\n\t\t\troundState(): ReportedRoundStates\n\t\t\tsubscribeJustifications(): JustificationNotification\n\t\t"},{name:"Mmr",rpc_path:"mmr",funcs:"\n\t\t\tgenerateProof(leafIndex: u64, at?: BlockHash): MmrLeafProof\n\t\t"},{name:"OffChain",rpc_path:"offchain",funcs:"\n\t\t\tlocalStorageGet(kind: StorageKind, key: Bytes): Option<Bytes>\n\t\t\tlocalStorageSet(kind: StorageKind, key: Bytes, value: Bytes): Null\n\t\t"},{name:"Payment",rpc_path:"payment",funcs:"\n\t\t\tqueryFeeDetails(extrinsic: Bytes, at?: BlockHash): FeeDetails\n\t\t\tqueryInfo(extrinsic: Bytes, at?: BlockHash): RuntimeDispatchInfo\n\t\t"},{name:"RPC",rpc_path:"rpc",funcs:"\n\t\t\tmethods(): RpcMethods\n\t\t"},{name:"State",rpc_path:"state",funcs:"\n\t\t\tcall(method: Text, data: Bytes, at?: BlockHash): Bytes\n\t\t\tgetChildKeys(childStorageKey: StorageKey, childDefinition: StorageKey, childType: u32, key: StorageKey, at?: BlockHash): Vec<StorageKey>\n\t\t\tgetChildReadProof(childStorageKey: PrefixedStorageKey, keys: Vec<StorageKey>, at?: BlockHash): ReadProof\n\t\t\tgetChildStorage(childStorageKey: StorageKey, childDefinition: StorageKey, childType: u32, key: StorageKey, at?: BlockHash): StorageData\n\t\t\tgetChildStorageHash(childStorageKey: StorageKey, childDefinition: StorageKey, childType: u32, key: StorageKey, at?: BlockHash): Hash\n\t\t\tgetChildStorageSize(childStorageKey: StorageKey, childDefinition: StorageKey, childType: u32, key: StorageKey, at?: BlockHash): u64\n\t\t\tgetKeys(key: StorageKey, at?: BlockHash): Vec<StorageKey>\n\t\t\tgetKeysPaged(key: StorageKey, count: u32, startKey?: StorageKey, at?: BlockHash): Vec<StorageKey>\n\t\t\tgetMetadata(at?: BlockHash): Metadata\n\t\t\tgetPairs(prefix: StorageKey, at?: BlockHash): Vec<KeyValue>\n\t\t\tgetReadProof(keys: Vec<StorageKey>, at?: BlockHash): ReadProof\n\t\t\tgetRuntimeVersion(at?: BlockHash): RuntimeVersion\n\t\t\tgetStorage(key: StorageKey, at?: BlockHash): StorageData\n\t\t\tgetStorageHash(key: StorageKey, at?: BlockHash): Hash\n\t\t\tgetStorageSize(key: StorageKey, at?: BlockHash): u64\n\t\t\tqueryStorage(keys: Vec<StorageKey>, fromBlock: Hash, toBlock?: BlockHash): Vec<StorageChangeSet>\n\t\t\tqueryStorageAt(keys: Vec<StorageKey>, at?: BlockHash): Vec<StorageChangeSet>\n\t\t\tsubscribeRuntimeVersion(): RuntimeVersion\n\t\t\tsubscribeStorage(keys?: Vec<StorageKey>): StorageChangeSet\n\t\t\ttraceBlock(block: Hash, targets: Option<Text>, storageKeys: Option<Text>, methods: Option<Text>): TraceBlockResponse\n\t\t"},{name:"SyncState",rpc_path:"syncstate",funcs:"\n\t\t\tgenSyncSpec(raw: bool): Json\n\t\t"},{name:"System",rpc_path:"system",funcs:"\n\t\t\taccountNextIndex(accountId: AccountId): Index\n\t\t\taddLogFilter(directives: Text): Null\n\t\t\taddReservedPeer(peer: Text): Text\n\t\t\tchain(): Text\n\t\t\tchainType(): ChainType\n\t\t\tdryRun(extrinsic: Bytes, at?: BlockHash): ApplyExtrinsicResult\n\t\t\thealth(): Health\n\t\t\tlocalListenAddresses(): Vec<Text>\n\t\t\tlocalPeerId(): Text\n\t\t\tname(): Text\n\t\t\tnetworkState(): NetworkState\n\t\t\tnodeRoles(): Vec<NodeRole>\n\t\t\tpeers(): Vec<PeerInfo>\n\t\t\tproperties(): ChainProperties\n\t\t\tremoveReservedPeer(peerId: Text): Text\n\t\t\treservedPeers(): Vec<Text>\n\t\t\tresetLogFilter(): Null\n\t\t\tsyncState(): SyncState\n\t\t\tversion(): Text\n\t\t"}]),Context._extensionEnabled=new Promise((t=>_extensionEnabled=t));class ConnectionExtensionData{constructor(t){this._dAppName="BP-Polkadot.js",this._iface=t}get dAppName(){return this._dAppName}set dAppName(t){this._dAppName=t,this._iface.node.syncOut("dAppName",t)}}Blackprint.utils.setEnumerablePrototype(ConnectionExtensionData,{dAppName:!0}),Blackprint.registerNode("Polkadot.js/Connection/Extension",((_class=class extends Blackprint.Node{constructor(t){super(t),this.setInterface("BPIC/Polkadot.js/Connection/Extension").title="Browser Wallet"}imported(t){t&&Object.assign(this.iface.data,t)}syncIn(t,e){"dAppName"===t&&(this.iface.data.dAppName=e)}}).input={ExtensionId:Blackprint.Port.Default(String,"polkadot-js"),Connect:Blackprint.Port.Trigger((function({iface:t}){t.connectExtension()}))},_class.output={Accounts:Array,IsAllowed:Boolean},_class)),Blackprint.registerInterface("BPIC/Polkadot.js/Connection/Extension",Context.IFace.ConnectionExtension=class extends Blackprint.Interface{constructor(t){super(t),this.data=new ConnectionExtensionData(this),this._toast=new NodeToast(this),this._toast.warn("Disconnected")}async connectExtension(){let{Input:t,Output:e}=this.ref,n=this._toast;if(!t.ExtensionId)return console.error("ExtensionId is required"),n.error("ExtensionId is required");let a=window.injectedWeb3?.[t.ExtensionId];if(void 0===a)return console.error("Extension (with id: "+t.ExtensionId+") was not found"),n.error("Extension (with id: "+t.ExtensionId+") was not found");n.clear(),n.warn("Asking for Permission"),this._unsubscribe?.();try{this._polkadot=await polkadotExtensionDapp.web3Enable(this.data.dAppName)}catch(t){return console.error(t.message),n.error(t.message),void(e.IsAllowed=!1)}if(0===this._polkadot.length)return e.IsAllowed=!1,n.clear(),void n.warn("Access Rejected");n.clear(),n.success("Access Granted"),_extensionEnabled(),Context._extensionEnabled=!0,this._unsubscribe=await polkadotExtensionDapp.web3AccountsSubscribe((t=>{e.Accounts=t})),e.Accounts=await polkadotExtensionDapp.web3Accounts(),e.IsAllowed=!0}destroy(){try{this._unsubscribe?.()}catch(t){console.error(t)}}});class ConnectionHTTPData{constructor(t){this._rpcURL="",this._iface=t}get rpcURL(){return this._rpcURL}set rpcURL(t){this._rpcURL=t,this._iface.changeRPC(),this._iface.node.syncOut("rpcURL",t)}}Blackprint.utils.setEnumerablePrototype(ConnectionHTTPData,{rpcURL:!0}),Blackprint.registerNode("Polkadot.js/Connection/HTTP",((_class2=class extends Blackprint.Node{constructor(t){super(t);let e=this.setInterface("BPIC/Polkadot.js/Connection/HTTP");e.title="HTTP",e.data=new ConnectionHTTPData(e)}imported(t){t&&Object.assign(this.iface.data,t)}syncIn(t,e){"rpcURL"===t&&(this.iface.data.rpcURL=e)}destroy(){let t=this.ref.Output.Provider;void 0!==t&&(t.disconnect(),this.ref.Output.Disconnected())}}).input={Reconnect:Blackprint.Port.Trigger((function({iface:t}){t.changeRPC()}))},_class2.output={Provider:polkadotApi.HttpProvider,API:polkadotApi.ApiPromise,Connected:Blackprint.Types.Trigger,Disconnected:Blackprint.Types.Trigger},_class2)),Blackprint.registerInterface("BPIC/Polkadot.js/Connection/HTTP",Context.IFace.ConnectionHTTP=class extends Blackprint.Interface{constructor(t){super(t),this._toast=new NodeToast(this),this._toast.warn("Disconnected")}async changeRPC(){let{Output:t}=this.ref;this._toast.clear();let e=this.data.rpcURL;if(!e)return this._toast.error("RPC URL was empty");if(!/^(https|http):\/\//.test(e))return this._toast.error("The endpoint should start with http:// or https://");null!=t.Provider&&(t.Provider.disconnect(),t.Disconnected());let n=t.Provider=new polkadotApi.HttpProvider(e);this._toast.warn("Connecting...");try{var a=await polkadotApi.ApiPromise.create({provider:n,throwOnConnect:!0})}catch(e){return this._toast.warn("Connection failed"),t.API=null,void t.Disconnected()}t.API=a,n.isConnected?(this._toast.clear(),this._toast.success("Connected"),t.Connected()):(this._toast.error("Failed to connect"),t.Disconnected())}});class ConnectionWebSocketData{constructor(t){this._rpcURL="",this._iface=t}get rpcURL(){return this._rpcURL}set rpcURL(t){this._rpcURL=t,this._iface.changeRPC(),this._iface.node.syncOut("rpcURL",t)}}Blackprint.utils.setEnumerablePrototype(ConnectionWebSocketData,{rpcURL:!0}),Blackprint.registerNode("Polkadot.js/Connection/WebSocket",((_class3=class extends Blackprint.Node{constructor(t){super(t);let e=this.setInterface("BPIC/Polkadot.js/Connection/WebSocket");e.title="WebSocket",e.data=new ConnectionWebSocketData(e)}imported(t){t&&Object.assign(this.iface.data,t)}syncIn(t,e){"rpcURL"===t&&(this.iface.data.rpcURL=e)}destroy(){let t=this.ref.Output.Provider;void 0!==t&&t.disconnect()}}).input={Connect:Blackprint.Port.Trigger((function({iface:t}){t.node.output.Provider?.connect()})),Disconnect:Blackprint.Port.Trigger((function({iface:t}){t.node.output.Provider?.disconnect()}))},_class3.output={Provider:polkadotApi.WsProvider,API:polkadotApi.ApiPromise,Connected:Blackprint.Types.Trigger,Disconnected:Blackprint.Types.Trigger},_class3)),Blackprint.registerInterface("BPIC/Polkadot.js/Connection/WebSocket",Context.IFace.ConnectionWebSocket=class extends Blackprint.Interface{constructor(t){super(t),this._toast=new NodeToast(this),this._toast.warn("Disconnected")}async changeRPC(){let{Output:t}=this.ref;this._toast.clear(),t.Provider?.disconnect();let e=this.data.rpcURL;if(!e)return this._toast.error("RPC URL was empty");if(!/^(wss|ws):\/\//.test(e))return this._toast.error("The endpoint should start with ws:// or wss://");let n=t.Provider=new polkadotApi.WsProvider(e);clearTimeout(this._prepareAPIWait);let a=!1;n.on("connected",(()=>{this._toast.clear(),this._toast.success("Connected"),a||(this._toast.warn("Preparing API..."),this._prepareAPIWait=setTimeout((()=>{a||(this._toast.clear(),this._toast.error("No response from RPC"))}),6e4)),t.Connected()})),n.on("disconnected",(()=>{this._toast.warn("Disconnected"),t.Disconnected()})),this._toast.warn("Connecting..."),t.API=await polkadotApi.ApiPromise.create({provider:n}),a=!0,clearTimeout(this._prepareAPIWait),"Preparing API..."===this._toast.haveWarn.text&&this._toast.clear()}}),Substrate_BlackprintNodeGenerator({namespace:"Constants",description:"[Experimental] Substrate Constants",apiPath:"consts",loose:!0,isConst:!0},[{name:"Assets",rpc_path:"assets",funcs:"\n\t\t\tapprovalDeposit: u128\n\t\t\tassetAccountDeposit: u128\n\t\t\tassetDeposit: u128\n\t\t\tmetadataDepositBase: u128\n\t\t\tmetadataDepositPerByte: u128\n\t\t\tstringLimit: u32\n\t\t"},{name:"Authorship",rpc_path:"authorship",funcs:"\n\t\t\tuncleGenerations: u32\n\t\t"},{name:"Babe",rpc_path:"babe",funcs:"\n\t\t\tepochDuration: u64\n\t\t\texpectedBlockTime: u64\n\t\t\tmaxAuthorities: u32\n\t\t"},{name:"BagsList",rpc_path:"bagsList",funcs:"\n\t\t\tbagThresholds: Vec<u64>\n\t\t"},{name:"Balances",rpc_path:"balances",funcs:"\n\t\t\texistentialDeposit: u128\n\t\t\tmaxLocks: u32\n\t\t\tmaxReserves: u32\n\t\t"},{name:"Bounties",rpc_path:"bounties",funcs:"\n\t\t\tbountyCuratorDeposit: Permill\n\t\t\tbountyDepositBase: u128\n\t\t\tbountyDepositPayoutDelay: u32\n\t\t\tbountyUpdatePeriod: u32\n\t\t\tbountyValueMinimum: u128\n\t\t\tdataDepositPerByte: u128\n\t\t\tmaximumReasonLength: u32\n\t\t"},{name:"ChildBounties",rpc_path:"childBounties",funcs:"\n\t\t\tchildBountyCuratorDepositBase: Permill\n\t\t\tchildBountyValueMinimum: u128\n\t\t\tmaxActiveChildBountyCount: u32\n\t\t"},{name:"Contracts",rpc_path:"contracts",funcs:"\n\t\t\tdeletionQueueDepth: u32\n\t\t\tdeletionWeightLimit: u64\n\t\t\tdepositPerByte: u128\n\t\t\tdepositPerItem: u128\n\t\t\tschedule: PalletContractsSchedule\n\t\t"},{name:"Democracy",rpc_path:"democracy",funcs:"\n\t\t\tcooloffPeriod: u32\n\t\t\tenactmentPeriod: u32\n\t\t\tfastTrackVotingPeriod: u32\n\t\t\tinstantAllowed: bool\n\t\t\tlaunchPeriod: u32\n\t\t\tmaxProposals: u32\n\t\t\tmaxVotes: u32\n\t\t\tminimumDeposit: u128\n\t\t\tpreimageByteDeposit: u128\n\t\t\tvoteLockingPeriod: u32\n\t\t\tvotingPeriod: u32\n\t\t"},{name:"ElectionProviderMultiPhase",rpc_path:"electionProviderMultiPhase",funcs:"\n\t\t\tminerMaxLength: u32\n\t\t\tminerMaxWeight: u64\n\t\t\tminerTxPriority: u64\n\t\t\toffchainRepeat: u32\n\t\t\tsignedDepositBase: u128\n\t\t\tsignedDepositByte: u128\n\t\t\tsignedDepositWeight: u128\n\t\t\tsignedMaxSubmissions: u32\n\t\t\tsignedMaxWeight: u64\n\t\t\tsignedPhase: u32\n\t\t\tsignedRewardBase: u128\n\t\t\tsolutionImprovementThreshold: Perbill\n\t\t\tunsignedPhase: u32\n\t\t\tvoterSnapshotPerBlock: u32\n\t\t"},{name:"Elections",rpc_path:"elections",funcs:"\n\t\t\tcandidacyBond: u128\n\t\t\tdesiredMembers: u32\n\t\t\tdesiredRunnersUp: u32\n\t\t\tpalletId: [u8;8]\n\t\t\ttermDuration: u32\n\t\t\tvotingBondBase: u128\n\t\t\tvotingBondFactor: u128\n\t\t"},{name:"Gilt",rpc_path:"gilt",funcs:"\n\t\t\tfifoQueueLen: u32\n\t\t\tintakePeriod: u32\n\t\t\tmaxIntakeBids: u32\n\t\t\tmaxQueueLen: u32\n\t\t\tminFreeze: u128\n\t\t\tperiod: u32\n\t\t\tqueueCount: u32\n\t\t"},{name:"Grandpa",rpc_path:"grandpa",funcs:"\n\t\t\tmaxAuthorities: u32\n\t\t"},{name:"Identity",rpc_path:"identity",funcs:"\n\t\t\tbasicDeposit: u128\n\t\t\tfieldDeposit: u128\n\t\t\tmaxAdditionalFields: u32\n\t\t\tmaxRegistrars: u32\n\t\t\tmaxSubAccounts: u32\n\t\t\tsubAccountDeposit: u128\n\t\t"},{name:"ImOnline",rpc_path:"imOnline",funcs:"\n\t\t\tunsignedPriority: u64\n\t\t"},{name:"Indices",rpc_path:"indices",funcs:"\n\t\t\tdeposit: u128\n\t\t"},{name:"Lottery",rpc_path:"lottery",funcs:"\n\t\t\tmaxCalls: u32\n\t\t\tmaxGenerateRandom: u32\n\t\t\tpalletId: FrameSupportPalletId\n\t\t"},{name:"Multisig",rpc_path:"multisig",funcs:"\n\t\t\tdepositBase: u128\n\t\t\tdepositFactor: u128\n\t\t\tmaxSignatories: u16\n\t\t"},{name:"Proxy",rpc_path:"proxy",funcs:"\n\t\t\tannouncementDepositBase: u128\n\t\t\tannouncementDepositFactor: u128\n\t\t\tmaxPending: u32\n\t\t\tmaxProxies: u32\n\t\t\tproxyDepositBase: u128\n\t\t\tproxyDepositFactor: u128\n\t\t"},{name:"Recovery",rpc_path:"recovery",funcs:"\n\t\t\tconfigDepositBase: u128\n\t\t\tfriendDepositFactor: u128\n\t\t\tmaxFriends: u16\n\t\t\trecoveryDeposit: u128\n\t\t"},{name:"Scheduler",rpc_path:"scheduler",funcs:"\n\t\t\tmaximumWeight: u64\n\t\t\tmaxScheduledPerBlock: u32\n\t\t"},{name:"Society",rpc_path:"society",funcs:"\n\t\t\tcandidateDeposit: u128\n\t\t\tchallengePeriod: u32\n\t\t\tmaxCandidateIntake: u32\n\t\t\tmaxLockDuration: u32\n\t\t\tmaxStrikes: u32\n\t\t\tpalletId: FrameSupportPalletId\n\t\t\tperiodSpend: u128\n\t\t\trotationPeriod: u32\n\t\t\twrongSideDeduction: u128\n\t\t"},{name:"Staking",rpc_path:"staking",funcs:"\n\t\t\tbondingDuration: u32\n\t\t\tmaxNominatorRewardedPerValidator: u32\n\t\t\tsessionsPerEra: u32\n\t\t\tslashDeferDuration: u32\n\t\t"},{name:"System",rpc_path:"system",funcs:"\n\t\t\tblockHashCount: u32\n\t\t\tblockLength: FrameSystemLimitsBlockLength\n\t\t\tblockWeights: FrameSystemLimitsBlockWeights\n\t\t\tdbWeight: FrameSupportWeightsRuntimeDbWeight\n\t\t\tss58Prefix: u16\n\t\t\tversion: SpVersionRuntimeVersion\n\t\t"},{name:"Timestamp",rpc_path:"timestamp",funcs:"\n\t\t\tminimumPeriod: u64\n\t\t"},{name:"Tips",rpc_path:"tips",funcs:"\n\t\t\tdataDepositPerByte: u128\n\t\t\tmaximumReasonLength: u32\n\t\t\ttipCountdown: u32\n\t\t\ttipFindersFee: Percent\n\t\t\ttipReportDepositBase: u128\n\t\t"},{name:"TransactionPayment",rpc_path:"transactionPayment",funcs:"\n\t\t\toperationalFeeMultiplier: u8\n\t\t\ttransactionByteFee: u128\n\t\t\tweightToFee: Vec<FrameSupportWeightsWeightToFeeCoefficient>\n\t\t"},{name:"Treasury",rpc_path:"treasury",funcs:"\n\t\t\tburn: Permill\n\t\t\tmaxApprovals: u32\n\t\t\tpalletId: FrameSupportPalletId\n\t\t\tproposalBond: Permill\n\t\t\tproposalBondMaximum: Option<u128>\n\t\t\tproposalBondMinimum: u128\n\t\t\tspendPeriod: u32\n\t\t"},{name:"Uniques",rpc_path:"uniques",funcs:"\n\t\t\tattributeDepositBase: u128\n\t\t\tclassDeposit: u128\n\t\t\tdepositPerByte: u128\n\t\t\tinstanceDeposit: u128\n\t\t\tkeyLimit: u32\n\t\t\tmetadataDepositBase: u128\n\t\t\tstringLimit: u32\n\t\t\tvalueLimit: u32\n\t\t"},{name:"Utility",rpc_path:"utility",funcs:"\n\t\t\tbatchedCallsLimit: u32\n\t\t"},{name:"Vesting",rpc_path:"vesting",funcs:"\n\t\t\tmaxVestingSchedules: u32\n\t\t\tminVestedTransfer: u128\n\t\t"}]),Blackprint.registerNode("Polkadot.js/Convert/Mnemonic",((_class4=class extends Blackprint.Node{constructor(t){super(t);let e=this.setInterface();e.title="Mnemonic",this._toast=new NodeToast(e)}init(){this.iface.input.Text.on("disconnect",Context.EventSlot,(()=>{this.output.Seed=null}))}update(){let{Input:t,Output:e}=this.ref,{mnemonicToMiniSecret:n,mnemonicValidate:a}=polkadotUtilCrypto,o=this._toast;try{if(!a(t.Text))return o.warn("Invalid mnemonic");e.Seed=n(t.Text),o.clear()}catch(t){return o.warn(t.message)}}}).input={Text:String},_class4.output={Seed:Uint8Array},_class4)),Blackprint.registerNode("Polkadot.js/Data/Sign",((_class5=class extends Blackprint.Node{constructor(t){super(t);let e=this.setInterface();e.title="Sign",e.description="Data/transaction signer",this._toast=new NodeToast(this.iface),this.iface.on("cable.disconnect",Context.EventSlot,(({port:t})=>{"input"===t.source&&this.update()}))}_fail(t){this.output.Bytes=null,this._toast.warn(t)}update(){let{Input:t}=this.ref;return t.Signer?t.Data?void this._toast.clear():this._fail("Data is required"):this._fail("Signer is required")}async trigger(){let{Input:t,Output:e}=this.ref;if(!t.Signer||!t.Data)return this._fail("Some input is required");let n=t.Data,{signer:a,address:o,isPair:s}=t.Signer;if(e.Bytes=null,s)n.constructor===String&&(n=polkadotUtil.stringToU8a(n)),e.Bytes=a.sign(n);else{n.constructor===Uint8Array?n=polkadotUtil.u8aToHex(n):"0x"!==n.slice(0,2)&&(n=polkadotUtil.stringToHex(n));try{var r=a.signRaw({type:"bytes",data:n,address:o});this.iface.signing=r,r=await r,this.iface.signing=!1}catch(t){throw this._fail(t.message),t}e.Bytes=polkadotUtil.hexToU8a(r.signature)}}}).input={Trigger:Blackprint.Port.Trigger((function({iface:t}){t.node.trigger()})),Signer:Signer,Data:Blackprint.Port.Union([String,Uint8Array])},_class5.output={Bytes:Uint8Array},_class5)),Blackprint.registerNode("Polkadot.js/Data/Verify",((_class6=class extends Blackprint.Node{constructor(t){super(t),this.setInterface().title="Verify",this._toast=new NodeToast(this.iface),this.iface.on("cable.disconnect",Context.EventSlot,(({port:t})=>{"input"===t.source&&this.update()}))}_fail(t){this.output.IsValid=null,this._toast.warn(t)}update(){let{Input:t,Output:e}=this.ref;if(!t.Data)return this._fail("Data is required");if(!t.Address)return this._fail("Address is required");if(!t.Signature)return this._fail("Signature is required");let n=t.Data;n.constructor===String&&(n="0x"===n.slice(0,2)?polkadotUtil.hexToU8a(n):polkadotUtil.stringToU8a(n));let a=t.Signature;if(a.constructor===String){if("0x"!==a.slice(0,2))return this._fail("Signature must be Hex or Uint8Array");a=polkadotUtil.hexToU8a(a)}this._toast.clear();try{var o=polkadotUtilCrypto.signatureVerify(n,a,t.Address)}catch(t){throw this._fail(t.message),t}e.IsValid=o.isValid}}).input={Address:String,Data:Blackprint.Port.Union([String,Uint8Array]),Signature:Blackprint.Port.Union([String,Uint8Array])},_class6.output={IsValid:Boolean},_class6)),Blackprint.registerNode("Polkadot.js/Events/Blocks",((_class7=class extends Blackprint.Node{constructor(t){super(t);let e=this.setInterface("BPIC/Polkadot.js/Events/Blocks");e.title="Blocks Event",this._toast=new NodeToast(e)}init(){let{IInput:t}=this.ref;t.API.on("disconnect",Context.EventSlot,(()=>{this.iface.unsubscribe()}))}destroy(){this.iface.unsubscribe()}async update(){let{Input:t,Output:e}=this.ref;this.iface.unsubscribe();let n=t.API;if(n){if(!n.hasSubscriptions)return this._toast.error("Please use WebSocket for using this feature");this._toast.clear(),this._toast.warn("Subscribing..."),this.iface.unsubscribe=await n.rpc.chain.subscribeNewHeads((t=>{e.Data=t,e.Number=this.iface.number=t.number.toNumber()})),this._toast.clear(),this._toast.success("Subscribed!")}}}).type="event",_class7.input={API:polkadotApi.ApiPromise},_class7.output={Data:Object,Number:Number},_class7)),Blackprint.registerInterface("BPIC/Polkadot.js/Events/Blocks",Context.IFace.EventsBlocks=class extends Blackprint.Interface{constructor(t){super(t),this.number=0,this.unsubscribe=()=>{}}}),Substrate_BlackprintNodeGenerator({namespace:"Extrinsics",description:"[Experimental] Substrate Extrinsics",apiPath:"tx",loose:!0,isExtrinsics:!0},[{name:"Assets",rpc_path:"assets",funcs:"\n\t\t\tapproveTransfer(id: Compact<u32>, delegate: MultiAddress, amount: Compact<u128>)\n\t\t\tburn(id: Compact<u32>, who: MultiAddress, amount: Compact<u128>)\n\t\t\tcancelApproval(id: Compact<u32>, delegate: MultiAddress)\n\t\t\tclearMetadata(id: Compact<u32>)\n\t\t\tcreate(id: Compact<u32>, admin: MultiAddress, min_balance: u128)\n\t\t\tdestroy(id: Compact<u32>, witness: PalletAssetsDestroyWitness)\n\t\t\tforceAssetStatus(id: Compact<u32>, owner: MultiAddress, issuer: MultiAddress, admin: MultiAddress, freezer: MultiAddress, min_balance: Compact<u128>, is_sufficient: bool, is_frozen: bool)\n\t\t\tforceCancelApproval(id: Compact<u32>, owner: MultiAddress, delegate: MultiAddress)\n\t\t\tforceClearMetadata(id: Compact<u32>)\n\t\t\tforceCreate(id: Compact<u32>, owner: MultiAddress, is_sufficient: bool, min_balance: Compact<u128>)\n\t\t\tforceSetMetadata(id: Compact<u32>, name: Bytes, symbol: Bytes, decimals: u8, is_frozen: bool)\n\t\t\tforceTransfer(id: Compact<u32>, source: MultiAddress, dest: MultiAddress, amount: Compact<u128>)\n\t\t\tfreeze(id: Compact<u32>, who: MultiAddress)\n\t\t\tfreezeAsset(id: Compact<u32>)\n\t\t\tmint(id: Compact<u32>, beneficiary: MultiAddress, amount: Compact<u128>)\n\t\t\trefund(id: Compact<u32>, allow_burn: bool)\n\t\t\tsetMetadata(id: Compact<u32>, name: Bytes, symbol: Bytes, decimals: u8)\n\t\t\tsetTeam(id: Compact<u32>, issuer: MultiAddress, admin: MultiAddress, freezer: MultiAddress)\n\t\t\tthaw(id: Compact<u32>, who: MultiAddress)\n\t\t\tthawAsset(id: Compact<u32>)\n\t\t\ttouch(id: Compact<u32>)\n\t\t\ttransfer(id: Compact<u32>, target: MultiAddress, amount: Compact<u128>)\n\t\t\ttransferApproved(id: Compact<u32>, owner: MultiAddress, destination: MultiAddress, amount: Compact<u128>)\n\t\t\ttransferKeepAlive(id: Compact<u32>, target: MultiAddress, amount: Compact<u128>)\n\t\t\ttransferOwnership(id: Compact<u32>, owner: MultiAddress)\n\t\t"},{name:"Authorship",rpc_path:"authorship",funcs:"\n\t\t\tsetUncles(new_uncles: Vec<SpRuntimeHeader>)\n\t\t"},{name:"Babe",rpc_path:"babe",funcs:"\n\t\t\tplanConfigChange(config: SpConsensusBabeDigestsNextConfigDescriptor)\n\t\t\treportEquivocation(equivocation_proof: SpConsensusSlotsEquivocationProof, key_owner_proof: SpSessionMembershipProof)\n\t\t\treportEquivocationUnsigned(equivocation_proof: SpConsensusSlotsEquivocationProof, key_owner_proof: SpSessionMembershipProof)\n\t\t"},{name:"BagsList",rpc_path:"bagsList",funcs:"\n\t\t\tputInFrontOf(lighter: AccountId32)\n\t\t\trebag(dislocated: AccountId32)\n\t\t"},{name:"Balances",rpc_path:"balances",funcs:"\n\t\t\tforceTransfer(source: MultiAddress, dest: MultiAddress, value: Compact<u128>)\n\t\t\tforceUnreserve(who: MultiAddress, amount: u128)\n\t\t\tsetBalance(who: MultiAddress, new_free: Compact<u128>, new_reserved: Compact<u128>)\n\t\t\ttransfer(dest: MultiAddress, value: Compact<u128>)\n\t\t\ttransferAll(dest: MultiAddress, keep_alive: bool)\n\t\t\ttransferKeepAlive(dest: MultiAddress, value: Compact<u128>)\n\t\t"},{name:"Bounties",rpc_path:"bounties",funcs:"\n\t\t\tacceptCurator(bounty_id: Compact<u32>)\n\t\t\tapproveBounty(bounty_id: Compact<u32>)\n\t\t\tawardBounty(bounty_id: Compact<u32>, beneficiary: MultiAddress)\n\t\t\tclaimBounty(bounty_id: Compact<u32>)\n\t\t\tcloseBounty(bounty_id: Compact<u32>)\n\t\t\textendBountyExpiry(bounty_id: Compact<u32>, remark: Bytes)\n\t\t\tproposeBounty(value: Compact<u128>, description: Bytes)\n\t\t\tproposeCurator(bounty_id: Compact<u32>, curator: MultiAddress, fee: Compact<u128>)\n\t\t\tunassignCurator(bounty_id: Compact<u32>)\n\t\t"},{name:"ChildBounties",rpc_path:"childBounties",funcs:"\n\t\t\tacceptCurator(parent_bounty_id: Compact<u32>, child_bounty_id: Compact<u32>)\n\t\t\taddChildBounty(parent_bounty_id: Compact<u32>, value: Compact<u128>, description: Bytes)\n\t\t\tawardChildBounty(parent_bounty_id: Compact<u32>, child_bounty_id: Compact<u32>, beneficiary: MultiAddress)\n\t\t\tclaimChildBounty(parent_bounty_id: Compact<u32>, child_bounty_id: Compact<u32>)\n\t\t\tcloseChildBounty(parent_bounty_id: Compact<u32>, child_bounty_id: Compact<u32>)\n\t\t\tproposeCurator(parent_bounty_id: Compact<u32>, child_bounty_id: Compact<u32>, curator: MultiAddress, fee: Compact<u128>)\n\t\t\tunassignCurator(parent_bounty_id: Compact<u32>, child_bounty_id: Compact<u32>)\n\t\t"},{name:"Contracts",rpc_path:"contracts",funcs:"\n\t\t\tcall(dest: MultiAddress, value: Compact<u128>, gas_limit: Compact<u64>, storage_deposit_limit: Option<Compact<u128>>, data: Bytes)\n\t\t\tinstantiate(value: Compact<u128>, gas_limit: Compact<u64>, storage_deposit_limit: Option<Compact<u128>>, code_hash: H256, data: Bytes, salt: Bytes)\n\t\t\tinstantiateWithCode(value: Compact<u128>, gas_limit: Compact<u64>, storage_deposit_limit: Option<Compact<u128>>, code: Bytes, data: Bytes, salt: Bytes)\n\t\t\tremoveCode(code_hash: H256)\n\t\t\tuploadCode(code: Bytes, storage_deposit_limit: Option<Compact<u128>>)\n\t\t"},{name:"Council",rpc_path:"council",funcs:"\n\t\t\tclose(proposal_hash: H256, index: Compact<u32>, proposal_weight_bound: Compact<u64>, length_bound: Compact<u32>)\n\t\t\tdisapproveProposal(proposal_hash: H256)\n\t\t\texecute(proposal: Call, length_bound: Compact<u32>)\n\t\t\tpropose(threshold: Compact<u32>, proposal: Call, length_bound: Compact<u32>)\n\t\t\tsetMembers(new_members: Vec<AccountId32>, prime: Option<AccountId32>, old_count: u32)\n\t\t\tvote(proposal: H256, index: Compact<u32>, approve: bool)\n\t\t"},{name:"Democracy",rpc_path:"democracy",funcs:"\n\t\t\tblacklist(proposal_hash: H256, maybe_ref_index: Option<u32>)\n\t\t\tcancelProposal(prop_index: Compact<u32>)\n\t\t\tcancelQueued(which: u32)\n\t\t\tcancelReferendum(ref_index: Compact<u32>)\n\t\t\tclearPublicProposals()\n\t\t\tdelegate(to: AccountId32, conviction: PalletDemocracyConviction, balance: u128)\n\t\t\temergencyCancel(ref_index: u32)\n\t\t\tenactProposal(proposal_hash: H256, index: u32)\n\t\t\texternalPropose(proposal_hash: H256)\n\t\t\texternalProposeDefault(proposal_hash: H256)\n\t\t\texternalProposeMajority(proposal_hash: H256)\n\t\t\tfastTrack(proposal_hash: H256, voting_period: u32, delay: u32)\n\t\t\tnoteImminentPreimage(encoded_proposal: Bytes)\n\t\t\tnoteImminentPreimageOperational(encoded_proposal: Bytes)\n\t\t\tnotePreimage(encoded_proposal: Bytes)\n\t\t\tnotePreimageOperational(encoded_proposal: Bytes)\n\t\t\tpropose(proposal_hash: H256, value: Compact<u128>)\n\t\t\treapPreimage(proposal_hash: H256, proposal_len_upper_bound: Compact<u32>)\n\t\t\tremoveOtherVote(target: AccountId32, index: u32)\n\t\t\tremoveVote(index: u32)\n\t\t\tsecond(proposal: Compact<u32>, seconds_upper_bound: Compact<u32>)\n\t\t\tundelegate()\n\t\t\tunlock(target: AccountId32)\n\t\t\tvetoExternal(proposal_hash: H256)\n\t\t\tvote(ref_index: Compact<u32>, vote: PalletDemocracyVoteAccountVote)\n\t\t"},{name:"ElectionProviderMultiPhase",rpc_path:"electionProviderMultiPhase",funcs:"\n\t\t\tgovernanceFallback(maybe_max_voters: Option<u32>, maybe_max_targets: Option<u32>)\n\t\t\tsetEmergencyElectionResult(supports: Vec<(AccountId32,SpNposElectionsSupport)>)\n\t\t\tsetMinimumUntrustedScore(maybe_next_score: Option<[u128;3]>)\n\t\t\tsubmit(raw_solution: PalletElectionProviderMultiPhaseRawSolution, num_signed_submissions: u32)\n\t\t\tsubmitUnsigned(raw_solution: PalletElectionProviderMultiPhaseRawSolution, witness: PalletElectionProviderMultiPhaseSolutionOrSnapshotSize)\n\t\t"},{name:"Elections",rpc_path:"elections",funcs:"\n\t\t\tcleanDefunctVoters(num_voters: u32, num_defunct: u32)\n\t\t\tremoveMember(who: MultiAddress, has_replacement: bool)\n\t\t\tremoveVoter()\n\t\t\trenounceCandidacy(renouncing: PalletElectionsPhragmenRenouncing)\n\t\t\tsubmitCandidacy(candidate_count: Compact<u32>)\n\t\t\tvote(votes: Vec<AccountId32>, value: Compact<u128>)\n\t\t"},{name:"Gilt",rpc_path:"gilt",funcs:"\n\t\t\tplaceBid(amount: Compact<u128>, duration: u32)\n\t\t\tretractBid(amount: Compact<u128>, duration: u32)\n\t\t\tsetTarget(target: Compact<Perquintill>)\n\t\t\tthaw(index: Compact<u32>)\n\t\t"},{name:"Grandpa",rpc_path:"grandpa",funcs:"\n\t\t\tnoteStalled(delay: u32, best_finalized_block_number: u32)\n\t\t\treportEquivocation(equivocation_proof: SpFinalityGrandpaEquivocationProof, key_owner_proof: SpSessionMembershipProof)\n\t\t\treportEquivocationUnsigned(equivocation_proof: SpFinalityGrandpaEquivocationProof, key_owner_proof: SpSessionMembershipProof)\n\t\t"},{name:"Identity",rpc_path:"identity",funcs:"\n\t\t\taddRegistrar(account: AccountId32)\n\t\t\taddSub(sub: MultiAddress, data: Data)\n\t\t\tcancelRequest(reg_index: u32)\n\t\t\tclearIdentity()\n\t\t\tkillIdentity(target: MultiAddress)\n\t\t\tprovideJudgement(reg_index: Compact<u32>, target: MultiAddress, judgement: PalletIdentityJudgement)\n\t\t\tquitSub()\n\t\t\tremoveSub(sub: MultiAddress)\n\t\t\trenameSub(sub: MultiAddress, data: Data)\n\t\t\trequestJudgement(reg_index: Compact<u32>, max_fee: Compact<u128>)\n\t\t\tsetAccountId(index: Compact<u32>, new: AccountId32)\n\t\t\tsetFee(index: Compact<u32>, fee: Compact<u128>)\n\t\t\tsetFields(index: Compact<u32>, fields: PalletIdentityBitFlags)\n\t\t\tsetIdentity(info: PalletIdentityIdentityInfo)\n\t\t\tsetSubs(subs: Vec<(AccountId32,Data)>)\n\t\t"},{name:"ImOnline",rpc_path:"imOnline",funcs:"\n\t\t\theartbeat(heartbeat: PalletImOnlineHeartbeat, signature: PalletImOnlineSr25519AppSr25519Signature)\n\t\t"},{name:"Indices",rpc_path:"indices",funcs:"\n\t\t\tclaim(index: u32)\n\t\t\tforceTransfer(new: AccountId32, index: u32, freeze: bool)\n\t\t\tfree(index: u32)\n\t\t\tfreeze(index: u32)\n\t\t\ttransfer(new: AccountId32, index: u32)\n\t\t"},{name:"Lottery",rpc_path:"lottery",funcs:"\n\t\t\tbuyTicket(call: Call)\n\t\t\tsetCalls(calls: Vec<Call>)\n\t\t\tstartLottery(price: u128, length: u32, delay: u32, repeat: bool)\n\t\t\tstopRepeat()\n\t\t"},{name:"Multisig",rpc_path:"multisig",funcs:"\n\t\t\tapproveAsMulti(threshold: u16, other_signatories: Vec<AccountId32>, maybe_timepoint: Option<PalletMultisigTimepoint>, call_hash: [u8;32], max_weight: u64)\n\t\t\tasMulti(threshold: u16, other_signatories: Vec<AccountId32>, maybe_timepoint: Option<PalletMultisigTimepoint>, call: WrapperKeepOpaque<Call>, store_call: bool, max_weight: u64)\n\t\t\tasMultiThreshold1(other_signatories: Vec<AccountId32>, call: Call)\n\t\t\tcancelAsMulti(threshold: u16, other_signatories: Vec<AccountId32>, timepoint: PalletMultisigTimepoint, call_hash: [u8;32])\n\t\t"},{name:"Preimage",rpc_path:"preimage",funcs:"\n\t\t\tnotePreimage(bytes: Bytes)\n\t\t\trequestPreimage(hash: H256)\n\t\t\tunnotePreimage(hash: H256)\n\t\t\tunrequestPreimage(hash: H256)\n\t\t"},{name:"Proxy",rpc_path:"proxy",funcs:"\n\t\t\taddProxy(delegate: AccountId32, proxy_type: NodeRuntimeProxyType, delay: u32)\n\t\t\tannounce(real: AccountId32, call_hash: H256)\n\t\t\tanonymous(proxy_type: NodeRuntimeProxyType, delay: u32, index: u16)\n\t\t\tkillAnonymous(spawner: AccountId32, proxy_type: NodeRuntimeProxyType, index: u16, height: Compact<u32>, ext_index: Compact<u32>)\n\t\t\tproxy(real: AccountId32, force_proxy_type: Option<NodeRuntimeProxyType>, call: Call)\n\t\t\tproxyAnnounced(delegate: AccountId32, real: AccountId32, force_proxy_type: Option<NodeRuntimeProxyType>, call: Call)\n\t\t\trejectAnnouncement(delegate: AccountId32, call_hash: H256)\n\t\t\tremoveAnnouncement(real: AccountId32, call_hash: H256)\n\t\t\tremoveProxies()\n\t\t\tremoveProxy(delegate: AccountId32, proxy_type: NodeRuntimeProxyType, delay: u32)\n\t\t"},{name:"Recovery",rpc_path:"recovery",funcs:"\n\t\t\tasRecovered(account: AccountId32, call: Call)\n\t\t\tcancelRecovered(account: AccountId32)\n\t\t\tclaimRecovery(account: AccountId32)\n\t\t\tcloseRecovery(rescuer: AccountId32)\n\t\t\tcreateRecovery(friends: Vec<AccountId32>, threshold: u16, delay_period: u32)\n\t\t\tinitiateRecovery(account: AccountId32)\n\t\t\tremoveRecovery()\n\t\t\tsetRecovered(lost: AccountId32, rescuer: AccountId32)\n\t\t\tvouchRecovery(lost: AccountId32, rescuer: AccountId32)\n\t\t"},{name:"Scheduler",rpc_path:"scheduler",funcs:"\n\t\t\tcancel(when: u32, index: u32)\n\t\t\tcancelNamed(id: Bytes)\n\t\t\tschedule(when: u32, maybe_periodic: Option<(u32,u32)>, priority: u8, call: FrameSupportScheduleMaybeHashed)\n\t\t\tscheduleAfter(after: u32, maybe_periodic: Option<(u32,u32)>, priority: u8, call: FrameSupportScheduleMaybeHashed)\n\t\t\tscheduleNamed(id: Bytes, when: u32, maybe_periodic: Option<(u32,u32)>, priority: u8, call: FrameSupportScheduleMaybeHashed)\n\t\t\tscheduleNamedAfter(id: Bytes, after: u32, maybe_periodic: Option<(u32,u32)>, priority: u8, call: FrameSupportScheduleMaybeHashed)\n\t\t"},{name:"Session",rpc_path:"session",funcs:"\n\t\t\tpurgeKeys()\n\t\t\tsetKeys(keys: NodeRuntimeSessionKeys, proof: Bytes)\n\t\t"},{name:"Society",rpc_path:"society",funcs:"\n\t\t\tbid(value: u128)\n\t\t\tdefenderVote(approve: bool)\n\t\t\tfound(founder: AccountId32, max_members: u32, rules: Bytes)\n\t\t\tjudgeSuspendedCandidate(who: AccountId32, judgement: PalletSocietyJudgement)\n\t\t\tjudgeSuspendedMember(who: AccountId32, forgive: bool)\n\t\t\tpayout()\n\t\t\tsetMaxMembers(max: u32)\n\t\t\tunbid(pos: u32)\n\t\t\tunfound()\n\t\t\tunvouch(pos: u32)\n\t\t\tvote(candidate: MultiAddress, approve: bool)\n\t\t\tvouch(who: AccountId32, value: u128, tip: u128)\n\t\t"},{name:"Staking",rpc_path:"staking",funcs:"\n\t\t\tbond(controller: MultiAddress, value: Compact<u128>, payee: PalletStakingRewardDestination)\n\t\t\tbondExtra(max_additional: Compact<u128>)\n\t\t\tcancelDeferredSlash(era: u32, slash_indices: Vec<u32>)\n\t\t\tchill()\n\t\t\tchillOther(controller: AccountId32)\n\t\t\tforceNewEra()\n\t\t\tforceNewEraAlways()\n\t\t\tforceNoEras()\n\t\t\tforceUnstake(stash: AccountId32, num_slashing_spans: u32)\n\t\t\tincreaseValidatorCount(additional: Compact<u32>)\n\t\t\tkick(who: Vec<MultiAddress>)\n\t\t\tnominate(targets: Vec<MultiAddress>)\n\t\t\tpayoutStakers(validator_stash: AccountId32, era: u32)\n\t\t\treapStash(stash: AccountId32, num_slashing_spans: u32)\n\t\t\trebond(value: Compact<u128>)\n\t\t\tscaleValidatorCount(factor: Percent)\n\t\t\tsetController(controller: MultiAddress)\n\t\t\tsetHistoryDepth(new_history_depth: Compact<u32>, era_items_deleted: Compact<u32>)\n\t\t\tsetInvulnerables(invulnerables: Vec<AccountId32>)\n\t\t\tsetPayee(payee: PalletStakingRewardDestination)\n\t\t\tsetStakingConfigs(min_nominator_bond: u128, min_validator_bond: u128, max_nominator_count: Option<u32>, max_validator_count: Option<u32>, chill_threshold: Option<Percent>, min_commission: Perbill)\n\t\t\tsetValidatorCount(new: Compact<u32>)\n\t\t\tunbond(value: Compact<u128>)\n\t\t\tvalidate(prefs: PalletStakingValidatorPrefs)\n\t\t\twithdrawUnbonded(num_slashing_spans: u32)\n\t\t"},{name:"Sudo",rpc_path:"sudo",funcs:"\n\t\t\tsetKey(new: MultiAddress)\n\t\t\tsudo(call: Call)\n\t\t\tsudoAs(who: MultiAddress, call: Call)\n\t\t\tsudoUncheckedWeight(call: Call, weight: u64)\n\t\t"},{name:"System",rpc_path:"system",funcs:"\n\t\t\tfillBlock(ratio: Perbill)\n\t\t\tkillPrefix(prefix: Bytes, subkeys: u32)\n\t\t\tkillStorage(keys: Vec<Bytes>)\n\t\t\tremark(remark: Bytes)\n\t\t\tremarkWithEvent(remark: Bytes)\n\t\t\tsetCode(code: Bytes)\n\t\t\tsetCodeWithoutChecks(code: Bytes)\n\t\t\tsetHeapPages(pages: u64)\n\t\t\tsetStorage(items: Vec<(Bytes,Bytes)>)\n\t\t"},{name:"TechnicalCommittee",rpc_path:"technicalCommittee",funcs:"\n\t\t\tclose(proposal_hash: H256, index: Compact<u32>, proposal_weight_bound: Compact<u64>, length_bound: Compact<u32>)\n\t\t\tdisapproveProposal(proposal_hash: H256)\n\t\t\texecute(proposal: Call, length_bound: Compact<u32>)\n\t\t\tpropose(threshold: Compact<u32>, proposal: Call, length_bound: Compact<u32>)\n\t\t\tsetMembers(new_members: Vec<AccountId32>, prime: Option<AccountId32>, old_count: u32)\n\t\t\tvote(proposal: H256, index: Compact<u32>, approve: bool)\n\t\t"},{name:"TechnicalMembership",rpc_path:"technicalMembership",funcs:"\n\t\t\taddMember(who: AccountId32)\n\t\t\tchangeKey(new: AccountId32)\n\t\t\tclearPrime()\n\t\t\tremoveMember(who: AccountId32)\n\t\t\tresetMembers(members: Vec<AccountId32>)\n\t\t\tsetPrime(who: AccountId32)\n\t\t\tswapMember(remove: AccountId32, add: AccountId32)\n\t\t"},{name:"Timestamp",rpc_path:"timestamp",funcs:"\n\t\t\tset(now: Compact<u64>)\n\t\t"},{name:"Tips",rpc_path:"tips",funcs:"\n\t\t\tcloseTip(hash: H256)\n\t\t\treportAwesome(reason: Bytes, who: AccountId32)\n\t\t\tretractTip(hash: H256)\n\t\t\tslashTip(hash: H256)\n\t\t\ttip(hash: H256, tip_value: Compact<u128>)\n\t\t\ttipNew(reason: Bytes, who: AccountId32, tip_value: Compact<u128>)\n\t\t"},{name:"TransactionStorage",rpc_path:"transactionStorage",funcs:"\n\t\t\tcheckProof(proof: SpTransactionStorageProofTransactionStorageProof)\n\t\t\trenew(block: u32, index: u32)\n\t\t\tstore(data: Bytes)\n\t\t"},{name:"Treasury",rpc_path:"treasury",funcs:"\n\t\t\tapproveProposal(proposal_id: Compact<u32>)\n\t\t\tproposeSpend(value: Compact<u128>, beneficiary: MultiAddress)\n\t\t\trejectProposal(proposal_id: Compact<u32>)\n\t\t"},{name:"Uniques",rpc_path:"uniques",funcs:"\n\t\t\tapproveTransfer(class: Compact<u32>, instance: Compact<u32>, delegate: MultiAddress)\n\t\t\tburn(class: Compact<u32>, instance: Compact<u32>, check_owner: Option<MultiAddress>)\n\t\t\tcancelApproval(class: Compact<u32>, instance: Compact<u32>, maybe_check_delegate: Option<MultiAddress>)\n\t\t\tclearAttribute(class: Compact<u32>, maybe_instance: Option<u32>, key: Bytes)\n\t\t\tclearClassMetadata(class: Compact<u32>)\n\t\t\tclearMetadata(class: Compact<u32>, instance: Compact<u32>)\n\t\t\tcreate(class: Compact<u32>, admin: MultiAddress)\n\t\t\tdestroy(class: Compact<u32>, witness: PalletUniquesDestroyWitness)\n\t\t\tforceAssetStatus(class: Compact<u32>, owner: MultiAddress, issuer: MultiAddress, admin: MultiAddress, freezer: MultiAddress, free_holding: bool, is_frozen: bool)\n\t\t\tforceCreate(class: Compact<u32>, owner: MultiAddress, free_holding: bool)\n\t\t\tfreeze(class: Compact<u32>, instance: Compact<u32>)\n\t\t\tfreezeClass(class: Compact<u32>)\n\t\t\tmint(class: Compact<u32>, instance: Compact<u32>, owner: MultiAddress)\n\t\t\tredeposit(class: Compact<u32>, instances: Vec<u32>)\n\t\t\tsetAttribute(class: Compact<u32>, maybe_instance: Option<u32>, key: Bytes, value: Bytes)\n\t\t\tsetClassMetadata(class: Compact<u32>, data: Bytes, is_frozen: bool)\n\t\t\tsetMetadata(class: Compact<u32>, instance: Compact<u32>, data: Bytes, is_frozen: bool)\n\t\t\tsetTeam(class: Compact<u32>, issuer: MultiAddress, admin: MultiAddress, freezer: MultiAddress)\n\t\t\tthaw(class: Compact<u32>, instance: Compact<u32>)\n\t\t\tthawClass(class: Compact<u32>)\n\t\t\ttransfer(class: Compact<u32>, instance: Compact<u32>, dest: MultiAddress)\n\t\t\ttransferOwnership(class: Compact<u32>, owner: MultiAddress)\n\t\t"},{name:"Utility",rpc_path:"utility",funcs:"\n\t\t\tasDerivative(index: u16, call: Call)\n\t\t\tbatch(calls: Vec<Call>)\n\t\t\tbatchAll(calls: Vec<Call>)\n\t\t\tdispatchAs(as_origin: NodeRuntimeOriginCaller, call: Call)\n\t\t"},{name:"Vesting",rpc_path:"vesting",funcs:"\n\t\t\tforceVestedTransfer(source: MultiAddress, target: MultiAddress, schedule: PalletVestingVestingInfo)\n\t\t\tmergeSchedules(schedule1_index: u32, schedule2_index: u32)\n\t\t\tvest()\n\t\t\tvestOther(target: MultiAddress)\n\t\t\tvestedTransfer(target: MultiAddress, schedule: PalletVestingVestingInfo)\n\t\t"}]),Blackprint.registerNode("Polkadot.js/Keyring/RandomSeed",((_class8=class extends Blackprint.Node{constructor(t){super(t),this.setInterface().title="Random Key"}imported(){this.update()}update(){let{Input:t,Output:e}=this.ref;e.Seed=polkadotUtilCrypto.randomAsU8a(32);let n=new polkadotApi.Keyring({type:t.KeyType,ss58Format:0}),a=e.Pair=n.addFromSeed(e.Seed);e.Signer=new Signer(!0,e.Address,a),e.Address=a.address}}).input={KeyType:Blackprint.Port.Default(String,"ed25519")},_class8.output={Address:String,Seed:Uint8Array,Signer:Signer,Pair:Object},_class8)),Substrate_BlackprintNodeGenerator({namespace:"Storage",description:"[Experimental] Substrate Storage",apiPath:"query",loose:!0,typeAsName:!0},[{name:"Assets",rpc_path:"assets",funcs:"\n\t\t\taccount(u32, AccountId32): Option<PalletAssetsAssetAccount>\n\t\t\tapprovals(u32, AccountId32, AccountId32): Option<PalletAssetsApproval>\n\t\t\tasset(u32): Option<PalletAssetsAssetDetails>\n\t\t\tmetadata(u32): PalletAssetsAssetMetadata\n\t\t"},{name:"AuthorityDiscovery",rpc_path:"authorityDiscovery",funcs:"\n\t\t\tkeys(): Vec<SpAuthorityDiscoveryAppPublic>\n\t\t\tnextKeys(): Vec<SpAuthorityDiscoveryAppPublic>\n\t\t"},{name:"Authorship",rpc_path:"authorship",funcs:"\n\t\t\tauthor(): Option<AccountId32>\n\t\t\tdidSetUncles(): bool\n\t\t\tuncles(): Vec<PalletAuthorshipUncleEntryItem>\n\t\t"},{name:"Babe",rpc_path:"babe",funcs:"\n\t\t\tauthorities(): Vec<(SpConsensusBabeAppPublic,u64)>\n\t\t\tauthorVrfRandomness(): Option<[u8;32]>\n\t\t\tcurrentSlot(): u64\n\t\t\tepochConfig(): Option<SpConsensusBabeBabeEpochConfiguration>\n\t\t\tepochIndex(): u64\n\t\t\tepochStart(): (u32,u32)\n\t\t\tgenesisSlot(): u64\n\t\t\tinitialized(): Option<Option<[u8;32]>>\n\t\t\tlateness(): u32\n\t\t\tnextAuthorities(): Vec<(SpConsensusBabeAppPublic,u64)>\n\t\t\tnextEpochConfig(): Option<SpConsensusBabeBabeEpochConfiguration>\n\t\t\tnextRandomness(): [u8;32]\n\t\t\tpendingEpochConfigChange(): Option<SpConsensusBabeDigestsNextConfigDescriptor>\n\t\t\trandomness(): [u8;32]\n\t\t\tsegmentIndex(): u32\n\t\t\tunderConstruction(u32): Vec<[u8;32]>\n\t\t"},{name:"BagsList",rpc_path:"bagsList",funcs:"\n\t\t\tcounterForListNodes(): u32\n\t\t\tlistBags(u64): Option<PalletBagsListListBag>\n\t\t\tlistNodes(AccountId32): Option<PalletBagsListListNode>\n\t\t"},{name:"Balances",rpc_path:"balances",funcs:"\n\t\t\taccount(AccountId32): PalletBalancesAccountData\n\t\t\tlocks(AccountId32): Vec<PalletBalancesBalanceLock>\n\t\t\treserves(AccountId32): Vec<PalletBalancesReserveData>\n\t\t\tstorageVersion(): PalletBalancesReleases\n\t\t\ttotalIssuance(): u128\n\t\t"},{name:"Bounties",rpc_path:"bounties",funcs:"\n\t\t\tbounties(u32): Option<PalletBountiesBounty>\n\t\t\tbountyApprovals(): Vec<u32>\n\t\t\tbountyCount(): u32\n\t\t\tbountyDescriptions(u32): Option<Bytes>\n\t\t"},{name:"ChildBounties",rpc_path:"childBounties",funcs:"\n\t\t\tchildBounties(u32, u32): Option<PalletChildBountiesChildBounty>\n\t\t\tchildBountyCount(): u32\n\t\t\tchildBountyDescriptions(u32): Option<Bytes>\n\t\t\tchildrenCuratorFees(u32): u128\n\t\t\tparentChildBounties(u32): u32\n\t\t"},{name:"Contracts",rpc_path:"contracts",funcs:"\n\t\t\taccountCounter(): u64\n\t\t\tcodeStorage(H256): Option<PalletContractsWasmPrefabWasmModule>\n\t\t\tcontractInfoOf(AccountId32): Option<PalletContractsStorageRawContractInfo>\n\t\t\tdeletionQueue(): Vec<PalletContractsStorageDeletedContract>\n\t\t\townerInfoOf(H256): Option<PalletContractsWasmOwnerInfo>\n\t\t\tpristineCode(H256): Option<Bytes>\n\t\t"},{name:"Council",rpc_path:"council",funcs:"\n\t\t\tmembers(): Vec<AccountId32>\n\t\t\tprime(): Option<AccountId32>\n\t\t\tproposalCount(): u32\n\t\t\tproposalOf(H256): Option<Call>\n\t\t\tproposals(): Vec<H256>\n\t\t\tvoting(H256): Option<PalletCollectiveVotes>\n\t\t"},{name:"Democracy",rpc_path:"democracy",funcs:"\n\t\t\tblacklist(H256): Option<(u32,Vec<AccountId32>)>\n\t\t\tcancellations(H256): bool\n\t\t\tdepositOf(u32): Option<(Vec<AccountId32>,u128)>\n\t\t\tlastTabledWasExternal(): bool\n\t\t\tlocks(AccountId32): Option<u32>\n\t\t\tlowestUnbaked(): u32\n\t\t\tnextExternal(): Option<(H256,PalletDemocracyVoteThreshold)>\n\t\t\tpreimages(H256): Option<PalletDemocracyPreimageStatus>\n\t\t\tpublicPropCount(): u32\n\t\t\tpublicProps(): Vec<(u32,H256,AccountId32)>\n\t\t\treferendumCount(): u32\n\t\t\treferendumInfoOf(u32): Option<PalletDemocracyReferendumInfo>\n\t\t\tstorageVersion(): Option<PalletDemocracyReleases>\n\t\t\tvotingOf(AccountId32): PalletDemocracyVoteVoting\n\t\t"},{name:"ElectionProviderMultiPhase",rpc_path:"electionProviderMultiPhase",funcs:"\n\t\t\tcurrentPhase(): PalletElectionProviderMultiPhasePhase\n\t\t\tdesiredTargets(): Option<u32>\n\t\t\tminimumUntrustedScore(): Option<[u128;3]>\n\t\t\tqueuedSolution(): Option<PalletElectionProviderMultiPhaseReadySolution>\n\t\t\tround(): u32\n\t\t\tsignedSubmissionIndices(): BTreeMap<[u128;3], u32>\n\t\t\tsignedSubmissionNextIndex(): u32\n\t\t\tsignedSubmissionsMap(u32): Option<PalletElectionProviderMultiPhaseSignedSignedSubmission>\n\t\t\tsnapshot(): Option<PalletElectionProviderMultiPhaseRoundSnapshot>\n\t\t\tsnapshotMetadata(): Option<PalletElectionProviderMultiPhaseSolutionOrSnapshotSize>\n\t\t"},{name:"Elections",rpc_path:"elections",funcs:"\n\t\t\tcandidates(): Vec<(AccountId32,u128)>\n\t\t\telectionRounds(): u32\n\t\t\tmembers(): Vec<PalletElectionsPhragmenSeatHolder>\n\t\t\trunnersUp(): Vec<PalletElectionsPhragmenSeatHolder>\n\t\t\tvoting(AccountId32): PalletElectionsPhragmenVoter\n\t\t"},{name:"Gilt",rpc_path:"gilt",funcs:"\n\t\t\tactive(u32): Option<PalletGiltActiveGilt>\n\t\t\tactiveTotal(): PalletGiltActiveGiltsTotal\n\t\t\tqueues(u32): Vec<PalletGiltGiltBid>\n\t\t\tqueueTotals(): Vec<(u32,u128)>\n\t\t"},{name:"Grandpa",rpc_path:"grandpa",funcs:"\n\t\t\tcurrentSetId(): u64\n\t\t\tnextForced(): Option<u32>\n\t\t\tpendingChange(): Option<PalletGrandpaStoredPendingChange>\n\t\t\tsetIdSession(u64): Option<u32>\n\t\t\tstalled(): Option<(u32,u32)>\n\t\t\tstate(): PalletGrandpaStoredState\n\t\t"},{name:"Identity",rpc_path:"identity",funcs:"\n\t\t\tidentityOf(AccountId32): Option<PalletIdentityRegistration>\n\t\t\tregistrars(): Vec<Option<PalletIdentityRegistrarInfo>>\n\t\t\tsubsOf(AccountId32): (u128,Vec<AccountId32>)\n\t\t\tsuperOf(AccountId32): Option<(AccountId32,Data)>\n\t\t"},{name:"ImOnline",rpc_path:"imOnline",funcs:"\n\t\t\tauthoredBlocks(u32, AccountId32): u32\n\t\t\theartbeatAfter(): u32\n\t\t\tkeys(): Vec<PalletImOnlineSr25519AppSr25519Public>\n\t\t\treceivedHeartbeats(u32, u32): Option<WrapperOpaque<PalletImOnlineBoundedOpaqueNetworkState>>\n\t\t"},{name:"Indices",rpc_path:"indices",funcs:"\n\t\t\taccounts(u32): Option<(AccountId32,u128,bool)>\n\t\t"},{name:"Lottery",rpc_path:"lottery",funcs:"\n\t\t\tcallIndices(): Vec<(u8,u8)>\n\t\t\tlottery(): Option<PalletLotteryLotteryConfig>\n\t\t\tlotteryIndex(): u32\n\t\t\tparticipants(AccountId32): (u32,Vec<(u8,u8)>)\n\t\t\ttickets(u32): Option<AccountId32>\n\t\t\tticketsCount(): u32\n\t\t"},{name:"Mmr",rpc_path:"mmr",funcs:"\n\t\t\tnodes(u64): Option<H256>\n\t\t\tnumberOfLeaves(): u64\n\t\t\trootHash(): H256\n\t\t"},{name:"Multisig",rpc_path:"multisig",funcs:"\n\t\t\tcalls([u8;32]): Option<(WrapperKeepOpaque<Call>,AccountId32,u128)>\n\t\t\tmultisigs(AccountId32, [u8;32]): Option<PalletMultisigMultisig>\n\t\t"},{name:"Offences",rpc_path:"offences",funcs:"\n\t\t\tconcurrentReportsIndex([u8;16], Bytes): Vec<H256>\n\t\t\treports(H256): Option<SpStakingOffenceOffenceDetails>\n\t\t\treportsByKindIndex([u8;16]): Bytes\n\t\t"},{name:"Preimage",rpc_path:"preimage",funcs:"\n\t\t\tpreimageFor(H256): Option<Bytes>\n\t\t\tstatusFor(H256): Option<PalletPreimageRequestStatus>\n\t\t"},{name:"Proxy",rpc_path:"proxy",funcs:"\n\t\t\tannouncements(AccountId32): (Vec<PalletProxyAnnouncement>,u128)\n\t\t\tproxies(AccountId32): (Vec<PalletProxyProxyDefinition>,u128)\n\t\t"},{name:"RandomnessCollectiveFlip",rpc_path:"randomnessCollectiveFlip",funcs:"\n\t\t\trandomMaterial(): Vec<H256>\n\t\t"},{name:"Recovery",rpc_path:"recovery",funcs:"\n\t\t\tactiveRecoveries(AccountId32, AccountId32): Option<PalletRecoveryActiveRecovery>\n\t\t\tproxy(AccountId32): Option<AccountId32>\n\t\t\trecoverable(AccountId32): Option<PalletRecoveryRecoveryConfig>\n\t\t"},{name:"Scheduler",rpc_path:"scheduler",funcs:"\n\t\t\tagenda(u32): Vec<Option<PalletSchedulerScheduledV3>>\n\t\t\tlookup(Bytes): Option<(u32,u32)>\n\t\t"},{name:"Session",rpc_path:"session",funcs:"\n\t\t\tcurrentIndex(): u32\n\t\t\tdisabledValidators(): Vec<u32>\n\t\t\tkeyOwner((SpCoreCryptoKeyTypeId,Bytes)): Option<AccountId32>\n\t\t\tnextKeys(AccountId32): Option<NodeRuntimeSessionKeys>\n\t\t\tqueuedChanged(): bool\n\t\t\tqueuedKeys(): Vec<(AccountId32,NodeRuntimeSessionKeys)>\n\t\t\tvalidators(): Vec<AccountId32>\n\t\t"},{name:"Society",rpc_path:"society",funcs:"\n\t\t\tbids(): Vec<PalletSocietyBid>\n\t\t\tcandidates(): Vec<PalletSocietyBid>\n\t\t\tdefender(): Option<AccountId32>\n\t\t\tdefenderVotes(AccountId32): Option<PalletSocietyVote>\n\t\t\tfounder(): Option<AccountId32>\n\t\t\thead(): Option<AccountId32>\n\t\t\tmaxMembers(): u32\n\t\t\tmembers(): Vec<AccountId32>\n\t\t\tpayouts(AccountId32): Vec<(u32,u128)>\n\t\t\tpot(): u128\n\t\t\trules(): Option<H256>\n\t\t\tstrikes(AccountId32): u32\n\t\t\tsuspendedCandidates(AccountId32): Option<(u128,PalletSocietyBidKind)>\n\t\t\tsuspendedMembers(AccountId32): bool\n\t\t\tvotes(AccountId32, AccountId32): Option<PalletSocietyVote>\n\t\t\tvouching(AccountId32): Option<PalletSocietyVouchingStatus>\n\t\t"},{name:"Staking",rpc_path:"staking",funcs:"\n\t\t\tactiveEra(): Option<PalletStakingActiveEraInfo>\n\t\t\tbonded(AccountId32): Option<AccountId32>\n\t\t\tbondedEras(): Vec<(u32,u32)>\n\t\t\tcanceledSlashPayout(): u128\n\t\t\tchillThreshold(): Option<Percent>\n\t\t\tcounterForNominators(): u32\n\t\t\tcounterForValidators(): u32\n\t\t\tcurrentEra(): Option<u32>\n\t\t\tcurrentPlannedSession(): u32\n\t\t\tearliestUnappliedSlash(): Option<u32>\n\t\t\terasRewardPoints(u32): PalletStakingEraRewardPoints\n\t\t\terasStakers(u32, AccountId32): PalletStakingExposure\n\t\t\terasStakersClipped(u32, AccountId32): PalletStakingExposure\n\t\t\terasStartSessionIndex(u32): Option<u32>\n\t\t\terasTotalStake(u32): u128\n\t\t\terasValidatorPrefs(u32, AccountId32): PalletStakingValidatorPrefs\n\t\t\terasValidatorReward(u32): Option<u128>\n\t\t\tforceEra(): PalletStakingForcing\n\t\t\thistoryDepth(): u32\n\t\t\tinvulnerables(): Vec<AccountId32>\n\t\t\tledger(AccountId32): Option<PalletStakingStakingLedger>\n\t\t\tmaxNominatorsCount(): Option<u32>\n\t\t\tmaxValidatorsCount(): Option<u32>\n\t\t\tminCommission(): Perbill\n\t\t\tminimumValidatorCount(): u32\n\t\t\tminNominatorBond(): u128\n\t\t\tminValidatorBond(): u128\n\t\t\tnominators(AccountId32): Option<PalletStakingNominations>\n\t\t\tnominatorSlashInEra(u32, AccountId32): Option<u128>\n\t\t\toffendingValidators(): Vec<(u32,bool)>\n\t\t\tpayee(AccountId32): PalletStakingRewardDestination\n\t\t\tslashingSpans(AccountId32): Option<PalletStakingSlashingSlashingSpans>\n\t\t\tslashRewardFraction(): Perbill\n\t\t\tspanSlash((AccountId32,u32)): PalletStakingSlashingSpanRecord\n\t\t\tstorageVersion(): PalletStakingReleases\n\t\t\tunappliedSlashes(u32): Vec<PalletStakingUnappliedSlash>\n\t\t\tvalidatorCount(): u32\n\t\t\tvalidators(AccountId32): PalletStakingValidatorPrefs\n\t\t\tvalidatorSlashInEra(u32, AccountId32): Option<(Perbill,u128)>\n\t\t"},{name:"Substrate",rpc_path:"substrate",funcs:"\n\t\t\tchangesTrieConfig(): u32\n\t\t\tchildStorageKeyPrefix(): u32\n\t\t\tcode(): Bytes\n\t\t\textrinsicIndex(): u32\n\t\t\theapPages(): u64\n\t\t"},{name:"Sudo",rpc_path:"sudo",funcs:"\n\t\t\tkey(): Option<AccountId32>\n\t\t"},{name:"System",rpc_path:"system",funcs:"\n\t\t\taccount(AccountId32): FrameSystemAccountInfo\n\t\t\tallExtrinsicsLen(): Option<u32>\n\t\t\tblockHash(u32): H256\n\t\t\tblockWeight(): FrameSupportWeightsPerDispatchClassU64\n\t\t\tdigest(): SpRuntimeDigest\n\t\t\teventCount(): u32\n\t\t\tevents(): Vec<FrameSystemEventRecord>\n\t\t\teventTopics(H256): Vec<(u32,u32)>\n\t\t\texecutionPhase(): Option<FrameSystemPhase>\n\t\t\textrinsicCount(): Option<u32>\n\t\t\textrinsicData(u32): Bytes\n\t\t\tlastRuntimeUpgrade(): Option<FrameSystemLastRuntimeUpgradeInfo>\n\t\t\tnumber(): u32\n\t\t\tparentHash(): H256\n\t\t\tupgradedToTripleRefCount(): bool\n\t\t\tupgradedToU32RefCount(): bool\n\t\t"},{name:"TechnicalCommittee",rpc_path:"technicalCommittee",funcs:"\n\t\t\tmembers(): Vec<AccountId32>\n\t\t\tprime(): Option<AccountId32>\n\t\t\tproposalCount(): u32\n\t\t\tproposalOf(H256): Option<Call>\n\t\t\tproposals(): Vec<H256>\n\t\t\tvoting(H256): Option<PalletCollectiveVotes>\n\t\t"},{name:"TechnicalMembership",rpc_path:"technicalMembership",funcs:"\n\t\t\tmembers(): Vec<AccountId32>\n\t\t\tprime(): Option<AccountId32>\n\t\t"},{name:"Timestamp",rpc_path:"timestamp",funcs:"\n\t\t\tdidUpdate(): bool\n\t\t\tnow(): u64\n\t\t"},{name:"Tips",rpc_path:"tips",funcs:"\n\t\t\treasons(H256): Option<Bytes>\n\t\t\ttips(H256): Option<PalletTipsOpenTip>\n\t\t"},{name:"TransactionPayment",rpc_path:"transactionPayment",funcs:"\n\t\t\tnextFeeMultiplier(): u128\n\t\t\tstorageVersion(): PalletTransactionPaymentReleases\n\t\t"},{name:"TransactionStorage",rpc_path:"transactionStorage",funcs:"\n\t\t\tblockTransactions(): Vec<PalletTransactionStorageTransactionInfo>\n\t\t\tbyteFee(): Option<u128>\n\t\t\tchunkCount(u32): u32\n\t\t\tentryFee(): Option<u128>\n\t\t\tmaxBlockTransactions(): u32\n\t\t\tmaxTransactionSize(): u32\n\t\t\tproofChecked(): bool\n\t\t\tstoragePeriod(): u32\n\t\t\ttransactions(u32): Option<Vec<PalletTransactionStorageTransactionInfo>>\n\t\t"},{name:"Treasury",rpc_path:"treasury",funcs:"\n\t\t\tapprovals(): Vec<u32>\n\t\t\tproposalCount(): u32\n\t\t\tproposals(u32): Option<PalletTreasuryProposal>\n\t\t"},{name:"Uniques",rpc_path:"uniques",funcs:"\n\t\t\taccount(AccountId32, u32, u32): Option<Null>\n\t\t\tasset(u32, u32): Option<PalletUniquesInstanceDetails>\n\t\t\tattribute(u32, Option<u32>, Bytes): Option<(Bytes,u128)>\n\t\t\tclass(u32): Option<PalletUniquesClassDetails>\n\t\t\tclassAccount(AccountId32, u32): Option<Null>\n\t\t\tclassMetadataOf(u32): Option<PalletUniquesClassMetadata>\n\t\t\tinstanceMetadataOf(u32, u32): Option<PalletUniquesInstanceMetadata>\n\t\t"},{name:"Vesting",rpc_path:"vesting",funcs:"\n\t\t\tstorageVersion(): PalletVestingReleases\n\t\t\tvesting(AccountId32): Option<Vec<PalletVestingVestingInfo>>\n\t\t"}]),Blackprint.registerNode("Polkadot.js/Transaction/Batch",((_class9=class extends Blackprint.Node{constructor(t){super(t);let e=this.setInterface();e.title="Batch Transaction",this._toast=new NodeToast(e),this.iface.on("cable.disconnect",Context.EventSlot,(({port:t})=>{"input"===t.source&&this.update()}))}update(){let{Input:t,Output:e}=this.ref,n=this._toast;if(0===t.Txn.length)return n.warn("Txn is required");n.clear();let a=t.Txn[0].api;if(null==a.tx.utility?.batchAll)return this._toast.error("The network doesn't support this feature");let o=a.tx.utility.batchAll(t.Txn.map((t=>t.txn)));e.Txn=new Transaction(o,a,!0)}}).input={Txn:Blackprint.Port.ArrayOf(Transaction)},_class9.output={Txn:Transaction},_class9)),Blackprint.registerNode("Polkadot.js/Transaction/PaymentInfo",((_class10=class extends Blackprint.Node{constructor(t){super(t);let e=this.setInterface();e.title="Payment Info",this._toast=new NodeToast(e),this.iface.on("cable.disconnect",Context.EventSlot,(({port:t})=>{"input"===t.source&&this.update()}))}async update(){let t,{Input:e,Output:n}=this.ref,a=this._toast;if(!e.Sender)return a.warn("Sender address is required");if(!e.Txn)return a.warn("Txn is required");if(a.clear(),null==e.Txn.api.rpc?.payment?.queryInfo)return this._toast.error("The network doesn't support this feature");try{a.warn("Waiting responses"),t=await e.Txn.txn.paymentInfo(e.Sender)}catch(t){throw a.clear(),t.message.includes("32601: Method not found")?a.error("The network doesn't support this feature"):a.error(t.message),t}a.clear(),n.Info=t}}).input={Sender:String,Txn:Transaction},_class10.output={Info:Blackprint.Port.StructOf(Object,{Fee:{type:Number,handle:t=>+t.partialFee},Weight:{type:Number,handle:t=>+t.weight}})},_class10)),Blackprint.registerNode("Polkadot.js/Transaction/Send",(_class11=class extends Blackprint.Node{constructor(t){super(t);let e=this.setInterface();e.title="Send Transaction";let n=this._toast=new NodeToast(e);this._onStatus=t=>{let{Input:e,Output:a}=this.ref;if("Finalized"===t.status.type){if(n.clear(),n.success(t.status.type),Blackprint.Environment.isBrowser){let a=t.dispatchError;if(null==a&&1===e.Txn.length){let n=e.Txn.api;for(let e=0,o=t.events.length;e<o;e++)if(n.events.utility.BatchInterrupted.is(t.events[e].event)){a=t.events[e].event.data[1];break}}if(null!=a)if(a.isModule){let t=e.Txn.api;try{let e=t.registry.findMetaError(a.asModule),{docs:o,method:s,section:r}=e;n.error(o.join(" ")||`${r}: ${s}`)}catch{console.log("Txn error data:",a.toString()),n.error("Transaction failed")}}else console.log("Txn error data:",a.toString()),n.error("Transaction failed")}null!=t.dispatchError?a.Failed():a.Success()}else n.warn(t.status.type);null==a.TxHash&&null!=t.txHash&&(a.TxHash=t.txHash),a.Status=t},this.iface.on("cable.disconnect",Context.EventSlot,(({port:t})=>{"input"===t.source&&this.update()}))}update(){let{Input:t}=this.ref,e=this._toast;return t.Signer?t.Txn?void e.clear():e.warn("Txn is required"):e.warn("Signer is required")}async submit(){let{Input:t,Output:e}=this.ref,n=this._toast;if(!t.Txn||!t.Signer)return n.error("Some input port need to have a value");n.clear();let a=t.Signer;e.TxHash=null,e.Status=null;let o=t.Txn.txn,s={};t.Nonce&&0!==t.Nonce&&(s.nonce=t.Nonce),n.warn("Sending request");try{a.isPair?await o.signAndSend(a.signer,s,this._onStatus):(s.signer=a.signer,await o.signAndSend(a.address,s,this._onStatus))}catch(t){n.clear(),t.message.includes("32601: Method not found")?n.error("The network doesn't support this feature"):n.error(t.message),e.Failed()}}},_class11.input={Submit:Blackprint.Port.Trigger((function({iface:t}){t.node.submit()})),Signer:Signer,Txn:Transaction,Nonce:Number},_class11.output={Success:Blackprint.Types.Trigger,Failed:Blackprint.Types.Trigger,Status:Object,TxHash:Uint8Array},_class11)),Blackprint.registerNode("Polkadot.js/Account/Transfer/Balance",((_class12=class extends Blackprint.Node{constructor(t){super(t);let e=this.setInterface();e.title="Transfer Balance",this._toast=new NodeToast(e),this.iface.on("cable.disconnect",Context.EventSlot,(({port:t})=>{"input"===t.source&&this.update()}))}update(){let{Input:t,Output:e}=this.ref,n=this._toast;if(!t.API)return n.warn("API is required");if(!t.Address)return n.warn("Address is required");if(null==t.Value)return n.warn("Value is required");let a=t.Value;if(a<0)return n.warn("Value must be positive integer");if(!Number.isInteger(a))return n.warn("Value must be integer, but found floating number: "+a);if(a>Number.MAX_SAFE_INTEGER)return n.warn("Value must be lower than 2^53 - 1");n.clear();let o=t.API.tx.balances.transfer(t.Address,a);e.Txn=new Transaction(o,t.API)}}).input={API:polkadotApi.ApiPromise,Address:String,Value:Number},_class12.output={Txn:Transaction},_class12)),Blackprint.registerNode("Polkadot.js/Convert/Address To/Address",((_class13=class extends Blackprint.Node{constructor(t){super(t),this.setInterface().title="Address to Address",this._toast=new NodeToast(this.iface),this.iface.on("cable.disconnect",Context.EventSlot,(({port:t})=>{"input"===t.source&&this.update()}))}_fail(t){this.output.Address=null,this._toast.warn(t)}update(){let{Input:t,Output:e}=this.ref;if(!t.Address)return this._fail("Address is required");this._toast.clear(),e.Address=polkadotKeyring.encodeAddress(t.Address,t.ChainId)}}).input={Address:String,ChainId:Number},_class13.output={Address:String},_class13)),Blackprint.registerNode("Polkadot.js/Convert/Address To/Uint8Array",((_class14=class extends Blackprint.Node{constructor(t){super(t),this.setInterface().title="Address to Uint8Array",this._toast=new NodeToast(this.iface),this.iface.on("cable.disconnect",Context.EventSlot,(({port:t})=>{"input"===t.source&&this.update()}))}_fail(t){this.output.Bytes=null,this._toast.warn(t)}update(){let{Input:t,Output:e}=this.ref;if(!t.Address)return this._fail("Address is required");this._toast.clear(),e.Bytes=polkadotKeyring.decodeAddress(t.Address)}}).output={Bytes:Uint8Array},_class14.input={Address:String},_class14)),Blackprint.registerNode("Polkadot.js/Convert/String To/Uint8Array",((_class15=class extends Blackprint.Node{constructor(t){super(t),this.setInterface().title="String to Uint8Array"}init(){this.iface.input.In.on("disconnect",Context.EventSlot,(()=>{this.output.Out=null}))}update(){let{Input:t,Output:e}=this.ref;e.Out=polkadotUtil.stringToU8a(t.In)}}).input={In:String},_class15.output={Out:Uint8Array},_class15)),Blackprint.registerNode("Polkadot.js/Convert/Uint8Array To/Hex",((_class16=class extends Blackprint.Node{constructor(t){super(t),this.setInterface().title="Uint8Array to Hex"}init(){this.iface.input.In.on("disconnect",Context.EventSlot,(()=>{this.output.Out=null}))}update(){let{Input:t,Output:e}=this.ref;e.Out=polkadotUtil.u8aToHex(t.In)}}).input={In:Uint8Array},_class16.output={Out:String},_class16)),Blackprint.registerNode("Polkadot.js/Convert/Uint8Array To/String",((_class17=class extends Blackprint.Node{constructor(t){super(t),this.setInterface().title="Uint8Array to String"}init(){this.iface.input.In.on("disconnect",Context.EventSlot,(()=>{this.output.Out=null}))}update(){let{Input:t,Output:e}=this.ref;e.Out=polkadotUtil.u8aToString(t.In)}}).input={In:Uint8Array},_class17.output={Out:String},_class17)),Blackprint.registerNode("Polkadot.js/Events/Account/Balance",((_class18=class extends Blackprint.Node{constructor(t){super(t);let e=this.setInterface();e.title="Account Balance Event",e.type="event",this._toast=new NodeToast(e),this.unsubscribe=()=>{}}init(){let{IInput:t}=this.ref;t.API.on("disconnect",Context.EventSlot,(()=>{this.unsubscribe()}))}async update(){let{Input:t,Output:e}=this.ref;this.unsubscribe();let n=t.API;if(n){if(!n.hasSubscriptions)return this._toast.error("Please use WebSocket for using this feature");this._toast.warn("Subscribing...");try{this.unsubscribe=await n.query.system.account(t.Address,(t=>{e.Data=t}))}catch(t){this._toast.clear(),this._toast.error(t.message)}this._toast.clear(),this._toast.success("Subscribed!")}}destroy(){this.unsubscribe&&this.unsubscribe()}}).type="event",_class18.input={API:polkadotApi.ApiPromise,Address:String},_class18.output={Data:Blackprint.Port.StructOf(Object,{Free:{type:Number,handle:t=>+t.data.free},Reserved:{type:Number,handle:t=>+t.data.reserved},MiscFrozen:{type:Number,handle:t=>+t.data.miscFrozen},FeeFrozen:{type:Number,handle:t=>+t.data.feeFrozen}})},_class18)),Blackprint.registerNode("Polkadot.js/Extension/Get/Signer",((_class19=class extends Blackprint.Node{constructor(t){super(t),this.setInterface().title="Signer",this._toast=new NodeToast(this.iface),this.iface.on("cable.disconnect",Context.EventSlot,(({port:t})=>{"input"===t.source&&this.update()}))}async update(){let{Input:t,Output:e}=this.ref,n=this._toast;if(!t.Address)return n.warn("Address is required");!0!==Context._extensionEnabled&&(n.warn("No access to browser extension"),await Context._extensionEnabled),n.clear();try{var a=await polkadotExtensionDapp.web3FromAddress(t.Address)}catch(t){return n.warn(t.message)}e.Signer=new Signer(!1,t.Address,a.signer)}}).input={Address:String},_class19.output={Signer:Signer},_class19)),Blackprint.registerNode("Polkadot.js/Keyring/Create/Keypair",((_class20=class extends Blackprint.Node{constructor(t){super(t);let e=this.setInterface();e.title="Create Keypair",e.description="Using internal keyring",this._toast=new NodeToast(this.iface),this.iface.on("cable.disconnect",Context.EventSlot,(({port:t})=>{"input"===t.source&&this.update()}))}update(){let{Input:t,Output:e,IInput:n}=this.ref,a=this._toast;t.Keyring===Context._internalKeyring?this.iface.description="Using internal keyring: "+t.Keyring.type:this.iface.description="Using connected keyring: "+t.Keyring.type;let o=this._keyring;this._keyring=t.Keyring,null!=e.Keypair&&(o.removePair(e.Keypair.address),e.Keypair=null);let{Keyring:s,Seed:r,Mnemonic:i}=t;if(i&&r)return!1===this._mnemonic&&0!==n.Seed.cables.length?n.Seed.disconnectAll():void n.Mnemonic.disconnectAll();if(i){if(!polkadotUtilCrypto.mnemonicValidate(i))return a.warn("Invalid mnemonic, it must be 12 or 24 words");e.Keypair=s.addFromMnemonic(i),this._mnemonic=!0}else{if(null==r)return e.Keypair=null,e.Address=null,e.Signer=null,this._mnemonic=!1,a.warn("Seed or Mnemonic is required");if(32!==r.byteLength)return a.warn("Seed must be 32 bytes");e.Keypair=s.addFromSeed(r),this._mnemonic=!1}a.clear();let c=e.Keypair;e.Signer=new Signer(!0,c.address,c),e.Address=c.address}}).input={Keyring:Blackprint.Port.Default(polkadotApi.Keyring,Context._internalKeyring),Seed:Blackprint.Port.Union([String,Uint8Array]),Mnemonic:String},_class20.output={Keypair:Object,Address:String,Signer:Signer},_class20)),Blackprint.registerNode("Polkadot.js/Keyring/Create/Keyring",((_class21=class extends Blackprint.Node{constructor(t){super(t),this.setInterface().title="Keyring",this._toast=new NodeToast(this.iface)}imported(){let{Input:t,Output:e,IInput:n}=this.ref;this.currentKeyType=t.KeyType,e.Keyring=new polkadotApi.Keyring({type:t.KeyType,ss58Format:0}),n.KeyType.on("disconnect",Context.EventSlot,(()=>this.update()))}update(){let{Input:t,Output:e}=this.ref,n=t.KeyType.toLowerCase(),a=this._toast;return this.currentKeyType===n?a.clear():"ed25519"!==n&&"sr25519"!==n&&"ethereum"!==n&&"ecdsa"!==n?a.warn("Invalid KeyType, it must be ed25519, sr25519, ethereum, or ecdsa"):(e.Keyring=new polkadotApi.Keyring({type:n,ss58Format:0}),this.currentKeyType=n,void a.clear())}}).input={KeyType:Blackprint.Port.Default(String,"ed25519")},_class21.output={Keyring:polkadotApi.Keyring},_class21)),Blackprint.registerNode("Polkadot.js/Keyring/Create/Mnemonic",((_class22=class extends Blackprint.Node{constructor(t){super(t),this.setInterface().title="Create Mnemonic"}imported(){this.output.Text=polkadotUtilCrypto.mnemonicGenerate(12)}}).output={Text:String},_class22)),Blackprint.registerNode("Polkadot.js/Keyring/Create/Seed",((_class23=class extends Blackprint.Node{constructor(t){super(t),this.setInterface().title="Random Seed"}imported(){this.output.Seed=polkadotUtilCrypto.randomAsU8a(32)}}).output={Seed:Uint8Array},_class23));
//# sourceMappingURL=nodes-polkadotjs.mjs.map